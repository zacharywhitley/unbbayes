import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.math3.distribution.TDistribution;
import org.apache.commons.math3.stat.descriptive.SummaryStatistics;

import unbbayes.prs.INode;
import unbbayes.prs.bn.PotentialTable;
import unbbayes.prs.bn.ProbabilisticTable;
import unbbayes.util.Debug;
import au.com.bytecode.opencsv.CSVReader;

/**
 * 
 */

/**
 * Calculates some statistics from the simulations generated by {@link DirichletUserSimulator}
 * @author Shou Matsumoto
 *
 */
public class SimulatedUserStatisticsCalculator extends DirichletUserSimulator {

	private boolean isToAdd1ToCounts = true;
	
	private float confidence = .95f;
	private List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();
	
	/**
	 * 
	 */
	public SimulatedUserStatisticsCalculator() {
		this.set1stLineForNames(true);
	}
	
	public static class Query {
		private List<String> conditions = Collections.emptyList();
		private List<String> conditionsStates = Collections.emptyList();
		private String query = "";
		private String queryState = "";
		private SummaryStatistics statistics = new SummaryStatistics();
		private String queriedString = null;
		public List<String> getConditions() {
			return this.conditions;
		}
		public void setConditions(List<String> conditions) {
			this.conditions = conditions;
		}
		public String getQuery() {
			return this.query;
		}
		public void setQuery(String query) {
			this.query = query;
		}
		public SummaryStatistics getStatistics() {
			return this.statistics;
		}
		public void setStatistics(SummaryStatistics statistics) {
			this.statistics = statistics;
		}
		public List<String> getConditionsStates() {
			return conditionsStates;
		}
		public void setConditionsStates(List<String> conditionsStates) {
			this.conditionsStates = conditionsStates;
		}
		public String getQueryState() {
			return queryState;
		}
		public void setQueryState(String queryState) {
			this.queryState = queryState;
		}
		public String getQueriedString() {
			return this.queriedString;
		}
		public void setQueriedString(String queriedString) {
			this.queriedString = queriedString;
		}
		/**
		 * @param confidence : Number between 0 and 1 use indicating confidence (as in confidence interval). 
		 * Use .95 by default.
		 * @return a confidence interval that can be obtained from {@link #getStatistics()}
		 */
		public Entry<Float, Float> getConfidenceInterval(float confidence) {
			SummaryStatistics statistics = this.getStatistics();
			
			// extract the statistics we need
			double average = statistics.getMean();
			double stdDeviation = statistics.getStandardDeviation(); 
			long sampleSize = statistics.getN();
			
			// prepare the student t distribution
			TDistribution tdistro = new TDistribution(sampleSize - 1);
			
			// the coefficient (of t-distribution) to be used to calculate the upper and lower bounds
			double coefficient = tdistro.inverseCumulativeProbability(getCumulativeProbFromConfidence(confidence));
			
			// lower bound is average - diff. Upper bound is average + diff
			double diff = (coefficient * stdDeviation)/Math.sqrt(sampleSize);
			Float lower = (float) (average - diff);
			Float upper = (float) (average + diff);
			
			// convert the pair to an instance of Entry.
			// TODO instantiate an Entry instead of delegating to Map
			return Collections.singletonMap(lower, upper).entrySet().iterator().next();
		}
		
	}
	
	
	/**
	 * Converts confidence level to an input to be used in inverse cumulative probability function of t-student distribution.
	 * @param confidenceLevel
	 * @return
	 */
	public static float getCumulativeProbFromConfidence(float confidenceLevel){
		float complement = 1 - confidenceLevel;
		return confidenceLevel + complement/2;
	}
	

	/**
	 * @param query : output argument. 
	 * @param toParse : string in a format like "P(X=state|Y=state)"
	 * @see Query#setQuery(String)
	 * @see Query#setQueryState(String)
	 * @see Query#setConditions(List)
	 * @see Query#setConditionsStates(List)
	 */
	public void fillQueriedVarAndStates(String toParse, Query query) {
		// remove white spaces
		toParse = toParse.trim().replaceAll("\\s","");
		
		if (!toParse.matches("P\\([a-zA-Z_][a-zA-Z0-9_]*=[a-zA-Z0-9_]+\\|[a-zA-Z_][a-zA-Z0-9_]*=[a-zA-Z0-9_]+\\)")) {
			throw new IllegalArgumentException("Query needs to match format P(X=state|Y=state)");
		}
		
		String[] split = toParse.split("(P\\(|\\||\\)|=)");
		if (split[0].trim().isEmpty()) {
			split = Arrays.copyOfRange(split, 1, split.length);
		}
		if (split.length != 4) {
			throw new IllegalArgumentException("Current version only supports format 1 queried node and 1 condition: format P(X=state|Y=state)");
		}
		
//		if (!split[0].matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
//			throw new IllegalArgumentException("Names need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[1].matches("[a-zA-Z0-9_]+")) {
//			throw new IllegalArgumentException("States need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[2].matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
//			throw new IllegalArgumentException("Names need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[3].matches("[a-zA-Z0-9_]+")) {
//			throw new IllegalArgumentException("States need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
		
		query.setQuery(split[0]);
		query.setQueryState(split[1]);
		query.setConditions(Collections.singletonList(split[2]));
		query.setConditionsStates(Collections.singletonList(split[3]));
		query.setQueriedString(toParse);
	}
	
	/*
	 * (non-Javadoc)
	 * @see DirichletUserSimulator#runSingleSimulation(java.util.List, java.io.File, int)
	 */
	public void runSingleSimulation(List<PotentialTable> jointProbabilities, File output, int numSimulation) throws IOException {
		throw new UnsupportedOperationException();
	}

	

	/*
	 * (non-Javadoc)
	 * @see ExpectationPrinter#getJointProbabilityFromFile(java.io.File)
	 */
	public PotentialTable getJointProbabilityFromFile(File file) throws IOException {
		
		CSVReader reader = new CSVReader(new FileReader(file));
		
		
		// read csv file line-by-line
		
		
		List<String> varNames = new ArrayList<String>();
		
		// read the 1st line of csv (name of the columns)
		String[] csvLine = null;
		
		csvLine = reader.readNext();
		for (int column = 0; column < csvLine.length; column++) {
			String name = csvLine[column];
			varNames.add(name);
		}
		
		if (varNames.isEmpty()) {
			varNames = getNameList(defaultIndicatorNames);
			varNames.add(0, DEFAULT_THREAT_NAME);
		}
		
		PotentialTable jointTable = super.getJointTable(null, varNames);
		if (isToAdd1ToCounts()) {
			jointTable.fillTable(1f);	// add count 1 to everyone
		} else {
			jointTable.fillTable(0f);	// initialize counts with zeros
		}
		
		// read the remaining file and fill joint table with counts
		for (csvLine = reader.readNext(); csvLine != null; csvLine = reader.readNext()) {
			if (csvLine.length <= 0) {
				continue;	// ignore empty lines
			}
			
			// each line in csv file is something like 1,0,0,1 (this means 1st var is yes, second var is no, 3rd var is no, and 4th var is yes).
			
			// figure out which cell in joint table represents the value in current line
			int[] coord = jointTable.getMultidimensionalCoord(0);
			if (csvLine.length != coord.length) {
				reader.close();
				throw new IOException("File is expected to have " + coord.length + " columns, but the number of columns was " + csvLine.length);
			}
			for (int columnInCSV = 0; columnInCSV < csvLine.length; columnInCSV++) {
				
				int columnInTable = (coord.length-1) - columnInCSV;
				
				// check which state is true and which state is false
				INode var = jointTable.getVariableAt(columnInTable);
				int trueState = -1;
				int falseState = -1;
				for (int state = 0; state < var.getStatesSize(); state++) {
					if (var.getStateAt(state).trim().equalsIgnoreCase("Yes")
							|| var.getStateAt(state).trim().equalsIgnoreCase("true")) {
						trueState = state;
					} else if (var.getStateAt(state).trim().equalsIgnoreCase("No")
							|| var.getStateAt(state).trim().equalsIgnoreCase("false")) {
						falseState = state;
					} else {
						reader.close();
						throw new IOException("Invalid state found in variable " + var.getName() + ": " + var.getStateAt(state));
					}
				}
				
				if (csvLine[columnInCSV].trim().equalsIgnoreCase("true")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("yes")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("1")) {
					coord[columnInTable] = trueState;
				} else if (csvLine[columnInCSV].trim().equalsIgnoreCase("false")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("no")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("0")) {
					coord[columnInTable] = falseState;
				} else {
					reader.close();
					throw new IOException("Unknown state found in file " + file.getName() + ": " + csvLine[columnInCSV]);
				}
			}
			
			// increment current cell in table
			int cell = jointTable.getLinearCoord(coord);
			jointTable.setValue(cell, jointTable.getValue(cell)+1);
		}
		reader.close();
		
		// normalize joint table, so that joint table becomes a table of proportions
		jointTable.normalize();
		
		return jointTable;
	}
	
	
	
	/*
	 * (non-Javadoc)
	 * @see DirichletUserSimulator#run()
	 */
	public void run() throws IOException {
		File input = getInput();
		if (input.isDirectory()) {
			// read all files in the directory
			List<File> files = new ArrayList<File>(Arrays.asList(input.listFiles()));
			Collections.sort(files, new Comparator<File>() {
				public int compare(File o1, File o2) {
					return o1.getName().compareTo(o2.getName());
				}
			});
			for (File internalFile : files) {
				this.fillQueriesFromFile(internalFile, getQueries());
			}
		} else if (input.isFile()) {
			// read a single file
			this.fillQueriesFromFile(input, getQueries());
		} else {
			throw new IllegalArgumentException(input.getName() + " is not a valid accessible file/directory.");
		}
		
		// print query results
		System.out.println("\"Query\",\"Average\",\"Std.Dev.\",\"" + getConfidence() + " C.I., lower bound\",\""+ getConfidence() + " C.I., upper bound\"");
		for (Query query : getQueries()) {
			System.out.print("\""+query.getQueriedString()+"\",");
			System.out.print(query.getStatistics().getMean()+",");
			System.out.print(query.getStatistics().getStandardDeviation()+",");
			Entry<Float, Float> ci = query.getConfidenceInterval(getConfidence());
			System.out.print(ci.getKey()+",");
			System.out.println(ci.getValue()+",");
		}
	}

	
	/**
	 * 
	 * @param file
	 * @throws IOException
	 */
	public void fillQueriesFromFile(File file, List<Query> queries) throws IOException {
		if (queries == null || queries.isEmpty()) {
			return;
		}
		if (file.isDirectory()) {
			// read all files in the directory
			List<File> files = new ArrayList<File>(Arrays.asList(file.listFiles()));
			Collections.sort(files, new Comparator<File>() {
				public int compare(File o1, File o2) {
					return o1.getName().compareTo(o2.getName());
				}
			});
			for (File internalFile : files) {
				this.fillQueriesFromFile(internalFile, queries);
			}
			return;
		} 
		
		// read current file
		PotentialTable jointTable = this.getJointProbabilityFromFile(file);
		
		// build a map of names to variable, for easy access
		Map<String, INode> varMap = new HashMap<String, INode>();
		for (int i = 0; i < jointTable.getVariablesSize(); i++) {
			varMap.put(jointTable.getVariableAt(i).getName(), jointTable.getVariableAt(i));
		}
		
		
		// iterate on queries and update their statistics
		List<PotentialTable> queriedTables = new ArrayList<PotentialTable>(queries.size());
		for (Query query : queries) {
			
			// retrieve what was queried
			INode queriedVar = varMap.get(query.getQuery());
			if (queriedVar == null) {
				throw new RuntimeException("Queried variable not found: " + query.getQuery());
			}
			
			// retrieve what was conditioned
			if (query.getConditions().size() > 1) {
				throw new UnsupportedOperationException("Current version does not allow more than 1 condition");
			}
			
			INode conditionedVar = null;
			if (query.getConditions().size() == 1) {
				conditionedVar = varMap.get(query.getConditions().get(0));
			}
			
			// build a potential table which represents the query
			PotentialTable queryTable = new ProbabilisticTable();
			queryTable.addVariable(queriedVar);
			queryTable.addVariable(conditionedVar);
			
			queriedTables.add(queryTable);
		}
		
		fillTablesFromJointProbability(queriedTables, jointTable);
		
		// convert queried tables from joint probabilities to conditional probabilities;
		for (PotentialTable table : queriedTables) {
			// calculate marginal of condition, so that we can use it to calculate conditional
			PotentialTable marginalTable = table.getTemporaryClone();
			marginalTable.removeVariable(table.getVariableAt(0));	// the first variable is the queried var, so if we remove it, we have the marginal of the conditions.
			table.opTab(marginalTable, table.DIVISION_OPERATOR);
//			for (int i = 0; i < table.tableSize(); i++) {
//				int[] coord = table.getMultidimensionalCoord(i);
//				table.setValue(i, table.getValue(i) / marginalTable.getValue(coord[1]));
//			}
		}
		
		// add to query statistics the cell in conditional table which matches with the queried element;
		for (int i = 0; i < queries.size(); i++) {
			Query query = queries.get(i);
			PotentialTable queryTable = queriedTables.get(i);
			
			// find queried state
			String state = query.getQueryState().trim();
			boolean isTrue = false;
			if (state.equalsIgnoreCase("Yes") || state.equalsIgnoreCase("true")  || state.equalsIgnoreCase("1")) {
				isTrue = true;
			}
			
			// search for index 
			int queriedStateIndex = 0;
			for (; queriedStateIndex < queryTable.getVariableAt(0).getStatesSize(); queriedStateIndex++) {
				if (queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("Yes")
						|| queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("true")) {
					if (isTrue) {
						break;
					}
				}
				if (queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("No")
						|| queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("false")) {
					if (!isTrue) {
						break;
					}
				}
			}
			
			state = query.getConditionsStates().get(0).trim();
			isTrue = false;
			if (state.equalsIgnoreCase("Yes") || state.equalsIgnoreCase("true")  || state.equalsIgnoreCase("1")) {
				isTrue = true;
			}
			int conditionStateIndex = 0;
			for (; conditionStateIndex < queryTable.getVariableAt(0).getStatesSize(); conditionStateIndex++) {
				if (queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("Yes")
						|| queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("true")) {
					if (isTrue) {
						break;
					}
				}
				if (queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("No")
						|| queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("false")) {
					if (!isTrue) {
						break;
					}
				}
			}
			
			int[] coord = queryTable.getMultidimensionalCoord(0);
			coord[0] = queriedStateIndex;
			coord[1] = conditionStateIndex;
			query.getStatistics().addValue(queryTable.getValue(coord));
		}
		
		
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		CommandLineParser parser = new DefaultParser();
		Options options = new Options();
		options.addOption("d","debug", false, "Enables debug mode.");
		options.addOption("i","input", true, "File or directory to get joint probabilities from.");
		options.addOption("c","confidence", true, "Number between 0 and 1 which denotes confidence (for confidence interval)");
		options.addOption("q","query", true, "Probabilities in the format of \"P(X=state|Y=state)\" to be queried.");
		options.addOption("h","help", false, "Help.");
		
		CommandLine cmd = null;
		try {
			cmd = parser.parse(options, args);
		} catch (ParseException e) {
			e.printStackTrace();
			return;
		}
		
		if (cmd == null) {
			System.err.println("Invalid command line");
			return;
		}
		

		if (cmd.hasOption("h")) {
			System.out.println("-i <FILE NAME> : file or directory containing csv files of joint probabilities.");
			System.out.println("-c <SOME NUMBER> : number between 0 and 1 which denotes confidence (for confidence interval).");
			System.out.println("-q <STRING> : queries in the format of \"P(X=state|Y=state)\". Multiple queries can be performed.");
			System.out.println("-d : Enables debug mode.");
			System.out.println("-h: Help.");
			return;
		}
		
		if (cmd.hasOption("d")) {
			Debug.setDebug(true);
		} else {
			Debug.setDebug(false);
		}
		
		SimulatedUserStatisticsCalculator sim = new SimulatedUserStatisticsCalculator();
		if (cmd.hasOption("i")) {
			sim.setInput(new File(cmd.getOptionValue("i")));
		}
		if (cmd.hasOption("c")) {
			sim.setConfidence(Float.parseFloat(cmd.getOptionValue("c")));
		}
		
		List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();
		if (cmd.hasOption("q")) {
			String[] optionValues = cmd.getOptionValues("q");
			for (String toParse : optionValues) {
				Query q = new Query();
				sim.fillQueriedVarAndStates(toParse, q);
				q.setStatistics(new SummaryStatistics());
				queries.add(q);
			}
			sim.setQueries(queries);
		}
		
		try {
			sim.run();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}


	/**
	 * @return the confidence
	 */
	public float getConfidence() {
		return confidence;
	}

	/**
	 * @param confidence the confidence to set
	 */
	public void setConfidence(float confidence) {
		if (confidence < 0 || confidence > 1) {
			throw new IllegalArgumentException("Confidence needs to be a value between 0 and 1.");
		}
		this.confidence = confidence;
	}

	/**
	 * @return the queries
	 */
	public List<Query> getQueries() {
		return queries;
	}

	/**
	 * @param queries the queries to set
	 */
	public void setQueries(List<Query> queries) {
		this.queries = queries;
	}


	/**
	 * @return the isToAdd1ToCounts
	 */
	public boolean isToAdd1ToCounts() {
		return isToAdd1ToCounts;
	}


	/**
	 * @param isToAdd1ToCounts the isToAdd1ToCounts to set
	 */
	public void setToAdd1ToCounts(boolean isToAdd1ToCounts) {
		this.isToAdd1ToCounts = isToAdd1ToCounts;
	}



}
