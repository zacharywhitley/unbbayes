package utils;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.math3.distribution.BetaDistribution;
import org.apache.commons.math3.distribution.BinomialDistribution;
import org.apache.commons.math3.distribution.TDistribution;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import unbbayes.prs.INode;
import unbbayes.prs.Node;
import unbbayes.prs.bn.PotentialTable;
import unbbayes.prs.bn.ProbabilisticTable;
import unbbayes.util.Debug;
import au.com.bytecode.opencsv.CSVReader;
import cc.mallet.types.Dirichlet;
import cc.mallet.util.Randoms;

/**
 * 
 */

/**
 * Calculates some statistics from the simulations generated by {@link DirichletUserSimulator}
 * @author Shou Matsumoto
 *
 */
public class SimulatedUserStatisticsCalculator extends DirichletUserSimulator {

	private boolean isToAdd1ToCounts = false;
	
	private float confidence = .95f;
	private List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();

	private boolean isToPrintSummary = false;
	private boolean isToPrintAll = false;
	
	private Map<String, String> queryAlias = QUERY_ALIAS_RCP1;

	private boolean isToIgnoreNaN = false;

	private Float defaultNaNPrintAlias = -1f;
	
	public static final Map<String, String> QUERY_ALIAS_RCP1 = new HashMap<String, String>();
	static {
		QUERY_ALIAS_RCP1.put("P(Alert=true|Threat=true)", "Q01");
		QUERY_ALIAS_RCP1.put("P(Threat=true|Alert=true)", "Q02");
		QUERY_ALIAS_RCP1.put("P(Alert=true|Threat=false)", "Q03");
		
		QUERY_ALIAS_RCP1.put("P(Alert=true|I1=true)", "Q04");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I2=true)", "Q05");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I3=true)", "Q06");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I4=true)", "Q07");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I5=true)", "Q08");
		
		QUERY_ALIAS_RCP1.put("P(I1=true|Alert=true)", "Q09");
		QUERY_ALIAS_RCP1.put("P(I2=true|Alert=true)", "Q10");
		QUERY_ALIAS_RCP1.put("P(I3=true|Alert=true)", "Q11");
		QUERY_ALIAS_RCP1.put("P(I4=true|Alert=true)", "Q12");
		QUERY_ALIAS_RCP1.put("P(I5=true|Alert=true)", "Q13");
	}
	
	public static final Map<String, String> QUERY_ALIAS_RCP2 = new HashMap<String, String>();
	static {
		QUERY_ALIAS_RCP2.put("P(Alert=true|Threat=true)", "Q01");
		QUERY_ALIAS_RCP2.put("P(Threat=true|Alert=true)", "Q02");
		QUERY_ALIAS_RCP2.put("P(Alert=true|Threat=false)", "Q03");
		
		QUERY_ALIAS_RCP2.put("P(Alert=true|I1=true)", "Q04");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I2=true)", "Q05");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I3=true)", "Q06");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I4=true)", "Q07");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I5=true)", "Q08");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I6=true)", "Q09");
		
		QUERY_ALIAS_RCP2.put("P(I1=true|Alert=true)", "Q10");
		QUERY_ALIAS_RCP2.put("P(I2=true|Alert=true)", "Q11");
		QUERY_ALIAS_RCP2.put("P(I3=true|Alert=true)", "Q12");
		QUERY_ALIAS_RCP2.put("P(I4=true|Alert=true)", "Q13");
		QUERY_ALIAS_RCP2.put("P(I5=true|Alert=true)", "Q14");
		QUERY_ALIAS_RCP2.put("P(I6=true|Alert=true)", "Q15");
	}
	
	public static final Map<String, String> QUERY_ALIAS_RCP3 = new HashMap<String, String>();

	
	/**
	 * Types of sub-sampling supported by {@link SimulatedUserStatisticsCalculator#getJointProbabilityFromFile(File, boolean, boolean, boolean)}
	 * and {@link SimulatedUserStatisticsCalculator#getConditionalProbabilityFromQueryTable(PotentialTable)}.
	 */
	public static enum SubSamplingMode {WEIGHTED, BETA_BINOMIAL};
	private SubSamplingMode subSamplingMode = SubSamplingMode.BETA_BINOMIAL;
	private int numSubSampleSimulation = 100;
	private int stratifiedSampleNumTotal = 100;
	private int stratifiedSampleNumAlert = -1;//30;	// negative values mean no sub-sampling will be performed
	private boolean isToNormalize = false;
	private float priorCount = 1;				// beta binomial prior is 1
	
	static {
		QUERY_ALIAS_RCP3.put("P(Alert=true|Threat=true)", "Q01");
		QUERY_ALIAS_RCP3.put("P(Threat=true|Alert=true)", "Q02");
		QUERY_ALIAS_RCP3.put("P(Alert=true|Threat=false)", "Q03");
		
		QUERY_ALIAS_RCP3.put("P(Alert=true|I1=true)", "Q04");
		QUERY_ALIAS_RCP3.put("P(Alert=true|I2=true)", "Q05");
		QUERY_ALIAS_RCP3.put("P(Alert=true|I3=true)", "Q06");
		QUERY_ALIAS_RCP3.put("P(Alert=true|I4=true)", "Q07");
		
		QUERY_ALIAS_RCP3.put("P(I1=true|Alert=true)", "Q08");
		QUERY_ALIAS_RCP3.put("P(I2=true|Alert=true)", "Q09");
		QUERY_ALIAS_RCP3.put("P(I3=true|Alert=true)", "Q10");
		QUERY_ALIAS_RCP3.put("P(I4=true|Alert=true)", "Q11");
	}
	
	public SimulatedUserStatisticsCalculator() {
		this.set1stLineForNames(true);
		this.setOutput(new File("output.csv"));
	}
	public static SimulatedUserStatisticsCalculator getInstance() {
		return new SimulatedUserStatisticsCalculator();
	}
	public static SimulatedUserStatisticsCalculator getInstance(int numUsers, int numOrganization) {
		SimulatedUserStatisticsCalculator ret = SimulatedUserStatisticsCalculator.getInstance();
		ret.setNumUsers(numUsers);
		ret.setNumOrganization(numOrganization);
		return ret;
	}
	
	public static class Query {
		private boolean isToUsePercentileForConfidenceInterval = true;
		private List<String> conditions = Collections.emptyList();
		private List<String> conditionsStates = Collections.emptyList();
		private String query = "";
		private String queryState = "";
		private DescriptiveStatistics statistics = new DescriptiveStatistics();
		private String queriedString = null;
		private List<Float> values = new ArrayList<Float>();
		private boolean isJointProbability = false;
		public List<String> getConditions() {
			return this.conditions;
		}
		public void setConditions(List<String> conditions) {
			this.conditions = conditions;
		}
		public String getQuery() {
			return this.query;
		}
		public void setQuery(String query) {
			this.query = query;
		}
		public DescriptiveStatistics getStatistics() {
			return this.statistics;
		}
		public void setStatistics(DescriptiveStatistics statistics) {
			this.statistics = statistics;
		}
		public List<String> getConditionsStates() {
			return conditionsStates;
		}
		public void setConditionsStates(List<String> conditionsStates) {
			this.conditionsStates = conditionsStates;
		}
		public String getQueryState() {
			return queryState;
		}
		public void setQueryState(String queryState) {
			this.queryState = queryState;
		}
		public String getQueriedString() {
			return this.queriedString;
		}
		public void setQueriedString(String queriedString) {
			this.queriedString = queriedString;
		}
		public List<Float> getValues() {
			return values;
		}
		public void setValues(List<Float> values) {
			this.values = values;
		}
		public boolean isToUsePercentileForConfidenceInterval() {
			return isToUsePercentileForConfidenceInterval;
		}
		public void setToUsePercentileForConfidenceInterval(
				boolean isToUsePercentileForConfidenceInterval) {
			this.isToUsePercentileForConfidenceInterval = isToUsePercentileForConfidenceInterval;
		}
		public boolean isJointProbability() {
			return isJointProbability;
		}
		public void setJointProbability(boolean isJointProbability) {
			this.isJointProbability = isJointProbability;
		}
		/**
		 * @param confidence : Number between 0 and 1 use indicating confidence (as in confidence interval). 
		 * Use .95 by default.
		 * @return a confidence interval that can be obtained from {@link #getStatistics()}
		 */
		public Entry<Float, Float> getInterval(float confidence) {
			DescriptiveStatistics statistics = this.getStatistics();
			
			if (isToUsePercentileForConfidenceInterval()) {
				Float upper = (float) statistics.getPercentile((confidence+((1-confidence)/2)) * 100);
				Float lower = (float) statistics.getPercentile(((1-confidence)/2) * 100);
				return Collections.singletonMap(lower, upper).entrySet().iterator().next();
			}
			
			// extract the statistics we need
			double average = statistics.getMean();
			double stdDeviation = statistics.getStandardDeviation(); 
			long sampleSize = statistics.getN();
			
			// prepare the student t distribution
			TDistribution tdistro = new TDistribution(sampleSize - 1);
			
			// the coefficient (of t-distribution) to be used to calculate the upper and lower bounds
			double coefficient = tdistro.inverseCumulativeProbability(getCumulativeProbFromConfidence(confidence));
			
			// lower bound is average - diff. Upper bound is average + diff
			double diff = (coefficient * stdDeviation)/Math.sqrt(sampleSize);
			Float lower = (float) (average - diff);
			Float upper = (float) (average + diff);
			
			// convert the pair to an instance of Entry.
			// TODO instantiate an Entry instead of delegating to Map
			return Collections.singletonMap(lower, upper).entrySet().iterator().next();
		}
		
		public void addValue(float value) {
			this.getValues().add(value);
			if (Float.isNaN(value)) {
				Debug.println(getClass(), "Found NaN in " + this);
				return;
			}
			getStatistics().addValue(value);
		}
		public String toString() {
			return this.getQueriedString();
		}
		
		
	}
	
	
	/**
	 * Converts confidence level to an input to be used in inverse cumulative probability function of t-student distribution.
	 * @param confidenceLevel
	 * @return
	 */
	public static float getCumulativeProbFromConfidence(float confidenceLevel){
		float complement = 1 - confidenceLevel;
		return confidenceLevel + complement/2;
	}
	

	/**
	 * @param query : output argument. 
	 * @param toParse : string in a format like "P(X=state|Y=state)" or "P(X=state,Y=state)"
	 * @see Query#setQuery(String)
	 * @see Query#setQueryState(String)
	 * @see Query#setConditions(List)
	 * @see Query#setConditionsStates(List)
	 */
	public void fillQueriedVarAndStates(String toParse, Query query) {
		// remove white spaces
		toParse = toParse.trim().replaceAll("\\s","");
		
		if (!toParse.matches("P\\([a-zA-Z_][a-zA-Z0-9_]*=[a-zA-Z0-9_]+[\\|,][a-zA-Z_][a-zA-Z0-9_]*=[a-zA-Z0-9_]+\\)")) {
			throw new IllegalArgumentException("Query needs to match format P(X=state|Y=state)");
		}
		
		// if it contains a comma and matched the above regex, then it is a query to joint probability
		query.setJointProbability(toParse.contains(","));
		
		String[] split = toParse.split("(P\\(|\\||,|\\)|=)");
		if (split[0].trim().isEmpty()) {
			split = Arrays.copyOfRange(split, 1, split.length);
		}
		if (split.length != 4) {
			throw new IllegalArgumentException("Current version only supports format 1 queried node and 1 condition: format P(X=state|Y=state)");
		}
		
//		if (!split[0].matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
//			throw new IllegalArgumentException("Names need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[1].matches("[a-zA-Z0-9_]+")) {
//			throw new IllegalArgumentException("States need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[2].matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
//			throw new IllegalArgumentException("Names need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[3].matches("[a-zA-Z0-9_]+")) {
//			throw new IllegalArgumentException("States need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
		
		query.setQuery(split[0]);
		query.setQueryState(split[1]);
		query.setConditions(Collections.singletonList(split[2]));
		query.setConditionsStates(Collections.singletonList(split[3]));
		query.setQueriedString(toParse);
	}
	
	/**
	 * @param table
	 * @return : the sum of {@link PotentialTable#getValue(int)} for the entire table.
	 */
	public float sumTableContent(PotentialTable table) {
		float sum = 0;
		if (table != null) {
			for (int i = 0; i < table.tableSize(); i++) {
				sum += table.getValue(i);
			}
		}
		return sum;
	}
	

	/*
	 * (non-Javadoc)
	 * @see ExpectationPrinter#getJointProbabilityFromFile(java.io.File)
	 */
	public PotentialTable getJointProbabilityFromFile(File file) throws IOException {
		return this.getJointProbabilityFromFile(file, getStratifiedSampleNumAlert() >= 0);
	}
	
	/*
	 * (non-Javadoc)
	 * @see utils.ExpectationPrinter#getJointProbabilityFromFile(java.io.File, boolean)
	 */
	public PotentialTable getJointProbabilityFromFile(File file, boolean isToSubSample) throws IOException {
		return this.getJointProbabilityFromFile(file, isToSubSample, getSubSamplingMode() == SubSamplingMode.WEIGHTED, isToNormalize());
	}
	
	/**
	 * Obtains a joint probability from file, but with support for pre-processing for stratified sub-samples 
	 * which consider {@link #getStratifiedSampleNumAlert()} and {@link #getStratifiedSampleNumTotal()}.
	 * <br/>
	 * A subset of {@link #getStratifiedSampleNumTotal()} samples from file will be used to calculate joint probability.
	 * Samples with {@link #getAlertName()} = true will have a weight of:
	 * <pre>
	 * "total number of samples with {@link #getAlertName()} = true" / {@link #getStratifiedSampleNumAlert()}
	 * </pre>
	 * and samples with {@link #getAlertName()} = false will have a weight of:
	 * <pre>
	 * "total number of samples with {@link #getAlertName()} = false" / ({@link #getStratifiedSampleNumTotal()} - {@link #getStratifiedSampleNumAlert()})
	 * </pre>
	 * @param isToSubSample : if true, then {@link #getStratifiedSampleNumAlert()} and {@link #getStratifiedSampleNumTotal()}
	 * will be used to generate samples from file before calculating joint probabilities.
	 * @param isToWeight : if true and isToSubSample is also true, then stratified/weighted samples will be used
	 * @param originalCounts : if this map is filled, the counts of variables identified by key of entries in this map
	 * will be inserted to this map. This is useful when isToSubSample is on, because the original count will be lost otherwise.
	 * @param isToNormalize: if true, then the table to be returned will be normalized to 1.
	 * @see utils.ExpectationPrinter#getJointProbabilityFromFile(java.io.File, boolean)
	 */
	public PotentialTable getJointProbabilityFromFile(File file, boolean isToSubSample, boolean isToWeight, boolean isToNormalize) throws IOException {
		
//		long time = System.currentTimeMillis();
		
		
		CSVReader reader = new CSVReader(new FileReader(file));
		
		
		// read csv file line-by-line
		
		
		List<String> varNames = new ArrayList<String>();
		
		// read the csv rows.
		List<String[]> allRows = reader.readAll();
		
		// read the 1st line of csv (name of the columns)
//		String[] csvLine = null;
//		csvLine = reader.readNext();
		String[] csvLine = allRows.get(0);
		
		
		for (int column = 0; column < csvLine.length; column++) {
			String name = csvLine[column];
			if (name != null && !name.trim().isEmpty()) {
				varNames.add(name);
			}
		}
		
		if (varNames.isEmpty()) {
			varNames = getNameList(getIndicatorNames());
			varNames.add(0, getThreatName());
			if (isToConsiderDetectors()) {
				varNames.addAll(getNameList(getDetectorNames()));
			}
		}
		
		PotentialTable jointTable = super.getJointTable(null, varNames);
		if (isToAdd1ToCounts()) {
			jointTable.fillTable(1f);	// add count 1 to everyone
		} else {
			jointTable.fillTable(0f);	// initialize counts with zeros
		}
		
		
		PotentialTable weightTable = null; 	// if non-null, this weight will be multiplied to number of samples so that counts of samples are converted to weighted samples
		List<String[]> rowsToRead = null;	// this will be filled with samples that will be read from csv (can be the entire file, or subset of the file)
		if (isToSubSample) {
			// check validity of sample numbers
			if (getStratifiedSampleNumAlert() <= 0
					|| getStratifiedSampleNumTotal() <= getStratifiedSampleNumAlert()) {
				reader.close();
				throw new IllegalArgumentException("Invalid number of stratified samples. Alert = true: " + getStratifiedSampleNumAlert()
						 + ". Total: " + getStratifiedSampleNumTotal());
			}
			// check validity of alert variable's name
			if (getAlertName() == null || getAlertName().trim().isEmpty()) {
				reader.close();
				throw new IllegalArgumentException("Invalid alert variable name: " + getAlertName());
			}
			
			if (isToWeight) {
				// prepare the table which will hold weights to be applied to count table
				weightTable = new ProbabilisticTable();
				// search and add the alert variable into weight table
				for (int i = 0; i < jointTable.getVariablesSize(); i++) {
					if (jointTable.getVariableAt(i).getName().equals(getAlertName())) {
						weightTable.addVariable(jointTable.getVariableAt(i));
						break;
					}
				}
				if (weightTable.tableSize() > 2) {
					reader.close();
					throw new UnsupportedOperationException("Current version does not support variable " + getAlertName() + " with size " + weightTable.tableSize());
				}
			}
			
			
			// extract which column in csv is the state of alert variable
			int indexOfAlertInCSV = varNames.indexOf(getAlertName());
			if (indexOfAlertInCSV < 0) {
				if (weightTable != null) {
					indexOfAlertInCSV = jointTable.getVariablesSize() - jointTable.getVariableIndex((Node) weightTable.getVariableAt(0)) - 1;
				}
				if (indexOfAlertInCSV < 0 || indexOfAlertInCSV >= jointTable.getVariablesSize()) {
					reader.close();
					throw new IllegalArgumentException("Alert variable not found in header " + varNames + " or in joint table " + jointTable);
				}
			}
			
			// count how many entries of alert = true and alert = false there are			
			List<Integer> alertTrueRowIndexes = new ArrayList<Integer>();
			List<Integer> alertFalseRowIndexes = new ArrayList<Integer>();
			for (int rowIndex = 1; rowIndex < allRows.size(); rowIndex++) {	// ignore first row, because it's a header
				csvLine = allRows.get(rowIndex);
				String valueInCSV = csvLine[indexOfAlertInCSV];
				Boolean isTrueValue = parseBoolean(valueInCSV);
				if (isTrueValue == null) {
					reader.close();
					throw new IOException("Invalid state found in row " + rowIndex + ", column " + indexOfAlertInCSV + ": " + valueInCSV);
				} else if (isTrueValue) {
					alertTrueRowIndexes.add(rowIndex);
				} else {
					alertFalseRowIndexes.add(rowIndex);
				}
			}
			
			if (alertTrueRowIndexes.size() + alertFalseRowIndexes.size() != allRows.size()-1) {
				reader.close();
				throw new IOException("Number of data in CSV is " + (allRows.size()-1) + ", but sum of alert and non-alert data was " + (alertTrueRowIndexes.size() + alertFalseRowIndexes.size()));
			}
			
			
			// calculate weights;
			if (isToWeight) {
				float weightAlert = ((float)alertTrueRowIndexes.size()) / ((float)getStratifiedSampleNumAlert());
				float weightNonAlert = ((float)alertFalseRowIndexes.size()) / (((float)getStratifiedSampleNumTotal()) - ((float)getStratifiedSampleNumAlert()));
				// if weight is lower than 1, set to 1;
				if (weightAlert < 1) {
					weightAlert = 1;
				}
				if (weightNonAlert < 1) {
					weightNonAlert = 1;
				}
				Debug.println(getClass(), "Weight alert = " + weightAlert + ", weight non-alert = " + weightNonAlert);
				
				// fill weight table 
				if (weightTable.tableSize() == 2) {
					INode alertVar = weightTable.getVariableAt(0);
					int alertTrueStateIndex = -1;
					if (parseBoolean(alertVar.getStateAt(0)) == true) {
						alertTrueStateIndex = 0;
					}
					if (alertTrueStateIndex < 0) {
						reader.close();
						throw new IllegalArgumentException("Cound not find true/yes/1 state in variable " + alertVar);
					}
					weightTable.setValue(alertTrueStateIndex, weightAlert);
					weightTable.setValue((1-alertTrueStateIndex), weightNonAlert);
				} else {
					Debug.println(getClass(), "Found weight table " + weightTable + " with size " + weightTable.tableSize());
				}
			}
			
			// we'll fill rowsToRead with getStratifiedSampleNumTotal() samples.
			rowsToRead = new ArrayList<String[]>(getStratifiedSampleNumTotal());
			// randomly pick getStratifiedSampleNumAlert() samples 
			Random rand = new Random();
			for (int i = 0; i < getStratifiedSampleNumAlert(); i++) {
				if (alertTrueRowIndexes.size() <= 0) {
					Debug.println(getClass(), "There are " + rowsToRead.size() + " cases of alert. Expected alert sample size was: " + getStratifiedSampleNumAlert());
					break;
				}
				int indexToAdd = rand.nextInt(alertTrueRowIndexes.size());
				rowsToRead.add(allRows.get(alertTrueRowIndexes.get(indexToAdd)));
				alertTrueRowIndexes.remove(indexToAdd);	// this is a random pick without substitution
			}
			int numSampleAlert = rowsToRead.size();	// store how many cases of alert we read.
			// randomly pick getStratifiedSampleNumTotal() - getStratifiedSampleNumAlert() samples 
			for (int i = 0; i < getStratifiedSampleNumTotal() - numSampleAlert; i++) {
				if (alertFalseRowIndexes.size() <= 0) {
					Debug.println(getClass(), "There are " + rowsToRead.size() + " total cases. Expected total sample size was: " + getStratifiedSampleNumTotal());
					break;
				}
				int indexToAdd = rand.nextInt(alertFalseRowIndexes.size());
				rowsToRead.add(allRows.get(alertFalseRowIndexes.get(indexToAdd)));
				alertFalseRowIndexes.remove(indexToAdd);
			}
			
		} else {
			// just read all rows except first row
			rowsToRead = allRows.subList(1, allRows.size());
		}
		
		// read the remaining file and fill joint table with counts
//		for (csvLine = reader.readNext(); csvLine != null; csvLine = reader.readNext()) {
		for (int currentRowIndex = 0; currentRowIndex < rowsToRead.size(); currentRowIndex++) {
			csvLine = rowsToRead.get(currentRowIndex);
			if (csvLine.length <= 0) {
				Debug.println(getClass(), "Empty row: " + currentRowIndex);
				continue;	// ignore empty lines
			}
			
			// each line in csv file is something like 1,0,0,1 (this means 1st var is yes, second var is no, 3rd var is no, and 4th var is yes).
			
			// figure out which cell in joint table represents the value in current line
			int[] coord = jointTable.getMultidimensionalCoord(0);
			if (csvLine.length != coord.length) {
				reader.close();
				throw new IOException("File " + file.getAbsolutePath() +  " is expected to have " + coord.length + " columns, but the number of columns was " + csvLine.length);
			}
			for (int columnInCSV = 0; columnInCSV < csvLine.length; columnInCSV++) {
				
				int columnInTable = (coord.length-1) - columnInCSV;
				
				// check which state is true and which state is false
				INode var = jointTable.getVariableAt(columnInTable);
				int trueState = -1;
				int falseState = -1;
				for (int state = 0; state < var.getStatesSize(); state++) {
					Boolean isTrue = parseBoolean(var.getStateAt(state));
					if (isTrue == null) {
						reader.close();
						throw new IOException("Invalid state found in variable " + var.getName() + ": " + var.getStateAt(state));
					} else if (isTrue) {
						trueState = state;
					} else {
						falseState = state;
					}
				}
				
				Boolean isTrue = parseBoolean(csvLine[columnInCSV]);
				if (isTrue == null) {
					reader.close();
					throw new IOException("Unknown state found in file " + file.getName() + ": " + csvLine[columnInCSV]);
				} else if (isTrue) {
					coord[columnInTable] = trueState;
				} else {
					coord[columnInTable] = falseState;
				}
			}
			
			// increment current cell in table
			int cell = jointTable.getLinearCoord(coord);
			jointTable.setValue(cell, jointTable.getValue(cell)+1);
		}
		reader.close();
		
		
		// apply weights;
		if (weightTable != null && weightTable.getVariablesSize() > 0) {
			jointTable.opTab(weightTable, jointTable.PRODUCT_OPERATOR);	// multiply counts in joint table with the weights in weight table
		}
		
		if (isToNormalize) {
			// normalize joint table, so that joint table becomes a table of proportions
			jointTable.normalize();
		}
		
//		Debug.println(getClass(), "Loaded " + file.getName() + " in " + (System.currentTimeMillis() - time) + "ms.");
		
		return jointTable;
	}
	
	
	
	/*
	 * (non-Javadoc)
	 * @see DirichletUserSimulator#run()
	 */
	public void run() throws IOException {
		File input = getInput();
		if (input.isDirectory()) {
			// read all files in the directory
			List<File> files = new ArrayList<File>(Arrays.asList(input.listFiles()));
			Collections.sort(files, new Comparator<File>() {
				public int compare(File o1, File o2) {
					return o1.getName().compareTo(o2.getName());
				}
			});
			for (File internalFile : files) {
				this.fillQueriesFromFile(internalFile, getQueries());
			}
		} else if (input.isFile()) {
			// read a single file
			this.fillQueriesFromFile(input, getQueries());
		} else {
			throw new IllegalArgumentException(input.getName() + " is not a valid accessible file/directory.");
		}
		
		
		if (isToPrintAll()) {	// print in different files
			// print query results
			File file = new File(getOutput().getParentFile(), getOutput().getName() + "_Statistics.csv");
			PrintStream printer = new PrintStream(new FileOutputStream(file, true));
			this.printSummary(printer);
			printer.close();
			// print the data
			file = new File(getOutput().getParentFile(), getOutput().getName() + "_Answers.csv");
			printer = new PrintStream(new FileOutputStream(file, true));
			this.printAnswerData(printer);
			printer.close();
		} else {
			PrintStream printer = new PrintStream(new FileOutputStream(getOutput(), true));
			if (isToPrintSummary()) {
				// print query results
				this.printSummary(printer);
			} else {
				// print the data
				this.printAnswerData(printer);
			}
			printer.close();
		}
		
	}

	/**
	 * 
	 * @param printer
	 */
	protected void printAnswerData(PrintStream printer) {
		// print first line
		int rowSize = -1;
		for (Query query : getQueries()) {
			String label = query.getQueriedString();
			if (getQueryAlias().containsKey(label)) {
				label = getQueryAlias().get(label);
			}
			printer.print("\""+ label + "\",");
			
			// also check number of values for this query
			int size = query.getValues().size();
			if (rowSize < 0) {
				rowSize = size;
			} else if (rowSize != size) {
				printer.close();
				throw new RuntimeException("Found query with " + size + " values, while previous queries had " + rowSize + " values");
			}
		}
		printer.println();
		for (int row = 0; row < rowSize; row++) {	
			String rowToPrint = "";
			boolean hasNaN = false;
			for (Query query : getQueries()) {
				Float value = query.getValues().get(row);
				if (value.isNaN()) {
					if (isToIgnoreNaN()) {
						hasNaN = true;
						break;
					} else {
						value = getDefaultNaNPrintAlias();
					}
				}
				rowToPrint += (value + ",");
			}
			if (!hasNaN) {
				printer.println(rowToPrint);
			}
		}
	}
	/**
	 * 
	 * @param printer
	 */
	protected void printSummary(PrintStream printer) {
		printer.println("\"Query\",\"Average\",\"Std.Dev.\",\"Median\",\"" + getConfidence() + " lower\",\""+ getConfidence() + " upper\"");
		for (Query query : getQueries()) {
			String label = query.getQueriedString();
			if (getQueryAlias().containsKey(label)) {
				label = getQueryAlias().get(label);
			}
			printer.print("\""+label+"\",");
			printer.print(query.getStatistics().getMean()+",");
			printer.print(query.getStatistics().getStandardDeviation()+",");
			printer.print(query.getStatistics().getPercentile(50)+",");
			Entry<Float, Float> ci = query.getInterval(getConfidence());
			printer.print(ci.getKey()+",");
			printer.println(ci.getValue()+",");
		}
	}
	/**
	 * 
	 * @param file
	 * @throws IOException
	 */
	public void fillQueriesFromFile(File file, List<Query> queries) throws IOException {
		if (queries == null || queries.isEmpty()) {
			return;
		}
		if (file.isDirectory()) {
			// read all files in the directory
			List<File> files = new ArrayList<File>(Arrays.asList(file.listFiles()));
			Collections.sort(files, new Comparator<File>() {
				public int compare(File o1, File o2) {
					return o1.getName().compareTo(o2.getName());
				}
			});
			for (File internalFile : files) {
				this.fillQueriesFromFile(internalFile, queries);
			}
			return;
		} 
		
		// read current file. 
		// joint table based on configuration in attributes (can be probabilities, or sub-sampled tables)
		PotentialTable jointTable = this.getJointProbabilityFromFile(file, getStratifiedSampleNumAlert() >= 0, getSubSamplingMode() == SubSamplingMode.WEIGHTED, isToNormalize());
		// a table that counts the occurrences in file without sub-sampling, without weighting, and without normalization
		// this is used later in order to run beta binomial simulation (we need to keep track original counts for it)
		PotentialTable nonNormalizedFullCountTable = null;
		if (((getStratifiedSampleNumAlert() < 0) && (getSubSamplingMode() != SubSamplingMode.WEIGHTED) && !isToNormalize() )	
				|| getSubSamplingMode() == SubSamplingMode.WEIGHTED) {	// we don't need to keep track of original counts in weighted sub-sampling mode
			// just reuse jointTable if it was not sub-sampled, not weighted, and didn't normalize
			nonNormalizedFullCountTable = jointTable;
		} else {
			Debug.println(getClass(), "Sub sampling... Mode = " + getSubSamplingMode());
			// get another table without sub-sampling, without weighting, and without normalization
			nonNormalizedFullCountTable = this.getJointProbabilityFromFile(file, false, false, false);
			// TODO stop reading file twice (it's redundant).
		}
		
		
		// build a map of names to variable, for easy access
		Map<String, INode> varMap = new HashMap<String, INode>();
		for (int i = 0; i < jointTable.getVariablesSize(); i++) {
			varMap.put(jointTable.getVariableAt(i).getName(), jointTable.getVariableAt(i));
		}
		
		
		// iterate on queries and update their statistics
		for (Query query : queries) {
			
			// retrieve what was queried
			INode queriedVar = varMap.get(query.getQuery());
			if (queriedVar == null) {
				throw new RuntimeException("Queried variable not found: " + query.getQuery());
			}
			
			// retrieve what was conditioned
			if (query.getConditions().size() > 1) {
				throw new UnsupportedOperationException("Current version does not allow more than 1 condition");
			}
			
			INode conditionedVar = null;
			if (query.getConditions().size() == 1) {
				conditionedVar = varMap.get(query.getConditions().get(0));
			}
			
			// build a potential table which represents the query
			PotentialTable queryTable = new ProbabilisticTable();
			queryTable.addVariable(queriedVar);
			if (conditionedVar != null && !conditionedVar.equals(queriedVar)) {
				queryTable.addVariable(conditionedVar);
			}
			
			// fill queryTable with joint probability
			fillTablesFromJointProbability(Collections.singletonList(queryTable), jointTable);
			
			// convert queried tables from joint probabilities to conditional probabilities if necessary;
			if (query.isJointProbability()) {
				// just make sure table is normalized.
				queryTable.normalize();
			} else {
				// calculate marginal of condition, so that we can use it to calculate conditional
//				long time = System.currentTimeMillis();
				queryTable = this.getConditionalProbabilityFromQueryTable(queryTable, nonNormalizedFullCountTable);
//				Debug.println(getClass(), "Calculated conditional probability in " + (System.currentTimeMillis() - time) + "ms.");
			}
			
			// add to query statistics the cell in conditional table which matches with the queried element;
			
			// find queried state
			String state = query.getQueryState().trim();
			boolean isTrue = (parseBoolean(state) == true);
			
			// search for index 
			int queriedStateIndex = 0;
			for (; queriedStateIndex < queryTable.getVariableAt(0).getStatesSize(); queriedStateIndex++) {
				Boolean isQueryVarTrue = parseBoolean(queryTable.getVariableAt(0).getStateAt(queriedStateIndex));
				if (isQueryVarTrue == true) {
					if (isTrue) {
						break;
					}
				}
				if (isQueryVarTrue == false) {
					if (!isTrue) {
						break;
					}
				}
			}
			
			state = query.getConditionsStates().get(0).trim();
			isTrue = (parseBoolean(state) == true);
			int conditionStateIndex = 0;
			for (; conditionStateIndex < queryTable.getVariableAt(0).getStatesSize(); conditionStateIndex++) {
				Boolean isQueryVarTrue = parseBoolean(queryTable.getVariableAt(0).getStateAt(conditionStateIndex));
				if (isQueryVarTrue == true) {
					if (isTrue) {
						break;
					}
				}
				if (isQueryVarTrue == false) {
					if (!isTrue) {
						break;
					}
				}
			}
			
			int[] coord = queryTable.getMultidimensionalCoord(0);
			coord[0] = queriedStateIndex;
			coord[1] = conditionStateIndex;
//			query.getStatistics().addValue(queryTable.getValue(coord));
			query.addValue(queryTable.getValue(coord));
		
		}
		
		
	}
	

	/**
	 * Converts a query table (marginalized joint probability or count table) to conditional probability
	 * @param queryTable
	 * @param fullCountTable : record of original counts (because queryTable may have sub-sampled counts).
	 *  This is used for reference when {@link #getSubSamplingMode()} is {@link SubSamplingMode#BETA_BINOMIAL}.
	 * @see #fillQueriesFromFile(File, List)
	 * @see #getJointProbabilityFromFile(File, boolean, boolean, boolean)
	 */
	public PotentialTable getConditionalProbabilityFromQueryTable(PotentialTable queryTable, PotentialTable fullCountTable) {
		if (queryTable == null) {
			throw new NullPointerException("No query table was provided");
		}
		
		// if we need to do beta-binomial sub sampling, do a pre-processing so that queryTable is filled with simulated counts
		if (getStratifiedSampleNumAlert() >= 0 && getSubSamplingMode() == SubSamplingMode.BETA_BINOMIAL) {
			return this.getConditionalProbabilityFromSimulation(queryTable, fullCountTable);
		}
		
		// we can just calculate the conditional probabilities, because the weights were already handled in getJointProbabilityFromFile
		queryTable.normalize();
		PotentialTable marginalTable = queryTable.getTemporaryClone();
		marginalTable.removeVariable(queryTable.getVariableAt(0));	// the first variable is the queried var, so if we remove it, we have the marginal of the conditions.
		queryTable.opTab(marginalTable, queryTable.DIVISION_OPERATOR);
		
		return queryTable;
	}
	
	/**
	 * Runs a beta binomial simulation in order to simulate the full population from a sub-sampled population and
	 * calculate conditional probability from simulated population.
	 * This is useful to incorporate uncertainty to a population read in {@link #getJointProbabilityFromFile(File, boolean, boolean, boolean)}
	 * when this population is known to generated from a sub-sampled population already (so we need to artificially increase the variance).
	 * @param queryTable : table containing 2 variables: query (0-th var in table) and condition (1st var in table).
	 * WARNING: implementations may make changes to this table instance (i.e. the content of this instance may be changed).
	 * @param fullCountTable : joint table containing counts of full population.
	 * @return conditional probability table of query (0-th var in table) given condition (1st var in table).
	 */
	protected PotentialTable getConditionalProbabilityFromSimulation(PotentialTable queryTable, PotentialTable fullCountTable) {
		// TODO reduce instrumentation to improve readability & speed
		
		
		
		// basic assertions
		if (queryTable.getVariablesSize() != 2) {
			throw new IllegalArgumentException("Current version can only handle beta-binomial sub-sampling with 2 variables. Query table = " + queryTable);
		}
		
		// make sure variables in queryTable is a subset of variables in jointTable
		if (queryTable.getVariablesSize() > fullCountTable.getVariablesSize()) {
			throw new IllegalArgumentException("Variables in query table must be a subset of joint table. Query table = " 
						+ queryTable + ", joint table = " + fullCountTable);
		}
		for (int i = 0; i < queryTable.getVariablesSize(); i++) {
			if (fullCountTable.getVariableIndex((Node) queryTable.getVariableAt(i)) < 0) {
				throw new IllegalArgumentException("Variables in query table must be a subset of joint table, but variable " 
						+ queryTable.getVariableAt(i) + " was not found in joint table. Query table = " + queryTable
						+ ", joint table = " + fullCountTable);
			}
		}
		
		// make sure the number of sub samples is consistent
		int numSubSamples = (int) sumTableContent(queryTable);
		if (numSubSamples != getStratifiedSampleNumTotal()) {
			throw new IllegalArgumentException("Expected number of sub-samples is " + getStratifiedSampleNumTotal()
					+ ", but actual number os sub-samples was " + numSubSamples);
		}
		
		// extract the alert variable
		String alertName = this.getAlertName();
		if (alertName == null || alertName.trim().isEmpty()) {
			throw new IllegalArgumentException("No name for alert variable was provided.");
		}
		INode alertVar = null;
		for (int i = 0; i < fullCountTable.getVariablesSize(); i++) {
			if (fullCountTable.getVariableAt(i).getName().equalsIgnoreCase(alertName)) {
				alertVar = fullCountTable.getVariableAt(i);
				break;
			}
		}
		
		// search which index in alert variable is the state true, and which one is false
		int indexOfAlertTrue = -1;
		int indexOfAlertFalse = -1;
		for (int i = 0; i < alertVar.getStatesSize(); i++) {
			Boolean isTrue = parseBoolean(alertVar.getStateAt(i));
			if (isTrue != null) {
				if (isTrue) {
					indexOfAlertTrue = i;
				} else {
					indexOfAlertFalse = i;
				}
			}
		}
//		Debug.println(getClass(), "Var: " + alertVar + ". Index of true = " + indexOfAlertTrue + ", index of false = " + indexOfAlertFalse);
		if (indexOfAlertTrue < 0) {
			throw new IllegalArgumentException("Could not find true state of variable " + alertVar);
		}
		if (indexOfAlertFalse < 0) {
			throw new IllegalArgumentException("Could not find false state of variable " + alertVar);
		}
		
		// retrieve how many alerts we originally had
		// marginalize out all variables of full count table, except alert
		PotentialTable numAlertTotal = (PotentialTable) fullCountTable.clone();
		while (numAlertTotal.getVariablesSize() > 1) {
			INode varToRemove = numAlertTotal.getVariableAt(0);
			if (varToRemove.equals(alertVar)) { // do not remove alert
				varToRemove = numAlertTotal.getVariableAt(1);
			}
			numAlertTotal.removeVariable(varToRemove);
		}
//		Debug.println(getClass(), "Total num alert = " + numAlertTotal.getValue(indexOfAlertTrue) + ", total num non-alert = " + numAlertTotal.getValue(indexOfAlertFalse));
		if (numAlertTotal.getValue(indexOfAlertTrue) + numAlertTotal.getValue(indexOfAlertFalse) < getStratifiedSampleNumTotal()) {
			throw new IllegalArgumentException("There are total of " + (numAlertTotal.getValue(indexOfAlertTrue) + numAlertTotal.getValue(indexOfAlertFalse)) 
					+ " data, but requested number of sub-samples was " + getStratifiedSampleNumTotal());
		}
		
		
		// get how many sub-samples of alert we had
		PotentialTable numAlertSubSample = new ProbabilisticTable();
		numAlertSubSample.addVariable(alertVar);
		numAlertSubSample.setValue(indexOfAlertTrue, 
				// if there is no enough sample, use the the total number of alerts
				(getStratifiedSampleNumAlert() > numAlertTotal.getValue(indexOfAlertTrue))?numAlertTotal.getValue(indexOfAlertTrue):getStratifiedSampleNumAlert()
			);
		// the rest is non-alert
		numAlertSubSample.setValue(indexOfAlertFalse, getStratifiedSampleNumTotal() - numAlertSubSample.getValue(indexOfAlertTrue));
		
		// make sure these numbers are consistent with queryTable table
		if (queryTable.getVariableIndex((Node) alertVar) >= 0) {	// if query table contains alert, then do the check
			// use a clone of query table and marginalize out non-alert
			PotentialTable numAlertInQueryTable = queryTable.getTemporaryClone();
			while (numAlertInQueryTable.getVariablesSize() > 1) {
				INode varToRemove = numAlertInQueryTable.getVariableAt(0);
				if (varToRemove.equals(alertVar)) { // do not remove alert
					varToRemove = numAlertInQueryTable.getVariableAt(1);
				}
				numAlertInQueryTable.removeVariable(varToRemove);
			}
			if (((int)numAlertInQueryTable.getValue(indexOfAlertTrue)) != ((int)numAlertSubSample.getValue(indexOfAlertTrue))) {
				throw new IllegalArgumentException("Expected number of alert in queried table " + queryTable + " is " + numAlertSubSample.getValue(indexOfAlertTrue)
						+ ", but was " + numAlertInQueryTable.getValue(indexOfAlertTrue));
			}
			if (((int)numAlertInQueryTable.getValue(indexOfAlertFalse)) != ((int)numAlertSubSample.getValue(indexOfAlertFalse))) {
				throw new IllegalArgumentException("Expected number of non-alert in queried table " + queryTable + " is " + numAlertSubSample.getValue(indexOfAlertFalse)
						+ ", but was " + numAlertInQueryTable.getValue(indexOfAlertFalse));
			}
		}
		 
		// extract queried var
		INode queryVar = queryTable.getVariableAt(0);
		if (queryVar.getStatesSize() != 2) {
			throw new IllegalArgumentException("Current version can only support Boolean variables: " + queryVar);
		}
		// extract condition var
		INode conditionVar = queryTable.getVariableAt(1);
		if (conditionVar.getStatesSize() != 2) {
			throw new IllegalArgumentException("Current version can only support Boolean variables: " + conditionVar);
		}
		if (conditionVar.equals(queryVar)) {
			throw new UnsupportedOperationException("Current version does not support queries of a variable given itself."
					+ ". Query was P(" + queryVar + "|" + conditionVar + ")");
		}
		
		// search which index in query variable is the state true, and which one is false
		int indexOfQueryTrue = -1;
		int indexOfQueryFalse = -1;
		for (int i = 0; i < queryVar.getStatesSize(); i++) {
			Boolean isTrue = parseBoolean(queryVar.getStateAt(i));
			if (isTrue != null) {
				if (isTrue) {
					indexOfQueryTrue = i;
				} else {
					indexOfQueryFalse = i;
				}
			}
		}
//		Debug.println(getClass(), "Var: " + queryVar + ". Index of true = " + indexOfQueryTrue + ", index of false = " + indexOfQueryFalse);
		if (indexOfQueryTrue < 0) {
			throw new IllegalArgumentException("Could not find true state of variable " + queryVar);
		}
		if (indexOfQueryFalse < 0) {
			throw new IllegalArgumentException("Could not find false state of variable " + queryVar);
		}
		
		// search which index in condition variable is the state true, and which one is false
		int indexOfConditionTrue = -1;
		int indexOfConditionFalse = -1;
		for (int i = 0; i < conditionVar.getStatesSize(); i++) {
			Boolean isTrue = parseBoolean(conditionVar.getStateAt(i));
			if (isTrue != null) {
				if (isTrue) {
					indexOfConditionTrue = i;
				} else {
					indexOfConditionFalse = i;
				}
			}
		}
//		Debug.println(getClass(), "Var: " + conditionVar + ". Index of true = " + indexOfConditionTrue + ", index of false = " + indexOfConditionFalse);
		if (indexOfConditionTrue < 0) {
			throw new IllegalArgumentException("Could not find true state of variable " + conditionVar);
		}
		if (indexOfConditionFalse < 0) {
			throw new IllegalArgumentException("Could not find false state of variable " + conditionVar);
		}
		
		// This version only supports cases when the alert variable is in the query table
		if (!(alertVar.equals(queryVar) || alertVar.equals(conditionVar))) {
			throw new UnsupportedOperationException("Current version only allows queries involving alert variable " + alertVar 
					+ ". Query was P(" + queryVar + "|" + conditionVar + ")");
		}
		
		// keep track of which variable is not the alert var
		INode otherVar = queryVar;
		int indexOfOtherVarTrue = indexOfQueryTrue;
		int indexOfOtherVarFalse = indexOfQueryFalse;
		if (otherVar.equals(alertVar)) {
			otherVar = conditionVar;
			indexOfOtherVarTrue = indexOfConditionTrue;
			indexOfOtherVarFalse = indexOfConditionFalse;
		}
		
		// create an alphabet of true and false, but we need to make sure the indexes are the same of queried var
//		Boolean[] booleanAlphabet = new Boolean[queryVar.getStatesSize()];
//		for (int state = 0; state < queryVar.getStatesSize(); state++) {
//			Boolean isTrue = parseBoolean(queryVar.getStateAt(state));
//			if (isTrue == null) {
//				throw new IllegalArgumentException("Boolean variable " + queryVar + " has an invalid state: " + queryVar.getStateAt(state));
//			}
//			booleanAlphabet[state] = isTrue;
//		}
//		Alphabet dictionary = new Alphabet(booleanAlphabet);
		
		
		// prepare parameters of beta-binomial sampler given condition = 0th state
		double[] alphasAlertTrue = new double[queryVar.getStatesSize()];
		double[] alphasAlertFalse = new double[queryVar.getStatesSize()];
		int[] coord = queryTable.getMultidimensionalCoord(0);				// prepare a coordinate to be used in next step
		for (int state = 0; state < queryVar.getStatesSize(); state++) {
			coord[queryTable.getVariableIndex((Node) otherVar)] = state;					// set the other variable (not the alert) to current state
			coord[queryTable.getVariableIndex((Node) alertVar)] = indexOfConditionTrue;		// given alert = true
			alphasAlertTrue[state] = queryTable.getValue(coord) + getPriorCount();			// we usually add a prior count (configurable parameter), which is 1 in most bayesian approaches
			coord[queryTable.getVariableIndex((Node) alertVar)] = indexOfConditionFalse;	// given alert = false
			alphasAlertFalse[state] = queryTable.getValue(coord) + getPriorCount();			// add prior count here too
		}
		// a dirichlet-multinomial sampler with dimension of 2 is a beta-binomial sampler
//		Dirichlet betaAlertTrue = new Dirichlet(alphasAlertTrue, dictionary);
//		Dirichlet betaAlertFalse = new Dirichlet(alphasAlertFalse, dictionary);
		// constructor of dirichlet without dictionary
//		Dirichlet betaAlertTrue = new Dirichlet(alphasAlertTrue);		
//		Dirichlet betaAlertFalse = new Dirichlet(alphasAlertFalse);	
		// use apache commons library instead of mallet
		BetaDistribution betaAlertTrue = new BetaDistribution(alphasAlertTrue[0], alphasAlertTrue[1]);
		BetaDistribution betaAlertFalse = new BetaDistribution(alphasAlertFalse[0], alphasAlertFalse[1]);
		
		// Create a table that will store the sum of estimates (to be used later to calculate average of estimates)
		PotentialTable estimateQueryTrue = new ProbabilisticTable();
		estimateQueryTrue.addVariable(conditionVar);		// each cell "i" in this table is the estimate of query = true given condition = "i". So the table is indexed by condition variable
		estimateQueryTrue.fillTable(0);	// initialize with zeros (null value of a sum), because we will fill it with a sum of estimates (and then divide, in order to calculate average)
		
		// generate samples
//		Randoms sampler = new Randoms();	// this is used later to draw samples from beta dist
		for (int i = 0; i < getNumSubSampleSimulation(); i++) { 
			
			// run trials (beta-binomial are like flips of coins, and trials is how many times we flip the coin)
			int[][] count_AlertXOther = new int[alertVar.getStatesSize()][otherVar.getStatesSize()];	// vector of counts, alert var X other var
			for (int n = 0; n < count_AlertXOther.length; n++) {
				for (int m = 0; m < count_AlertXOther[0].length; m++) {
					count_AlertXOther[n][m] = 0;	// initialize with zeros
				}
			}
			
			// fill histograms with samples from beta-binomial distribution
			// the number of trials is the total number of alerts (but we reuse the sub samples, so we reduce number of sub-samples from number of trials)
			int numTrials = (int) (numAlertTotal.getValue(indexOfAlertTrue) - numAlertSubSample.getValue(indexOfAlertTrue));
			
			BinomialDistribution binomial = new BinomialDistribution(numTrials, betaAlertTrue.sample());
			int sample = binomial.sample();
			if (sample > numTrials) {
				throw new IllegalStateException("Sampled " + sample + " from " + numTrials);
			}
			count_AlertXOther[indexOfAlertTrue][indexOfOtherVarTrue] += sample;
			count_AlertXOther[indexOfAlertTrue][indexOfOtherVarFalse] += (numTrials - sample);
//			for (int trial = 0; trial < numTrials ; trial++) {
//				count_AlertXOther[indexOfAlertTrue][sampler.nextDiscrete(betaAlertTrue.nextDistribution())]++;
//			}
			// do the same for query given condition = false
			numTrials = (int) (numAlertTotal.getValue(indexOfAlertFalse) - numAlertSubSample.getValue(indexOfAlertFalse));
			binomial = new BinomialDistribution(numTrials, betaAlertFalse.sample());
			sample = binomial.sample();
			if (sample > numTrials) {
				throw new IllegalStateException("Sampled " + sample + " from " + numTrials);
			}
			count_AlertXOther[indexOfAlertFalse][indexOfOtherVarTrue] += sample;
			count_AlertXOther[indexOfAlertFalse][indexOfOtherVarFalse] += (numTrials - sample);
//			for (int trial = 0; trial < numTrials ; trial++) {
//				count_AlertXOther[indexOfAlertFalse][sampler.nextDiscrete(betaAlertFalse.nextDistribution())]++;
//			}
			
			// reuse the sub-samples we had, by adding the sub samples to histogram
			coord = queryTable.getMultidimensionalCoord(0);	// prepare coord to be used in next step
			for (int otherVarState = 0; otherVarState < otherVar.getStatesSize(); otherVarState++) {
				// calculate the coordinate in query table which is related to current state
				coord[queryTable.getVariableIndex((Node)otherVar)] = otherVarState;
				
				// increase histograms
				coord[queryTable.getVariableIndex((Node)alertVar)] = indexOfAlertTrue;
//				histogramGivenTrue[queryState] += queryTable.getValue(coord);
				count_AlertXOther[indexOfAlertTrue][otherVarState] += queryTable.getValue(coord);
				
				coord[queryTable.getVariableIndex((Node)alertVar)] = indexOfAlertFalse;
//				histogramGivenFalse[queryState] += queryTable.getValue(coord);
				count_AlertXOther[indexOfAlertFalse][otherVarState] += queryTable.getValue(coord);
			}
			
			// make sure total counts are consistent;
			int expectedTotalCount =  (int) (numAlertTotal.getValue(indexOfAlertTrue) + numAlertTotal.getValue(indexOfAlertFalse));
			int actualTotalCount = 0;
			for (int n = 0; n < count_AlertXOther.length; n++) {
				for (int m = 0; m < count_AlertXOther[0].length; m++) {
					actualTotalCount += count_AlertXOther[n][m];
				}
			}
			if (expectedTotalCount != actualTotalCount) {
				throw new RuntimeException("Failed to generate correct number of counts. Expected = " + expectedTotalCount + ", actual = " + actualTotalCount + ", query table = " + queryTable);
			}
			
			// calculate the estimates and store to estimate table;
			
			// P(Query = true | condition = true) = Count(Query = true, condition = true) / (Count(Query = true, condition = true) + Count(Query = false, condition = true))
			float value = -1;
			if (alertVar.equals(conditionVar)) {	// alert is the condition var
				// Count(Alert = true, Other = true) / (Count(Alert = true, Other = true) + Count(Alert = true, Other = false))
				value = ( (float) count_AlertXOther[indexOfConditionTrue][indexOfQueryTrue]) 
					/ ( ( (float) count_AlertXOther[indexOfConditionTrue][indexOfQueryTrue]) + ( (float) count_AlertXOther[indexOfConditionTrue][indexOfQueryFalse] ) );
			} else {	// alert is the query var
				// just invert the index [m][n] to [n][m]
				value = ( (float) count_AlertXOther[indexOfQueryTrue][indexOfConditionTrue]) 
					/ ( ( (float) count_AlertXOther[indexOfQueryTrue][indexOfConditionTrue]) + ( (float) count_AlertXOther[indexOfQueryFalse][indexOfConditionTrue] ) );
			}
			
			// add P(Query = true | condition = true) to estimate
			estimateQueryTrue.setValue(indexOfConditionTrue, estimateQueryTrue.getValue(indexOfConditionTrue) + value);
			
			// P(Query = true | condition = false) = Count(Query = true, condition = false) / (Count(Query = true, condition = false) + Count(Query = false, condition = false))
			if (alertVar.equals(conditionVar)) { 	// alert is the condition var
				// Count(Alert = false, Other = true) / (Count(Alert = false, Other = true) + Count(Alert = false, Other = false))
				value = ( (float) count_AlertXOther[indexOfConditionFalse][indexOfQueryTrue]) 
					/ ( ( (float) count_AlertXOther[indexOfConditionFalse][indexOfQueryTrue]) + ( (float) count_AlertXOther[indexOfConditionFalse][indexOfQueryFalse] ) );
			} else {	// alert is the query var
				// just invert the index [m][n] to [n][m]
				value = ( (float) count_AlertXOther[indexOfQueryTrue][indexOfConditionFalse]) 
					/ ( ( (float) count_AlertXOther[indexOfQueryTrue][indexOfConditionFalse]) + ( (float) count_AlertXOther[indexOfQueryFalse][indexOfConditionFalse] ) );
			}
			
			// add P(Query = true | condition = false) to estimate
			estimateQueryTrue.setValue(indexOfConditionFalse, estimateQueryTrue.getValue(indexOfConditionFalse) + value);
		}
		
		// calculate average of estimates and set to table of estimates
		for (int tableIndex = 0; tableIndex < estimateQueryTrue.tableSize(); tableIndex++) {
			float value =  estimateQueryTrue.getValue(tableIndex) / ((float)getNumSubSampleSimulation());
			if (value < 0 || value > 1) {
				throw new RuntimeException("Invalid estimate of variable " + queryVar + " given " + conditionVar + " of value " + value
						+ " at state " + tableIndex + ". This is probably a bug. Please, report.");
			}
			estimateQueryTrue.setValue(tableIndex, value);
		}
		
		coord = queryTable.getMultidimensionalCoord(0);	// prepare a coordinate to be used in next loop
		// fill query table with the average we just calculated
		for (int conditionState = 0; conditionState < conditionVar.getStatesSize(); conditionState++) {
			// calculate the coordinate in query table which is related to current state
			coord[queryTable.getVariableIndex((Node) conditionVar)] = conditionState;
			
			// fill query = true with the estimate
			coord[queryTable.getVariableIndex((Node) queryVar)] = indexOfQueryTrue;
			queryTable.setValue(coord, estimateQueryTrue.getValue(conditionState));
			
			// fill the other cell (query = false) with the complement (1-estimate)
			coord[queryTable.getVariableIndex((Node) queryVar)] = indexOfQueryFalse;
			queryTable.setValue(coord, 1f - estimateQueryTrue.getValue(conditionState));
		}
		
		
		return queryTable;
	}
	
	/**
	 * @return the confidence
	 */
	public float getConfidence() {
		return confidence;
	}

	/**
	 * @param confidence the confidence to set
	 */
	public void setConfidence(float confidence) {
		if (confidence < 0 || confidence > 1) {
			throw new IllegalArgumentException("Confidence needs to be a value between 0 and 1.");
		}
		this.confidence = confidence;
	}

	/**
	 * @return the queries
	 */
	public List<Query> getQueries() {
		return queries;
	}

	/**
	 * @param queries the queries to set
	 */
	public void setQueries(List<Query> queries) {
		this.queries = queries;
	}


	/**
	 * @return the isToAdd1ToCounts
	 */
	public boolean isToAdd1ToCounts() {
		return isToAdd1ToCounts;
	}


	/**
	 * @param isToAdd1ToCounts the isToAdd1ToCounts to set
	 */
	public void setToAdd1ToCounts(boolean isToAdd1ToCounts) {
		this.isToAdd1ToCounts = isToAdd1ToCounts;
	}


	/**
	 * @return the isToPrintSummary
	 */
	public boolean isToPrintSummary() {
		return isToPrintSummary;
	}


	/**
	 * @param isToPrintSummary the isToPrintSummary to set
	 */
	public void setToPrintSummary(boolean isToPrintSummary) {
		this.isToPrintSummary = isToPrintSummary;
	}

	
	/**
	 * @return the isToPrintAll
	 */
	public boolean isToPrintAll() {
		return isToPrintAll;
	}
	/**
	 * @param isToPrintAll the isToPrintAll to set
	 */
	public void setToPrintAll(boolean isToPrintAll) {
		this.isToPrintAll = isToPrintAll;
	}

	/**
	 * @return the queryAlias
	 */
	public Map<String, String> getQueryAlias() {
		return queryAlias;
	}


	/**
	 * @param queryAlias the queryAlias to set
	 */
	public void setQueryAlias(Map<String, String> queryAlias) {
		this.queryAlias = queryAlias;
	}


	/*
	 * (non-Javadoc)
	 * @see ObjFunctionPrinter#setProblemID(java.lang.String)
	 */
	public void setProblemID(String problemID) {
		super.setProblemID(problemID);
		
		String upperCase = problemID.toUpperCase();
		if (upperCase.contains("RCP2")) {
			Debug.println("Setting alias for RCP2");
			this.setQueryAlias(QUERY_ALIAS_RCP2);
		} else if (upperCase.contains("RCP3")) {
			Debug.println("Setting alias for RCP3");
			this.setQueryAlias(QUERY_ALIAS_RCP3);
		} else if (upperCase.contains("RCP1")) {
			Debug.println("Setting alias for RCP1");
			this.setQueryAlias(QUERY_ALIAS_RCP1);
		} else {
			Debug.println("Unknown RCP ID. Resetting query alias...");
			this.setQueryAlias(new HashMap<String, String>());
		}
	}


	/**
	 * @return the isToIgnoreNaN
	 */
	public boolean isToIgnoreNaN() {
		return isToIgnoreNaN;
	}


	/**
	 * @param isToIgnoreNaN the isToIgnoreNaN to set
	 */
	public void setToIgnoreNaN(boolean isToIgnoreNaN) {
		this.isToIgnoreNaN = isToIgnoreNaN;
	}


	/**
	 * @return the defaultNaNPrintAlias : alternative value for {@link Float#NaN}
	 * when printing results.
	 * @see #run()
	 */
	public Float getDefaultNaNPrintAlias() {
		return defaultNaNPrintAlias;
	}


	/**
	 * @param defaultNaNPrintAlias alternative value for {@link Float#NaN}
	 * when printing results.
	 * @see #run()
	 */
	public void setDefaultNaNPrintAlias(Float defaultNaNPrintAlias) {
		this.defaultNaNPrintAlias = defaultNaNPrintAlias;
	}




	/**
	 * @return the stratifiedSampleNumTotal
	 * @see #getStratifiedSampleNumAlert()
	 */
	public int getStratifiedSampleNumTotal() {
		return stratifiedSampleNumTotal;
	}


	/**
	 * @param stratifiedSampleNumTotal the stratifiedSampleNumTotal to set
	 * @see #getStratifiedSampleNumAlert()
	 */
	public void setStratifiedSampleNumTotal(int stratifiedSampleNumTotal) {
		this.stratifiedSampleNumTotal = stratifiedSampleNumTotal;
	}


	/**
	 * @return the stratifiedSampleNumAlert : number of stratified samples to consider with Alert=true. 
	 * 100 minus this number will be sampled for Alert = false. Use this argument in order to increase variance.
	 * @see #getStratifiedSampleNumTotal()
	 */
	public int getStratifiedSampleNumAlert() {
		return stratifiedSampleNumAlert;
	}


	/**
	 * @param stratifiedSampleNumAlert : number of stratified samples to consider with Alert=true. 
	 * 100 minus this number will be sampled for Alert = false. Use this argument in order to increase variance.
	 * @see #getStratifiedSampleNumTotal()
	 */
	public void setStratifiedSampleNumAlert(int stratifiedSampleNumAlert) {
		this.stratifiedSampleNumAlert = stratifiedSampleNumAlert;
	}


	/**
	 * @return the isToNormalize : if true, then {@link #getJointProbabilityFromFile(File, boolean)} will
	 * normalize the table to 1.
	 */
	public boolean isToNormalize() {
		return isToNormalize;
	}
	/**
	 * @param isToNormalize : if true, then {@link #getJointProbabilityFromFile(File, boolean)} will
	 * normalize the table to 1.
	 */
	public void setToNormalize(boolean isToNormalize) {
		this.isToNormalize = isToNormalize;
	}
	/**
	 * @return the subSamplingMode : type of sub-sampling to be used by {@link SimulatedUserStatisticsCalculator#getJointProbabilityFromFile(File, boolean, boolean, boolean)}
	 * and {@link SimulatedUserStatisticsCalculator#getConditionalProbabilityFromQueryTable(PotentialTable)}.
	 */
	public SubSamplingMode getSubSamplingMode() {
		return subSamplingMode;
	}
	/**
	 * @param subSamplingMode : type of sub-sampling to be used by {@link SimulatedUserStatisticsCalculator#getJointProbabilityFromFile(File, boolean, boolean, boolean)}
	 * and {@link SimulatedUserStatisticsCalculator#getConditionalProbabilityFromQueryTable(PotentialTable)}.
	 */
	public void setSubSamplingMode(SubSamplingMode subSamplingMode) {
		this.subSamplingMode = subSamplingMode;
	}
	
	/**
	 * @return the numSubSampleSimulation : number of beta-binomial samples to be generated in {@link #getConditionalProbabilityFromSimulation(PotentialTable, PotentialTable)}
	 */
	public int getNumSubSampleSimulation() {
		return numSubSampleSimulation;
	}
	/**
	 * @param numSubSampleSimulation  : number of beta-binomial samples to be generated in {@link #getConditionalProbabilityFromSimulation(PotentialTable, PotentialTable)}
	 */
	public void setSubSampleSimulation(int numSubSampleSimulation) {
		this.numSubSampleSimulation = numSubSampleSimulation;
	}


	/**
	 * @return the priorCount : this is the prior count used in {@link #getConditionalProbabilityFromSimulation(PotentialTable, PotentialTable)}
	 * to initialize parameters of simulation. For example a beta distribution would use a prior count of 1 (default value). 
	 */
	public float getPriorCount() {
		return priorCount;
	}
	/**
	 * @param priorCount : this is the prior count used in {@link #getConditionalProbabilityFromSimulation(PotentialTable, PotentialTable)}
	 * to initialize parameters of simulation. For example a beta distribution would use a prior count of 1 (default value). 
	 */
	public void setPriorCount(float priorCount) {
		this.priorCount = priorCount;
	}


	/**
	 * @param args
	 */
	public static void main(String[] args) {
		CommandLineParser parser = new DefaultParser();
		Options options = new Options();
		options.addOption("d","debug", false, "Enables debug mode.");
		options.addOption("id","problem-id", true, "Name or identification of the current problem (this will be used as suffixes of output file names).");
		options.addOption("i","input", true, "File or directory to get joint probabilities from.");
		options.addOption("o","output", true, "File or directory to place output files.");
		options.addOption("c","confidence", true, "Number between 0 and 1 which denotes confidence (for confidence interval)");
		options.addOption("q","query", true, "Probabilities in the format of \"P(X=state|Y=state)\" to be queried.");
		options.addOption("p","percentile", false, "Use percentiles for confidence interval calculation.");
		options.addOption("s","summary", false, "Print statistical summary instead of probabilities.");
		options.addOption("h","help", false, "Help.");
		options.addOption("numI","number-indicators", true, "Number of indicators to consider.");
		options.addOption("alertSample","number-alert-samples", true, "Number of stratified samples to consider with Alert=true. "
				+ "100 minus this number will be sampled for Alert = false. Use this argument in order to increase variance.");
		options.addOption("alert","alert-name", true, "Name of alert variable.");
		options.addOption("all","print-all", false, "Print statistical summary and probabilities.");
		
		CommandLine cmd = null;
		try {
			cmd = parser.parse(options, args);
		} catch (ParseException e) {
			e.printStackTrace();
			return;
		}
		
		if (cmd == null) {
			System.err.println("Invalid command line");
			return;
		}
		

		if (cmd.hasOption("h")) {
			for (Option option : options.getOptions()) {
				System.out.println("-" + option.getOpt() + (option.hasArg()?(" <" + option.getLongOpt() +">"):"") + " : " + option.getDescription());
			}
			return;
		}
		
		Debug.setDebug(cmd.hasOption("d"));
		
		final SimulatedUserStatisticsCalculator sim = new SimulatedUserStatisticsCalculator();
		if (cmd.hasOption("i")) {
			sim.setInput(new File(cmd.getOptionValue("i")));
		}
		if (cmd.hasOption("o")) {
			sim.setOutput(new File(cmd.getOptionValue("o")));
		}
		if (cmd.hasOption("c")) {
			sim.setConfidence(Float.parseFloat(cmd.getOptionValue("c")));
		}
		
		boolean isToUsePercentiles = cmd.hasOption("p");
		
		sim.setToPrintSummary(cmd.hasOption("s"));
		
		sim.setToPrintAll(cmd.hasOption("all"));
		
		if (cmd.hasOption("id")) {
			sim.setProblemID(cmd.getOptionValue("id"));
		}
		
		if (cmd.hasOption("alert")) {
			sim.setAlertName(cmd.getOptionValue("alert"));
		}
		if (cmd.hasOption("alertSample")) {
			String value = cmd.getOptionValue("alertSample");
			int sampleNum = Integer.parseInt(value);
			if (sampleNum > 100) {
				throw new IllegalArgumentException("Invalid number of samples: " + sampleNum);
			}
			sim.setStratifiedSampleNumAlert(sampleNum);
			sim.setStratifiedSampleNumTotal(100);
		}
		
		// mount query aliases accordingly to indicators 
		if (cmd.hasOption("numI")) {
			// set names of indicators, for backward compatibility
			int num = Integer.parseInt(cmd.getOptionValue("numI"));
			String[] indicatorNames = new String[num];
			for (int i = 1; i <= num; i++) {
				indicatorNames[i-1] = "I"+i;
			}
			sim.setIndicatorNames(indicatorNames);
			
			// prepare the map that will be filled with queries and aliases (i.e. optional names)
			Map<String, String> alias = sim.getQueryAlias();
			if (alias == null) {
				alias = new HashMap<String, String>();
				sim.setQueryAlias(alias);
			} else {
				alias.clear();
			}

			// 3 queries are common to all RCPs
			alias.put("P(Alert=true|Threat=true)", "Q01");
			alias.put("P(Threat=true|Alert=true)", "Q02");
			alias.put("P(Alert=true|Threat=false)", "Q03");
			
			// other queries are dependent to indicators
			int questionNumber = 4;
			for (int i = 0; i < indicatorNames.length; i++, questionNumber++) {
				String indicator = indicatorNames[i];
				alias.put("P(Alert=true|" + indicator + "=true)", "Q" + String.format("%1$02d", questionNumber));;
			}
			for (int i = 0; i < indicatorNames.length; i++, questionNumber++) {
				String indicator = indicatorNames[i];
				alias.put("P(" + indicator + "=true|Alert=true)", "Q" + String.format("%1$02d", questionNumber));
			}
		}
		
		if (cmd.hasOption("q")) {
			List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();
			String[] optionValues = cmd.getOptionValues("q");
			for (String toParse : optionValues) {
				Query q = new Query();
				sim.fillQueriedVarAndStates(toParse, q);
				q.setToUsePercentileForConfidenceInterval(isToUsePercentiles);
				queries.add(q);
			}
			sim.setQueries(queries);
		} else {
			List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();
			for (String toParse : sim.getQueryAlias().keySet()) {
				Query q = new Query();
				sim.fillQueriedVarAndStates(toParse, q);
				q.setToUsePercentileForConfidenceInterval(isToUsePercentiles);
				queries.add(q);
			}
			Collections.sort(queries, new Comparator<Query>() {
				public int compare(Query o1, Query o2) {
					return sim.getQueryAlias().get(o1.getQueriedString()).compareTo(sim.getQueryAlias().get(o2.getQueriedString()));
				}
			});
			sim.setQueries(queries);
		}
		
		try {
			sim.run();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
	
	


}
