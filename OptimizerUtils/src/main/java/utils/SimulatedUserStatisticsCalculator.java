package utils;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.math3.distribution.TDistribution;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import unbbayes.prs.INode;
import unbbayes.prs.Node;
import unbbayes.prs.bn.PotentialTable;
import unbbayes.prs.bn.ProbabilisticTable;
import unbbayes.util.Debug;
import au.com.bytecode.opencsv.CSVReader;

/**
 * 
 */

/**
 * Calculates some statistics from the simulations generated by {@link DirichletUserSimulator}
 * @author Shou Matsumoto
 *
 */
public class SimulatedUserStatisticsCalculator extends DirichletUserSimulator {

	private boolean isToAdd1ToCounts = false;
	
	private float confidence = .95f;
	private List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();

	private boolean isToPrintSummary = false;
	
	private Map<String, String> queryAlias = QUERY_ALIAS_RCP1;

	private boolean isToIgnoreNaN = false;

	private Float defaultNaNPrintAlias = -1f;
	
	public static final Map<String, String> QUERY_ALIAS_RCP1 = new HashMap<String, String>();
	static {
		QUERY_ALIAS_RCP1.put("P(Alert=true|Threat=true)", "Q01");
		QUERY_ALIAS_RCP1.put("P(Threat=true|Alert=true)", "Q02");
		QUERY_ALIAS_RCP1.put("P(Alert=true|Threat=false)", "Q03");
		
		QUERY_ALIAS_RCP1.put("P(Alert=true|I1=true)", "Q04");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I2=true)", "Q05");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I3=true)", "Q06");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I4=true)", "Q07");
		QUERY_ALIAS_RCP1.put("P(Alert=true|I5=true)", "Q08");
		
		QUERY_ALIAS_RCP1.put("P(I1=true|Alert=true)", "Q09");
		QUERY_ALIAS_RCP1.put("P(I2=true|Alert=true)", "Q10");
		QUERY_ALIAS_RCP1.put("P(I3=true|Alert=true)", "Q11");
		QUERY_ALIAS_RCP1.put("P(I4=true|Alert=true)", "Q12");
		QUERY_ALIAS_RCP1.put("P(I5=true|Alert=true)", "Q13");
	}
	
	public static final Map<String, String> QUERY_ALIAS_RCP2 = new HashMap<String, String>();
	static {
		QUERY_ALIAS_RCP2.put("P(Alert=true|Threat=true)", "Q01");
		QUERY_ALIAS_RCP2.put("P(Threat=true|Alert=true)", "Q02");
		QUERY_ALIAS_RCP2.put("P(Alert=true|Threat=false)", "Q03");
		
		QUERY_ALIAS_RCP2.put("P(Alert=true|I1=true)", "Q04");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I2=true)", "Q05");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I3=true)", "Q06");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I4=true)", "Q07");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I5=true)", "Q08");
		QUERY_ALIAS_RCP2.put("P(Alert=true|I6=true)", "Q09");
		
		QUERY_ALIAS_RCP2.put("P(I1=true|Alert=true)", "Q10");
		QUERY_ALIAS_RCP2.put("P(I2=true|Alert=true)", "Q11");
		QUERY_ALIAS_RCP2.put("P(I3=true|Alert=true)", "Q12");
		QUERY_ALIAS_RCP2.put("P(I4=true|Alert=true)", "Q13");
		QUERY_ALIAS_RCP2.put("P(I5=true|Alert=true)", "Q14");
		QUERY_ALIAS_RCP2.put("P(I6=true|Alert=true)", "Q15");
	}
	
	public static final Map<String, String> QUERY_ALIAS_RCP3 = new HashMap<String, String>();

	private int stratifiedSampleNumTotal = 100;
	private int stratifiedSampleNumAlert = 30;
	
	static {
		QUERY_ALIAS_RCP3.put("P(Alert=true|Threat=true)", "Q01");
		QUERY_ALIAS_RCP3.put("P(Threat=true|Alert=true)", "Q02");
		QUERY_ALIAS_RCP3.put("P(Alert=true|Threat=false)", "Q03");
		
		QUERY_ALIAS_RCP3.put("P(Alert=true|I1=true)", "Q04");
		QUERY_ALIAS_RCP3.put("P(Alert=true|I2=true)", "Q05");
		QUERY_ALIAS_RCP3.put("P(Alert=true|I3=true)", "Q06");
		QUERY_ALIAS_RCP3.put("P(Alert=true|I4=true)", "Q07");
		
		QUERY_ALIAS_RCP3.put("P(I1=true|Alert=true)", "Q08");
		QUERY_ALIAS_RCP3.put("P(I2=true|Alert=true)", "Q09");
		QUERY_ALIAS_RCP3.put("P(I3=true|Alert=true)", "Q10");
		QUERY_ALIAS_RCP3.put("P(I4=true|Alert=true)", "Q11");
	}
	
	public SimulatedUserStatisticsCalculator() {
		this.set1stLineForNames(true);
		this.setOutput(new File("output.csv"));
	}
	public static SimulatedUserStatisticsCalculator getInstance() {
		return new SimulatedUserStatisticsCalculator();
	}
	public static SimulatedUserStatisticsCalculator getInstance(int numUsers, int numOrganization) {
		SimulatedUserStatisticsCalculator ret = SimulatedUserStatisticsCalculator.getInstance();
		ret.setNumUsers(numUsers);
		ret.setNumOrganization(numOrganization);
		return ret;
	}
	
	public static class Query {
		private boolean isToUsePercentileForConfidenceInterval = true;
		private List<String> conditions = Collections.emptyList();
		private List<String> conditionsStates = Collections.emptyList();
		private String query = "";
		private String queryState = "";
		private DescriptiveStatistics statistics = new DescriptiveStatistics();
		private String queriedString = null;
		private List<Float> values = new ArrayList<Float>();
		private boolean isJointProbability = false;
		public List<String> getConditions() {
			return this.conditions;
		}
		public void setConditions(List<String> conditions) {
			this.conditions = conditions;
		}
		public String getQuery() {
			return this.query;
		}
		public void setQuery(String query) {
			this.query = query;
		}
		public DescriptiveStatistics getStatistics() {
			return this.statistics;
		}
		public void setStatistics(DescriptiveStatistics statistics) {
			this.statistics = statistics;
		}
		public List<String> getConditionsStates() {
			return conditionsStates;
		}
		public void setConditionsStates(List<String> conditionsStates) {
			this.conditionsStates = conditionsStates;
		}
		public String getQueryState() {
			return queryState;
		}
		public void setQueryState(String queryState) {
			this.queryState = queryState;
		}
		public String getQueriedString() {
			return this.queriedString;
		}
		public void setQueriedString(String queriedString) {
			this.queriedString = queriedString;
		}
		public List<Float> getValues() {
			return values;
		}
		public void setValues(List<Float> values) {
			this.values = values;
		}
		public boolean isToUsePercentileForConfidenceInterval() {
			return isToUsePercentileForConfidenceInterval;
		}
		public void setToUsePercentileForConfidenceInterval(
				boolean isToUsePercentileForConfidenceInterval) {
			this.isToUsePercentileForConfidenceInterval = isToUsePercentileForConfidenceInterval;
		}
		public boolean isJointProbability() {
			return isJointProbability;
		}
		public void setJointProbability(boolean isJointProbability) {
			this.isJointProbability = isJointProbability;
		}
		/**
		 * @param confidence : Number between 0 and 1 use indicating confidence (as in confidence interval). 
		 * Use .95 by default.
		 * @return a confidence interval that can be obtained from {@link #getStatistics()}
		 */
		public Entry<Float, Float> getInterval(float confidence) {
			DescriptiveStatistics statistics = this.getStatistics();
			
			if (isToUsePercentileForConfidenceInterval()) {
				Float upper = (float) statistics.getPercentile((confidence+((1-confidence)/2)) * 100);
				Float lower = (float) statistics.getPercentile(((1-confidence)/2) * 100);
				return Collections.singletonMap(lower, upper).entrySet().iterator().next();
			}
			
			// extract the statistics we need
			double average = statistics.getMean();
			double stdDeviation = statistics.getStandardDeviation(); 
			long sampleSize = statistics.getN();
			
			// prepare the student t distribution
			TDistribution tdistro = new TDistribution(sampleSize - 1);
			
			// the coefficient (of t-distribution) to be used to calculate the upper and lower bounds
			double coefficient = tdistro.inverseCumulativeProbability(getCumulativeProbFromConfidence(confidence));
			
			// lower bound is average - diff. Upper bound is average + diff
			double diff = (coefficient * stdDeviation)/Math.sqrt(sampleSize);
			Float lower = (float) (average - diff);
			Float upper = (float) (average + diff);
			
			// convert the pair to an instance of Entry.
			// TODO instantiate an Entry instead of delegating to Map
			return Collections.singletonMap(lower, upper).entrySet().iterator().next();
		}
		
		public void addValue(float value) {
			this.getValues().add(value);
			if (Float.isNaN(value)) {
				Debug.println(getClass(), "Found NaN in " + this);
				return;
			}
			getStatistics().addValue(value);
		}
		public String toString() {
			return this.getQueriedString();
		}
		
		
	}
	
	
	/**
	 * Converts confidence level to an input to be used in inverse cumulative probability function of t-student distribution.
	 * @param confidenceLevel
	 * @return
	 */
	public static float getCumulativeProbFromConfidence(float confidenceLevel){
		float complement = 1 - confidenceLevel;
		return confidenceLevel + complement/2;
	}
	

	/**
	 * @param query : output argument. 
	 * @param toParse : string in a format like "P(X=state|Y=state)" or "P(X=state,Y=state)"
	 * @see Query#setQuery(String)
	 * @see Query#setQueryState(String)
	 * @see Query#setConditions(List)
	 * @see Query#setConditionsStates(List)
	 */
	public void fillQueriedVarAndStates(String toParse, Query query) {
		// remove white spaces
		toParse = toParse.trim().replaceAll("\\s","");
		
		if (!toParse.matches("P\\([a-zA-Z_][a-zA-Z0-9_]*=[a-zA-Z0-9_]+[\\|,][a-zA-Z_][a-zA-Z0-9_]*=[a-zA-Z0-9_]+\\)")) {
			throw new IllegalArgumentException("Query needs to match format P(X=state|Y=state)");
		}
		
		// if it contains a comma and matched the above regex, then it is a query to joint probability
		query.setJointProbability(toParse.contains(","));
		
		String[] split = toParse.split("(P\\(|\\||,|\\)|=)");
		if (split[0].trim().isEmpty()) {
			split = Arrays.copyOfRange(split, 1, split.length);
		}
		if (split.length != 4) {
			throw new IllegalArgumentException("Current version only supports format 1 queried node and 1 condition: format P(X=state|Y=state)");
		}
		
//		if (!split[0].matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
//			throw new IllegalArgumentException("Names need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[1].matches("[a-zA-Z0-9_]+")) {
//			throw new IllegalArgumentException("States need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[2].matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
//			throw new IllegalArgumentException("Names need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
//		if (!split[3].matches("[a-zA-Z0-9_]+")) {
//			throw new IllegalArgumentException("States need to start with letter or \"_\" and use only alphanumeric characters or \"_\".");
//		}
		
		query.setQuery(split[0]);
		query.setQueryState(split[1]);
		query.setConditions(Collections.singletonList(split[2]));
		query.setConditionsStates(Collections.singletonList(split[3]));
		query.setQueriedString(toParse);
	}
	

	

	/*
	 * (non-Javadoc)
	 * @see ExpectationPrinter#getJointProbabilityFromFile(java.io.File)
	 */
	public PotentialTable getJointProbabilityFromFile(File file) throws IOException {
		return this.getJointProbabilityFromFile(file, getStratifiedSampleNumAlert() >= 0);
	}
	
	/**
	 * Obtains a joint probability from file, but with support for pre-processing for stratified sub-samples 
	 * which consider {@link #getStratifiedSampleNumAlert()} and {@link #getStratifiedSampleNumTotal()}.
	 * <br/>
	 * A subset of {@link #getStratifiedSampleNumTotal()} samples from file will be used to calculate joint probability.
	 * Samples with {@link #getAlertName()} = true will have a weight of:
	 * <pre>
	 * "total number of samples with {@link #getAlertName()} = true" / {@link #getStratifiedSampleNumAlert()}
	 * </pre>
	 * and samples with {@link #getAlertName()} = false will have a weight of:
	 * <pre>
	 * "total number of samples with {@link #getAlertName()} = false" / ({@link #getStratifiedSampleNumTotal()} - {@link #getStratifiedSampleNumAlert()})
	 * </pre>
	 * @param isToSubSample : if true, then {@link #getStratifiedSampleNumAlert()} and {@link #getStratifiedSampleNumTotal()}
	 * will be used to generate stratified samples from file before calculating joint probabilities.
	 * @see utils.ExpectationPrinter#getJointProbabilityFromFile(java.io.File, boolean)
	 */
	public PotentialTable getJointProbabilityFromFile(File file, boolean isToSubSample) throws IOException {
		
		CSVReader reader = new CSVReader(new FileReader(file));
		
		
		// read csv file line-by-line
		
		
		List<String> varNames = new ArrayList<String>();
		
		// read the csv rows.
		List<String[]> allRows = reader.readAll();
		
		// read the 1st line of csv (name of the columns)
//		String[] csvLine = null;
//		csvLine = reader.readNext();
		String[] csvLine = allRows.get(0);
		
		
		for (int column = 0; column < csvLine.length; column++) {
			String name = csvLine[column];
			varNames.add(name);
		}
		
		if (varNames.isEmpty()) {
			varNames = getNameList(getIndicatorNames());
			varNames.add(0, getThreatName());
			if (isToConsiderDetectors()) {
				varNames.addAll(getNameList(getDetectorNames()));
			}
		}
		
		PotentialTable jointTable = super.getJointTable(null, varNames);
		if (isToAdd1ToCounts()) {
			jointTable.fillTable(1f);	// add count 1 to everyone
		} else {
			jointTable.fillTable(0f);	// initialize counts with zeros
		}
		
		
		PotentialTable weightTable = null; 	// if non-null, this weight will be multiplied to number of samples so that counts of samples are converted to weighted samples
		List<String[]> rowsToRead = null;	// this will be filled with samples that will be read from csv (can be the entire file, or subset of the file)
		if (isToSubSample) {
			// check validity of sample numbers
			if (getStratifiedSampleNumAlert() <= 0
					|| getStratifiedSampleNumTotal() <= getStratifiedSampleNumAlert()) {
				reader.close();
				throw new IllegalArgumentException("Invalid number of stratified samples. Alert = true: " + getStratifiedSampleNumAlert()
						 + ". Total: " + getStratifiedSampleNumTotal());
			}
			// check validity of alert variable's name
			if (getAlertName() == null || getAlertName().trim().isEmpty()) {
				reader.close();
				throw new IllegalArgumentException("Invalid alert variable name: " + getAlertName());
			}
			
			// prepare the table which will hold weights to be applied to count table
			weightTable = new ProbabilisticTable();
			// search and add the alert variable into weight table
			for (int i = 0; i < jointTable.getVariablesSize(); i++) {
				if (jointTable.getVariableAt(i).getName().equals(getAlertName())) {
					weightTable.addVariable(jointTable.getVariableAt(i));
					break;
				}
			}
			if (weightTable.tableSize() > 2) {
				reader.close();
				throw new UnsupportedOperationException("Current version does not support variable " + getAlertName() + " with size " + weightTable.tableSize());
			}
			
			
			// extract which column in csv is the state of alert variable
			int indexOfAlertInCSV = varNames.indexOf(getAlertName());
			if (indexOfAlertInCSV < 0) {
				indexOfAlertInCSV = jointTable.getVariablesSize() - jointTable.getVariableIndex((Node) weightTable.getVariableAt(0)) - 1;
				if (indexOfAlertInCSV < 0 || indexOfAlertInCSV >= jointTable.getVariablesSize()) {
					reader.close();
					throw new IllegalArgumentException("Alert variable not found in header " + varNames + " or in joint table " + jointTable);
				}
			}
			
			// count how many entries of alert = true and alert = false there are			
			List<Integer> alertTrueRowIndexes = new ArrayList<Integer>();
			List<Integer> alertFalseRowIndexes = new ArrayList<Integer>();
			for (int rowIndex = 1; rowIndex < allRows.size(); rowIndex++) {	// ignore first row, because it's a header
				csvLine = allRows.get(rowIndex);
				String alertValueInCSV = csvLine[indexOfAlertInCSV];
				if (alertValueInCSV.trim().equalsIgnoreCase("Yes")
						|| alertValueInCSV.trim().equalsIgnoreCase("true")
						|| alertValueInCSV.trim().equals("1")) {
					alertTrueRowIndexes.add(rowIndex);
				} else if (alertValueInCSV.trim().equalsIgnoreCase("No")
						|| alertValueInCSV.trim().equalsIgnoreCase("false")
						|| alertValueInCSV.trim().equals("0")) {
					alertFalseRowIndexes.add(rowIndex);
				} else {
					reader.close();
					throw new IOException("Invalid state found in row " + rowIndex + ", column " + indexOfAlertInCSV + ": " + alertValueInCSV);
				}
			}
			
			if (alertTrueRowIndexes.size() + alertFalseRowIndexes.size() != allRows.size()-1) {
				reader.close();
				throw new IOException("Number of data in CSV is " + (allRows.size()-1) + ", but sum of alert and non-alert data was " + (alertTrueRowIndexes.size() + alertFalseRowIndexes.size()));
			}
			
			
			// calculate weights;
			float weightAlert = ((float)alertTrueRowIndexes.size()) / ((float)getStratifiedSampleNumAlert());
			float weightNonAlert = ((float)alertFalseRowIndexes.size()) / (((float)getStratifiedSampleNumTotal()) - ((float)getStratifiedSampleNumAlert()));
			// if weight is lower than 1, set to 1;
			if (weightAlert < 1) {
				weightAlert = 1;
			}
			if (weightNonAlert < 1) {
				weightNonAlert = 1;
			}
			Debug.println(getClass(), "Weight alert = " + weightAlert + ", weight non-alert = " + weightNonAlert);
			
			// fill weight table 
			if (weightTable.tableSize() == 2) {
				INode alertVar = weightTable.getVariableAt(0);
				int alertTrueStateIndex = -1;
				if (alertVar.getStateAt(0).trim().equalsIgnoreCase("Yes")
						|| alertVar.getStateAt(0).trim().equalsIgnoreCase("true")
						|| alertVar.getStateAt(0).trim().equals("1")) {
					alertTrueStateIndex = 0;
				}
				if (alertTrueStateIndex < 0) {
					reader.close();
					throw new IllegalArgumentException("Cound not find true/yes/1 state in variable " + alertVar);
				}
				weightTable.setValue(alertTrueStateIndex, weightAlert);
				weightTable.setValue((1-alertTrueStateIndex), weightNonAlert);
			} else {
				Debug.println(getClass(), "Found weight table " + weightTable + " with size " + weightTable.tableSize());
			}
			
			// we'll fill rowsToRead with getStratifiedSampleNumTotal() samples.
			rowsToRead = new ArrayList<String[]>(getStratifiedSampleNumTotal());
			// randomly pick getStratifiedSampleNumAlert() samples 
			Random rand = new Random();
			for (int i = 0; i < getStratifiedSampleNumAlert(); i++) {
				if (alertTrueRowIndexes.size() <= 0) {
					break;
				}
				int indexToAdd = rand.nextInt(alertTrueRowIndexes.size());
				rowsToRead.add(allRows.get(alertTrueRowIndexes.get(indexToAdd)));
				alertTrueRowIndexes.remove(indexToAdd);
			}
			// randomly pick getStratifiedSampleNumTotal() - getStratifiedSampleNumAlert() samples 
			for (int i = 0; i < getStratifiedSampleNumTotal() - getStratifiedSampleNumAlert(); i++) {
				if (alertFalseRowIndexes.size() <= 0) {
					break;
				}
				int indexToAdd = rand.nextInt(alertFalseRowIndexes.size());
				rowsToRead.add(allRows.get(alertFalseRowIndexes.get(indexToAdd)));
				alertFalseRowIndexes.remove(indexToAdd);
			}
			
		} else {
			// just read all rows
			rowsToRead = allRows;
		}
		
		// read the remaining file and fill joint table with counts
//		for (csvLine = reader.readNext(); csvLine != null; csvLine = reader.readNext()) {
		for (int currentRowIndex = 1; currentRowIndex < rowsToRead.size(); currentRowIndex++) {
			csvLine = rowsToRead.get(currentRowIndex);
			if (csvLine.length <= 0) {
				continue;	// ignore empty lines
			}
			
			// each line in csv file is something like 1,0,0,1 (this means 1st var is yes, second var is no, 3rd var is no, and 4th var is yes).
			
			// figure out which cell in joint table represents the value in current line
			int[] coord = jointTable.getMultidimensionalCoord(0);
			if (csvLine.length != coord.length) {
				reader.close();
				throw new IOException("File is expected to have " + coord.length + " columns, but the number of columns was " + csvLine.length);
			}
			for (int columnInCSV = 0; columnInCSV < csvLine.length; columnInCSV++) {
				
				int columnInTable = (coord.length-1) - columnInCSV;
				
				// check which state is true and which state is false
				INode var = jointTable.getVariableAt(columnInTable);
				int trueState = -1;
				int falseState = -1;
				for (int state = 0; state < var.getStatesSize(); state++) {
					if (var.getStateAt(state).trim().equalsIgnoreCase("Yes")
							|| var.getStateAt(state).trim().equalsIgnoreCase("true")) {
						trueState = state;
					} else if (var.getStateAt(state).trim().equalsIgnoreCase("No")
							|| var.getStateAt(state).trim().equalsIgnoreCase("false")) {
						falseState = state;
					} else {
						reader.close();
						throw new IOException("Invalid state found in variable " + var.getName() + ": " + var.getStateAt(state));
					}
				}
				
				if (csvLine[columnInCSV].trim().equalsIgnoreCase("true")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("yes")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("1")) {
					coord[columnInTable] = trueState;
				} else if (csvLine[columnInCSV].trim().equalsIgnoreCase("false")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("no")
						|| csvLine[columnInCSV].trim().equalsIgnoreCase("0")) {
					coord[columnInTable] = falseState;
				} else {
					reader.close();
					throw new IOException("Unknown state found in file " + file.getName() + ": " + csvLine[columnInCSV]);
				}
			}
			
			// increment current cell in table
			int cell = jointTable.getLinearCoord(coord);
			jointTable.setValue(cell, jointTable.getValue(cell)+1);
		}
		reader.close();
		
		// apply weights;
		if (weightTable != null && weightTable.getVariablesSize() > 0) {
			jointTable.opTab(weightTable, jointTable.PRODUCT_OPERATOR);	// multiply counts in joint table with the weights in weight table
		}
		
		// normalize joint table, so that joint table becomes a table of proportions
		jointTable.normalize();
		
		return jointTable;
	}
	
	
	
	/*
	 * (non-Javadoc)
	 * @see DirichletUserSimulator#run()
	 */
	public void run() throws IOException {
		File input = getInput();
		if (input.isDirectory()) {
			// read all files in the directory
			List<File> files = new ArrayList<File>(Arrays.asList(input.listFiles()));
			Collections.sort(files, new Comparator<File>() {
				public int compare(File o1, File o2) {
					return o1.getName().compareTo(o2.getName());
				}
			});
			for (File internalFile : files) {
				this.fillQueriesFromFile(internalFile, getQueries());
			}
		} else if (input.isFile()) {
			// read a single file
			this.fillQueriesFromFile(input, getQueries());
		} else {
			throw new IllegalArgumentException(input.getName() + " is not a valid accessible file/directory.");
		}
		
		PrintStream printer = new PrintStream(new FileOutputStream(getOutput(), true));
		
		if (isToPrintSummary()) {
			// print query results
			printer.println("\"Query\",\"Average\",\"Std.Dev.\",\"Median\",\"" + getConfidence() + " lower\",\""+ getConfidence() + " upper\"");
			for (Query query : getQueries()) {
				String label = query.getQueriedString();
				if (getQueryAlias().containsKey(label)) {
					label = getQueryAlias().get(label);
				}
				printer.print("\""+label+"\",");
				printer.print(query.getStatistics().getMean()+",");
				printer.print(query.getStatistics().getStandardDeviation()+",");
				printer.print(query.getStatistics().getPercentile(50)+",");
				Entry<Float, Float> ci = query.getInterval(getConfidence());
				printer.print(ci.getKey()+",");
				printer.println(ci.getValue()+",");
			}
		} else {
			// print the data
			// print first line
			int rowSize = -1;
			for (Query query : getQueries()) {
				String label = query.getQueriedString();
				if (getQueryAlias().containsKey(label)) {
					label = getQueryAlias().get(label);
				}
				printer.print("\""+ label + "\",");
				
				// also check number of values for this query
				int size = query.getValues().size();
				if (rowSize < 0) {
					rowSize = size;
				} else if (rowSize != size) {
					printer.close();
					throw new RuntimeException("Found query with " + size + " values, while previous queries had " + rowSize + " values");
				}
			}
			printer.println();
			for (int row = 0; row < rowSize; row++) {	
				String rowToPrint = "";
				boolean hasNaN = false;
				for (Query query : getQueries()) {
					Float value = query.getValues().get(row);
					if (value.isNaN()) {
						if (isToIgnoreNaN()) {
							hasNaN = true;
							break;
						} else {
							value = getDefaultNaNPrintAlias();
						}
					}
					rowToPrint += (value + ",");
				}
				if (!hasNaN) {
					printer.println(rowToPrint);
				}
			}
		}
		
		printer.close();
	}

	
	/**
	 * 
	 * @param file
	 * @throws IOException
	 */
	public void fillQueriesFromFile(File file, List<Query> queries) throws IOException {
		if (queries == null || queries.isEmpty()) {
			return;
		}
		if (file.isDirectory()) {
			// read all files in the directory
			List<File> files = new ArrayList<File>(Arrays.asList(file.listFiles()));
			Collections.sort(files, new Comparator<File>() {
				public int compare(File o1, File o2) {
					return o1.getName().compareTo(o2.getName());
				}
			});
			for (File internalFile : files) {
				this.fillQueriesFromFile(internalFile, queries);
			}
			return;
		} 
		
		// read current file
		PotentialTable jointTable = this.getJointProbabilityFromFile(file);
		
		// build a map of names to variable, for easy access
		Map<String, INode> varMap = new HashMap<String, INode>();
		for (int i = 0; i < jointTable.getVariablesSize(); i++) {
			varMap.put(jointTable.getVariableAt(i).getName(), jointTable.getVariableAt(i));
		}
		
		
		// iterate on queries and update their statistics
		for (Query query : queries) {
			
			// retrieve what was queried
			INode queriedVar = varMap.get(query.getQuery());
			if (queriedVar == null) {
				throw new RuntimeException("Queried variable not found: " + query.getQuery());
			}
			
			// retrieve what was conditioned
			if (query.getConditions().size() > 1) {
				throw new UnsupportedOperationException("Current version does not allow more than 1 condition");
			}
			
			INode conditionedVar = null;
			if (query.getConditions().size() == 1) {
				conditionedVar = varMap.get(query.getConditions().get(0));
			}
			
			// build a potential table which represents the query
			PotentialTable queryTable = new ProbabilisticTable();
			queryTable.addVariable(queriedVar);
			if (conditionedVar != null && !conditionedVar.equals(queriedVar)) {
				queryTable.addVariable(conditionedVar);
			}
			
			// fill queryTable with joint probability
			fillTablesFromJointProbability(Collections.singletonList(queryTable), jointTable);
			
			// convert queried tables from joint probabilities to conditional probabilities if necessary;
			if (!query.isJointProbability()) {
				// calculate marginal of condition, so that we can use it to calculate conditional
				PotentialTable marginalTable = queryTable.getTemporaryClone();
				marginalTable.removeVariable(queryTable.getVariableAt(0));	// the first variable is the queried var, so if we remove it, we have the marginal of the conditions.
				queryTable.opTab(marginalTable, queryTable.DIVISION_OPERATOR);
			}
			
			// add to query statistics the cell in conditional table which matches with the queried element;
			
			// find queried state
			String state = query.getQueryState().trim();
			boolean isTrue = false;
			if (state.equalsIgnoreCase("Yes") || state.equalsIgnoreCase("true")  || state.equalsIgnoreCase("1")) {
				isTrue = true;
			}
			
			// search for index 
			int queriedStateIndex = 0;
			for (; queriedStateIndex < queryTable.getVariableAt(0).getStatesSize(); queriedStateIndex++) {
				if (queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("Yes")
						|| queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("true")) {
					if (isTrue) {
						break;
					}
				}
				if (queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("No")
						|| queryTable.getVariableAt(0).getStateAt(queriedStateIndex).equalsIgnoreCase("false")) {
					if (!isTrue) {
						break;
					}
				}
			}
			
			state = query.getConditionsStates().get(0).trim();
			isTrue = false;
			if (state.equalsIgnoreCase("Yes") || state.equalsIgnoreCase("true")  || state.equalsIgnoreCase("1")) {
				isTrue = true;
			}
			int conditionStateIndex = 0;
			for (; conditionStateIndex < queryTable.getVariableAt(0).getStatesSize(); conditionStateIndex++) {
				if (queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("Yes")
						|| queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("true")) {
					if (isTrue) {
						break;
					}
				}
				if (queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("No")
						|| queryTable.getVariableAt(0).getStateAt(conditionStateIndex).equalsIgnoreCase("false")) {
					if (!isTrue) {
						break;
					}
				}
			}
			
			int[] coord = queryTable.getMultidimensionalCoord(0);
			coord[0] = queriedStateIndex;
			coord[1] = conditionStateIndex;
//			query.getStatistics().addValue(queryTable.getValue(coord));
			query.addValue(queryTable.getValue(coord));
		
		}
		
		
	}
	



	/**
	 * @return the confidence
	 */
	public float getConfidence() {
		return confidence;
	}

	/**
	 * @param confidence the confidence to set
	 */
	public void setConfidence(float confidence) {
		if (confidence < 0 || confidence > 1) {
			throw new IllegalArgumentException("Confidence needs to be a value between 0 and 1.");
		}
		this.confidence = confidence;
	}

	/**
	 * @return the queries
	 */
	public List<Query> getQueries() {
		return queries;
	}

	/**
	 * @param queries the queries to set
	 */
	public void setQueries(List<Query> queries) {
		this.queries = queries;
	}


	/**
	 * @return the isToAdd1ToCounts
	 */
	public boolean isToAdd1ToCounts() {
		return isToAdd1ToCounts;
	}


	/**
	 * @param isToAdd1ToCounts the isToAdd1ToCounts to set
	 */
	public void setToAdd1ToCounts(boolean isToAdd1ToCounts) {
		this.isToAdd1ToCounts = isToAdd1ToCounts;
	}


	/**
	 * @return the isToPrintSummary
	 */
	public boolean isToPrintSummary() {
		return isToPrintSummary;
	}


	/**
	 * @param isToPrintSummary the isToPrintSummary to set
	 */
	public void setToPrintSummary(boolean isToPrintSummary) {
		this.isToPrintSummary = isToPrintSummary;
	}


	/**
	 * @return the queryAlias
	 */
	public Map<String, String> getQueryAlias() {
		return queryAlias;
	}


	/**
	 * @param queryAlias the queryAlias to set
	 */
	public void setQueryAlias(Map<String, String> queryAlias) {
		this.queryAlias = queryAlias;
	}


	/*
	 * (non-Javadoc)
	 * @see ObjFunctionPrinter#setProblemID(java.lang.String)
	 */
	public void setProblemID(String problemID) {
		super.setProblemID(problemID);
		
		String upperCase = problemID.toUpperCase();
		if (upperCase.contains("RCP2")) {
			Debug.println("Setting alias for RCP2");
			this.setQueryAlias(QUERY_ALIAS_RCP2);
		} else if (upperCase.contains("RCP3")) {
			Debug.println("Setting alias for RCP3");
			this.setQueryAlias(QUERY_ALIAS_RCP3);
		} else if (upperCase.contains("RCP1")) {
			Debug.println("Setting alias for RCP1");
			this.setQueryAlias(QUERY_ALIAS_RCP1);
		} else {
			Debug.println("Unknown RCP ID. Resetting query alias...");
			this.setQueryAlias(new HashMap<String, String>());
		}
	}


	/**
	 * @return the isToIgnoreNaN
	 */
	public boolean isToIgnoreNaN() {
		return isToIgnoreNaN;
	}


	/**
	 * @param isToIgnoreNaN the isToIgnoreNaN to set
	 */
	public void setToIgnoreNaN(boolean isToIgnoreNaN) {
		this.isToIgnoreNaN = isToIgnoreNaN;
	}


	/**
	 * @return the defaultNaNPrintAlias : alternative value for {@link Float#NaN}
	 * when printing results.
	 * @see #run()
	 */
	public Float getDefaultNaNPrintAlias() {
		return defaultNaNPrintAlias;
	}


	/**
	 * @param defaultNaNPrintAlias alternative value for {@link Float#NaN}
	 * when printing results.
	 * @see #run()
	 */
	public void setDefaultNaNPrintAlias(Float defaultNaNPrintAlias) {
		this.defaultNaNPrintAlias = defaultNaNPrintAlias;
	}




	/**
	 * @return the stratifiedSampleNumTotal
	 * @see #getStratifiedSampleNumAlert()
	 */
	public int getStratifiedSampleNumTotal() {
		return stratifiedSampleNumTotal;
	}


	/**
	 * @param stratifiedSampleNumTotal the stratifiedSampleNumTotal to set
	 * @see #getStratifiedSampleNumAlert()
	 */
	public void setStratifiedSampleNumTotal(int stratifiedSampleNumTotal) {
		this.stratifiedSampleNumTotal = stratifiedSampleNumTotal;
	}


	/**
	 * @return the stratifiedSampleNumAlert : number of stratified samples to consider with Alert=true. 
	 * 100 minus this number will be sampled for Alert = false. Use this argument in order to increase variance.
	 * @see #getStratifiedSampleNumTotal()
	 */
	public int getStratifiedSampleNumAlert() {
		return stratifiedSampleNumAlert;
	}


	/**
	 * @param stratifiedSampleNumAlert : number of stratified samples to consider with Alert=true. 
	 * 100 minus this number will be sampled for Alert = false. Use this argument in order to increase variance.
	 * @see #getStratifiedSampleNumTotal()
	 */
	public void setStratifiedSampleNumAlert(int stratifiedSampleNumAlert) {
		this.stratifiedSampleNumAlert = stratifiedSampleNumAlert;
	}




	/**
	 * @param args
	 */
	public static void main(String[] args) {
		CommandLineParser parser = new DefaultParser();
		Options options = new Options();
		options.addOption("d","debug", false, "Enables debug mode.");
		options.addOption("id","problem-id", true, "Name or identification of the current problem (this will be used as suffixes of output file names).");
		options.addOption("i","input", true, "File or directory to get joint probabilities from.");
		options.addOption("o","output", true, "File or directory to place output files.");
		options.addOption("c","confidence", true, "Number between 0 and 1 which denotes confidence (for confidence interval)");
		options.addOption("q","query", true, "Probabilities in the format of \"P(X=state|Y=state)\" to be queried.");
		options.addOption("p","percentile", false, "Use percentiles for confidence interval calculation.");
		options.addOption("s","summary", false, "Print statistical summary instead of probabilities.");
		options.addOption("h","help", false, "Help.");
		options.addOption("numI","number-indicators", true, "Number of indicators to consider.");
		options.addOption("alertSample","number-alert-samples", true, "Number of stratified samples to consider with Alert=true. "
				+ "100 minus this number will be sampled for Alert = false. Use this argument in order to increase variance.");
		options.addOption("alert","alert-name", true, "Name of alert variable.");
		
		CommandLine cmd = null;
		try {
			cmd = parser.parse(options, args);
		} catch (ParseException e) {
			e.printStackTrace();
			return;
		}
		
		if (cmd == null) {
			System.err.println("Invalid command line");
			return;
		}
		

		if (cmd.hasOption("h")) {
			for (Option option : options.getOptions()) {
				System.out.println("-" + option.getOpt() + (option.hasArg()?(" <" + option.getLongOpt() +">"):"") + " : " + option.getDescription());
			}
			return;
		}
		
		Debug.setDebug(cmd.hasOption("d"));
		
		final SimulatedUserStatisticsCalculator sim = new SimulatedUserStatisticsCalculator();
		if (cmd.hasOption("i")) {
			sim.setInput(new File(cmd.getOptionValue("i")));
		}
		if (cmd.hasOption("o")) {
			sim.setOutput(new File(cmd.getOptionValue("o")));
		}
		if (cmd.hasOption("c")) {
			sim.setConfidence(Float.parseFloat(cmd.getOptionValue("c")));
		}
		
		boolean isToUsePercentiles = cmd.hasOption("p");
		
		sim.setToPrintSummary(cmd.hasOption("s"));
		
		if (cmd.hasOption("id")) {
			sim.setProblemID(cmd.getOptionValue("id"));
		}
		
		if (cmd.hasOption("alert")) {
			sim.setAlertName(cmd.getOptionValue("alert"));
		}
		if (cmd.hasOption("alertSample")) {
			String value = cmd.getOptionValue("alertSample");
			int sampleNum = Integer.parseInt(value);
			if (sampleNum > 100) {
				throw new IllegalArgumentException("Invalid number of samples: " + sampleNum);
			}
			sim.setStratifiedSampleNumAlert(sampleNum);
			sim.setStratifiedSampleNumTotal(100);
		}
		
		// mount query aliases accordingly to indicators 
		if (cmd.hasOption("numI")) {
			// set names of indicators, for backward compatibility
			int num = Integer.parseInt(cmd.getOptionValue("numI"));
			String[] indicatorNames = new String[num];
			for (int i = 1; i <= num; i++) {
				indicatorNames[i-1] = "I"+i;
			}
			sim.setIndicatorNames(indicatorNames);
			
			// prepare the map that will be filled with queries and aliases (i.e. optional names)
			Map<String, String> alias = sim.getQueryAlias();
			if (alias == null) {
				alias = new HashMap<String, String>();
				sim.setQueryAlias(alias);
			} else {
				alias.clear();
			}

			// 3 queries are common to all RCPs
			alias.put("P(Alert=true|Threat=true)", "Q01");
			alias.put("P(Threat=true|Alert=true)", "Q02");
			alias.put("P(Alert=true|Threat=false)", "Q03");
			
			// other queries are dependent to indicators
			int questionNumber = 4;
			for (int i = 0; i < indicatorNames.length; i++, questionNumber++) {
				String indicator = indicatorNames[i];
				alias.put("P(Alert=true|" + indicator + "=true)", "Q" + String.format("%1$02d", questionNumber));;
			}
			for (int i = 0; i < indicatorNames.length; i++, questionNumber++) {
				String indicator = indicatorNames[i];
				alias.put("P(" + indicator + "=true|Alert=true)", "Q" + String.format("%1$02d", questionNumber));
			}
		}
		
		if (cmd.hasOption("q")) {
			List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();
			String[] optionValues = cmd.getOptionValues("q");
			for (String toParse : optionValues) {
				Query q = new Query();
				sim.fillQueriedVarAndStates(toParse, q);
				q.setToUsePercentileForConfidenceInterval(isToUsePercentiles);
				queries.add(q);
			}
			sim.setQueries(queries);
		} else {
			List<Query> queries = new ArrayList<SimulatedUserStatisticsCalculator.Query>();
			for (String toParse : sim.getQueryAlias().keySet()) {
				Query q = new Query();
				sim.fillQueriedVarAndStates(toParse, q);
				q.setToUsePercentileForConfidenceInterval(isToUsePercentiles);
				queries.add(q);
			}
			Collections.sort(queries, new Comparator<Query>() {
				public int compare(Query o1, Query o2) {
					return sim.getQueryAlias().get(o1.getQueriedString()).compareTo(sim.getQueryAlias().get(o2.getQueriedString()));
				}
			});
			sim.setQueries(queries);
		}
		
		try {
			sim.run();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}



}
