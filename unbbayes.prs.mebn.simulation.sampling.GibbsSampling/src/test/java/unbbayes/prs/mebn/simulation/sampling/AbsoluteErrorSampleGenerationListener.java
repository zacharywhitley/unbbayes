package unbbayes.prs.mebn.simulation.sampling;

import unbbayes.prs.Node;
import unbbayes.prs.bn.ProbabilisticNetwork;
import unbbayes.prs.bn.TreeVariable;
import unbbayes.simulation.montecarlo.sampling.IMonteCarloSampling;
import unbbayes.simulation.montecarlo.sampling.SampleGenerationListener;
import unbbayes.simulation.sampling.GibbsSampling;

/**
 * Listener that compares marginals of nodes filled by gibbs sampler and JT,
 * and if they are smaller than a given margin, stops sampling
 * @author Shou Matsumoto
 *
 */
public class AbsoluteErrorSampleGenerationListener implements SampleGenerationListener {
	private float marginalDiff = 0.01f;
	private ProbabilisticNetwork netToCompare = null;
	private long totalExecutionTime = 0;
	/**
	 * @param marginalDiff : if absolute difference between all marginals is smaller than this value, then stop sampling
	 * @param netToCompare : network generated by Junction tree algorithm
	 */
	public AbsoluteErrorSampleGenerationListener(float marginalDiff, ProbabilisticNetwork netToCompare) {
		this.setMarginalDiff(marginalDiff);
		this.setNetToCompare(netToCompare);
	}
	/**
	 * Stops gibbs sampler if current marginal is close to {@link #netToCompare} by the error margin of {@link #marginalDiff}
	 * @see unbbayes.simulation.montecarlo.sampling.SampleGenerationListener#onSampleGenerated(unbbayes.simulation.montecarlo.sampling.IMonteCarloSampling, long)
	 */
	public boolean onSampleGenerated(IMonteCarloSampling sampler, long sampleNumber) {
		long timeBefore = System.currentTimeMillis();
		if (sampler instanceof GibbsSampling) {
			GibbsSampling gibbs = (GibbsSampling) sampler;
			gibbs.fillMarginals();
			for (Node nodeToCompare : netToCompare.getNodes()) {
				TreeVariable gibbsNode = (TreeVariable) ((ProbabilisticNetwork)((GibbsSampling) sampler).getNetwork()).getNode(nodeToCompare.getName());
				for (int i = 0; i < gibbsNode.getStatesSize(); i++) {
					if (Math.abs(((TreeVariable)nodeToCompare).getMarginalAt(i) - gibbsNode.getMarginalAt(i)) > marginalDiff ) {
						totalExecutionTime += (System.currentTimeMillis() - timeBefore);
						return true;
					}
				}
			}
		}
		totalExecutionTime += (System.currentTimeMillis() - timeBefore);
		return false;
	}
	/**
	 * @return the time that {@link #onSampleGenerated(IMonteCarloSampling, long)} was executing
	 */
	public long getTotalExecutionTime() {
		return totalExecutionTime;
	}
	/**
	 * @param totalExecutionTime : the time that {@link #onSampleGenerated(IMonteCarloSampling, long)} was executing.
	 * Set this to zero in order to reset.
	 */
	public void setTotalExecutionTime(long totalExecutionTime) {
		this.totalExecutionTime = totalExecutionTime;
	}
	/**
	 * @return the marginalDiff
	 */
	public float getMarginalDiff() {
		return marginalDiff;
	}
	/**
	 * @param marginalDiff the marginalDiff to set
	 */
	public void setMarginalDiff(float marginalDiff) {
		this.marginalDiff = marginalDiff;
	}
	/**
	 * @return the netToCompare
	 */
	public ProbabilisticNetwork getNetToCompare() {
		return netToCompare;
	}
	/**
	 * @param netToCompare the netToCompare to set
	 */
	public void setNetToCompare(ProbabilisticNetwork netToCompare) {
		this.netToCompare = netToCompare;
	}
}
