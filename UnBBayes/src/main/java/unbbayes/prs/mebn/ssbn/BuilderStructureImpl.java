package unbbayes.prs.mebn.ssbn;

import java.util.ArrayList;
import java.util.List;

import unbbayes.prs.Node;
import unbbayes.prs.mebn.InputNode;
import unbbayes.prs.mebn.MFrag;
import unbbayes.prs.mebn.OrdinaryVariable;
import unbbayes.prs.mebn.ResidentNode;
import unbbayes.prs.mebn.kb.KnowledgeBase;
import unbbayes.prs.mebn.ssbn.exception.ImplementationRestrictionException;
import unbbayes.prs.mebn.ssbn.exception.OVInstanceFaultException;
import unbbayes.prs.mebn.ssbn.exception.SSBNNodeGeneralException;

/**
 * 
 * 
 * @author Laecio Lima dos Santos (laecio@gmail.com)
 */
public class BuilderStructureImpl implements BuilderStructure{

	//The structure is build from the query nodes. The finding nodes that 
	//don't is in a path don't will be created. Solution: don't search the
	//finding nodes before the algorithm evaluation. (r-SSBN)
	//Bad  - Evaluated if a SSBNNode is a finding
	//Good - In the other option, is verified the duplicated SSBN node possibility for 
	//       see if the node is a finding. The number of evidences should be
	//       very large! 

	// For each node Y in fragment F, if all parents of Y are in SSBN and 
	//all arcs from parents of Y to Y are in SSBN then mark Y finished, 
	//else mark Y unfinished

	//(The Laskey's algorithm only is up!!! If you add the finding nodes 
	//for necessity, you shouldn't have to up and to down. This difficult 
	//the control because the down part is more difficult. The solution should
	//make a simple father structure for evaluate what node is child of 
	//what node... or create all findings how the sugestion (the simple 
	//structure should be a posterior perform). 

	//Question: how the network is connected, always will have a path 
	//between two nodes? Yes! Then the solution of a simple structure don't 
	//work well. 

	//The great question here is the context node evaluation. 

	private List<SimpleSSBNNode> notFinishedNodeList; 
	private List<MFragInstance> mFragInstanceList; 
	
	private ContextNodeAvaliator contextNodeAvaliator; 
	
	private SSBN ssbn; 
	
	public BuilderStructureImpl(){
		
	}
	
	/**
	 * 
	 * 
	 * Pre-requisites
	 *     - All nodes of the SSBN are marked not finished. 
	 *     
	 * Pos-requisites
	 *     - All nodes of the SSBN are marked finished.     
	 */
	public void buildStructure(SSBN ssbn,
			KnowledgeBase kb) {
		
		notFinishedNodeList = new ArrayList<SimpleSSBNNode>(); 
		mFragInstanceList = new ArrayList<MFragInstance>();
		contextNodeAvaliator = new ContextNodeAvaliator(kb); 
		
		this.ssbn = ssbn; 
		
		//Fill the list of notFinishedNodeList
		for(SimpleSSBNNode node: ssbn.getSsbnNodeList()){
			notFinishedNodeList.add(node);
		}		
		
		//Evaluate all the not finished nodes
		//Maybe try a order that facilite the evaluation (nodes at some MFrag for example)
		
		//Cases: 
		//Query and Findings nodes
		//Input nodes still don't evaluated 
		while(!notFinishedNodeList.isEmpty()){
			for(SimpleSSBNNode node: notFinishedNodeList){
			   evaluateUnfinishedRV(node); 
			}
		}
	}

	/*
	 * Evaluate a node, creating the necessary nodes and edges to mark it how 	
	 * finished. Two cases: 
	 * - Generated by a input node (contains arguments for the input MFrag)
	 * - Generated by a finding/query node
	 */
	private void evaluateUnfinishedRV(SimpleSSBNNode node){

		//Build the MFragInstance related to the node
		MFragInstance mFragInstance = 
			ssbn.createMFragInstance(node.getResidentNode().getMFrag(), node.getArgumentList()); 

		//Evaluate the mFragInstances and create the nodes of its.
		evaluateMFragInstance(mFragInstance); 

	}

	/*
	 * - The resident nodes created are all marked finished
	 * - The input nodes are all marked unfinished
	 */
	private void evaluateMFragInstance(MFragInstance mFragInstance){

		if(mFragInstance.isEvaluated()){
			return; 
		}
		
		MFrag mFrag = mFragInstance.getMFragOrigin(); 
		
	    // Evaluate MFragInstance context
		try {
			contextNodeAvaliator.evaluateMFragContextNode(mFragInstance);
		} catch (ImplementationRestrictionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SSBNNodeGeneralException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (OVInstanceFaultException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 

	   // Create the new nodes by the result of evaluation
	   // Setting the distribution of the nodes how default when necessary
		
		//Step 1: Resident Nodes
		for(ResidentNode residentNode: mFrag.getResidentNodeList()){
			
			boolean uncertaintyReferenceTratment = false; 
			List<OVInstance> ovInstanceListSimpleCase = new ArrayList<OVInstance>(); 
			List<List<OVInstance>> ovInstanceListUncertaintyCase = new ArrayList<List<OVInstance>>(); 
			
		    //Mount the list of simple arguments (not generated by uncertainty reference)
			for(OrdinaryVariable ov: residentNode.getOrdinaryVariableList()){
				List<LiteralEntityInstance> listEntityInstance = mFragInstance.getInstanciatedOVValue(ov); 
				if(listEntityInstance.size() == 1){ //Simple case
					ovInstanceListSimpleCase.add(OVInstance.getInstance(ov, listEntityInstance.get(0))); 
				}else{ //OV generated by 
					if(mFragInstance.getContextNodeFather(ov) != null){
						uncertaintyReferenceTratment = true;  
						List<OVInstance> ovInstanceList = new ArrayList<OVInstance>(); 
						for(LiteralEntityInstance lei: listEntityInstance){
							ovInstanceList.add(OVInstance.getInstance(ov, lei)); 
						}
						ovInstanceListUncertaintyCase.add(ovInstanceList); 
					}else{
						//This case don't is treat for the algorithm
						//Warning or exception? 
//						throw new ImplementationRestrictionException(); 
					}
				}
			}
			
			//Create the nodes with the arguments (verify if it already exists)
			//Mark the nodes finished
			if(!uncertaintyReferenceTratment){
				
				//Create ONE node with the specified arguments
				SimpleSSBNNode ssbnNode = ssbn.createSSBNNode(residentNode, ovInstanceListSimpleCase); 
				ssbnNode.setMFragInstance(mFragInstance); 
				
				ssbnNode.setFinished(true); 
				
			}else{
				//TODO Create a list of nodes with the combinations of the arguments. 
			}
			
		}
		
		//Step 2: Input Nodes
		//The consistency of the context nodes should be averiguated 
		//Marked not finished
		//Verify if the node already exist 
		//In this moment use this MFragInstance (alter after)
		for(InputNode inputNode: mFrag.getInputNodeList()){
			
			boolean uncertaintyReferenceTratment = false; 
			List<OVInstance> ovInstanceListSimpleCase = new ArrayList<OVInstance>(); 
			List<List<OVInstance>> ovInstanceListUncertaintyCase = new ArrayList<List<OVInstance>>(); 
			
		    //Mount the list of simple arguments (not generated by uncertainty reference
			for(OrdinaryVariable ov: inputNode.getOrdinaryVariableList()){
				List<LiteralEntityInstance> listEntityInstance = mFragInstance.getInstanciatedOVValue(ov); 
				if(listEntityInstance.size() == 1){ //Simple case
					ovInstanceListSimpleCase.add(OVInstance.getInstance(ov, listEntityInstance.get(0))); 
				}else{ //OV generated by 
					if(mFragInstance.getContextNodeFather(ov) != null){
						uncertaintyReferenceTratment = true;  
						List<OVInstance> ovInstanceList = new ArrayList<OVInstance>(); 
						for(LiteralEntityInstance lei: listEntityInstance){
							ovInstanceList.add(OVInstance.getInstance(ov, lei)); 
						}
						ovInstanceListUncertaintyCase.add(ovInstanceList); 
					}else{
						//This case don't is possible yet. throw a exception
					}
				}
			}
			
			//Create the nodes with the arguments (verify if it already exists)
			//Mark the nodes finished
			//Set the arguments for MFrag (necessary in the CPT mounting)
			if(!uncertaintyReferenceTratment){
				
				//Create ONE node with the specified arguments
				SimpleSSBNNode ssbnNode = ssbn.createSSBNNode(inputNode, 
						ovInstanceListSimpleCase); 
				
				ssbnNode.setFinished(false); 
				notFinishedNodeList.add(ssbnNode); 
			
			}else{
				//Create a list of nodes with the combinations of the arguments. 
			}
			
		}		
		
		//Step 3: Create the edges between the nodes
		
		
		
		mFragInstance.setEvaluated(true); 
	}
	
	public void createEdgesForMFragInstance(MFragInstance mFragInstance){
		
		//Put the context node special node in the network in case of uncertainty reference
		
		//Don't exist edge between two input nodes
		//ResidentNodes
		for(SimpleSSBNNode evaluatedNode: mFragInstance.getNodeList()){
			
			//Taken only the nodes that are resident in this MFrag
			if(evaluatedNode.getMFragInstance().equals(mFragInstance)){
				
				//input node or resident node
				for(Node mebnNode: evaluatedNode.getResidentNode().getParents()){
					
					for(SimpleSSBNNode ssbnNodeParent: 
						mFragInstance.getSSBNNodeForNode(mebnNode, evaluatedNode.getArgumentList())){
						
						evaluatedNode.addParent(ssbnNodeParent); 
					
					}
					
				}
				
			}
			
		}
		
	}
	

	
	
}



