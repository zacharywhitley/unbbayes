package unbbayes.prs.mebn.ssbn;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import unbbayes.prs.mebn.ContextNode;
import unbbayes.prs.mebn.InputNode;
import unbbayes.prs.mebn.OrdinaryVariable;
import unbbayes.prs.mebn.ResidentNode;
import unbbayes.prs.mebn.entity.ObjectEntity;
import unbbayes.prs.mebn.entity.ObjectEntityInstanceOrdereable;
import unbbayes.prs.mebn.entity.StateLink;
import unbbayes.prs.mebn.kb.KnowledgeBase;
import unbbayes.prs.mebn.kb.SearchResult;
import unbbayes.prs.mebn.ssbn.exception.ImplementationRestrictionException;
import unbbayes.prs.mebn.ssbn.exception.MFragContextFailException;
import unbbayes.prs.mebn.ssbn.exception.OVInstanceFaultException;
import unbbayes.prs.mebn.ssbn.exception.SSBNNodeGeneralException;

/**
 * 
 * 
 * @author Laecio Lima dos Santos (laecio@gmail.com)
 */
public class BuilderStructureImpl implements IBuilderStructure{

	private List<SimpleSSBNNode> notFinishedNodeList; 
	private List<MFragInstance> mFragInstanceList; 
	
	private ContextNodeEvaluator contextNodeAvaliator; 
	private KnowledgeBase kb; 
	
	private SSBN ssbn; 
	
	private boolean internalDebug = false; 
	
	public BuilderStructureImpl(){
		
	}
	
	/**
	 * 
	 * 
	 * Pre-requisites
	 *     - All nodes of the SSBN are marked not finished. 
	 *     
	 * Pos-requisites
	 *     - All nodes of the SSBN are marked finished.     
	 */
	public void buildStructure(SSBN _ssbn,
			KnowledgeBase _kb) {
		
		notFinishedNodeList = new ArrayList<SimpleSSBNNode>(); 
		mFragInstanceList = new ArrayList<MFragInstance>();
		contextNodeAvaliator = new ContextNodeEvaluator(kb); 
		
		this.ssbn = _ssbn; 
		this.kb = _kb; 
		
		System.out.println("Build Structure");
		
		//Fill the list of notFinishedNodeList
		System.out.println("Initial list of not finished nodes: ");
		for(SimpleSSBNNode node: ssbn.getSsbnNodeList()){
			System.out.println("     -> " + node);
			notFinishedNodeList.add(node);
		}		
		
		//Evaluate all the not finished nodes
		
		//Cases: 
		//Query and Findings nodes
		//Input nodes still don't evaluated 
		
		int iteration = 0; 
		
		while(!notFinishedNodeList.isEmpty()){
			System.out.println("\n Not finished = false. New Iteration necessary");
			System.out.println("Iteration = " + iteration);
			
			for(SimpleSSBNNode node: notFinishedNodeList){
		        try {
					evaluateUnfinishedRV(node);
				} catch (ImplementationRestrictionException e) {
					// TODO Auto-generated catch block 
					//TODO throw exceptions of this method. 
					e.printStackTrace();
				} catch (SSBNNodeGeneralException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} 
			}
			
			//update the not finished list
			notFinishedNodeList.clear();

			System.out.println("Result after node evaluation: " +
					"Not finished nodes: ");
			
			for(SimpleSSBNNode node: ssbn.getSsbnNodeList()){
				if(!node.isFinished()){
					System.out.println("     - " + node.toString());
					notFinishedNodeList.add(node); 
				}
			}
			
			iteration++; 
			
		}
		
		System.out.println("Finished");
	}

	/*
	 * Evaluate a node, creating the necessary nodes and edges to mark it how 	
	 * finished. Two cases: 
	 * - Generated by a input node (contains arguments for the input MFrag)
	 * - Generated by a finding/query node
	 */
	private void evaluateUnfinishedRV(SimpleSSBNNode node) throws ImplementationRestrictionException, 
	                  SSBNNodeGeneralException{
		
		System.out.println("Evaluate unfinished node = " + node);
		
		//TODO view if already exists a equal MFragInstance. 
		
		//Build the MFragInstance related to the node
		MFragInstance mFragInstance = MFragInstance.getInstance(node.getResidentNode().getMFrag()); 
		
		//Add the arguments
		for(int i = 0; i < node.getOvArray().length; i++){
			try {
				mFragInstance.addOVValue(node.getOvArray()[i], node.getEntityArray()[i].getInstanceName());
			} catch (MFragContextFailException e) {
				// TODO Auto-generated catch block
				//TODO throw exception
				//internal error... 
				e.printStackTrace();
			} 
		}
		
		node.setMFragInstance(mFragInstance); 
		
		//Evaluate the mFragInstances and create the nodes of its.
		evaluateMFragInstance(mFragInstance, node); 
		
		node.setFinished(true);
		
		System.out.println("Unfinished node = " + node + " setted true");
		
	}

	/**
	 * Mount a list with the ordinary variables instances of the resident node 
	 * referent to the ordinary variables instances of the input node. This list 
	 * contains only the match found. 
	 * 
	 * @param inputNode
	 * @param argumentsOfInputNode
	 * @return the list mounted
	 */
//	private List<OVInstance> translateInputArgumentsForResidentArguments(InputNode inputNode, 
//			List<OVInstance> argumentsOfInputNode){
//		 
//		List<OVInstance> listResult = new ArrayList<OVInstance>(); 
//		ResidentNodePointer pointer = inputNode.getResidentNodePointer(); 
//		
//		for(OVInstance ovInstance: argumentsOfInputNode){
//			OrdinaryVariable residentOV = pointer.getCorrespondentOrdinaryVariable(ovInstance.getOv());
//			if(residentOV!=null){
//				listResult.add(OVInstance.getInstance(residentOV, ovInstance.getEntity())); 
//			}
//		}
//		
//		return listResult; 
//		
//	}
	
	/**
	 * Evaluate the fathers of a node in a MFrag. 
	 * 
	 * @param ssbnNode
	 * @param mFragInstance
	 * @throws ImplementationRestrictionException 
	 * @throws SSBNNodeGeneralException 
	 */
	private void evaluateMFragInstance(MFragInstance mFragInstance, SimpleSSBNNode ssbnNode) 
	      throws ImplementationRestrictionException, SSBNNodeGeneralException{

		System.out.println("Evaluate MFragInstance " + mFragInstance);
		
		// 1) Test if the MFragInstance already was evaluated
		if(mFragInstance.isEvaluated()){
			return; 
		}
		
	    // 2) Evaluate MFragInstance context
		try {
			evaluateMFragContextNodes(mFragInstance);
			
			System.out.println("Context Nodes evaluateds");
			
		} catch (ImplementationRestrictionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SSBNNodeGeneralException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (OVInstanceFaultException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		
		// 3) Create the nodes of the MFragInstance
		evaluateNodeInMFragInstance(mFragInstance, ssbnNode);
		
	}	
	
	/**
	 * Evaluate a node in this MFrag. Evaluate is verify if the node is a finding
	 * and create its parents. This 
	 * procediment is recursive: the parents of the parents will be created too, 
	 * except for the parents originated from input nodes. 
	 * <b>
	 * 
	 * Pre-Requisites: <b>
	 * The context node already are evaluated. <b>
	 * 
	 * Pos-Requisites: <b>
	 * set the mFragInstance of the node<b>
	 * Set the node how finished<b>
	 * set the mFragInstance how finished (all nodes parents necessary are generated)<b>
	 * 
	 * Notes: <b>
	 * - The evaluation of the recursivity should be in this method. 
	 * @throws ImplementationRestrictionException 
	 * @throws SSBNNodeGeneralException 
	 */
	private void evaluateNodeInMFragInstance(MFragInstance mFragInstance, SimpleSSBNNode node) 
	       throws ImplementationRestrictionException, SSBNNodeGeneralException{
		
		node.setMFragInstance(mFragInstance); 
		
		//--- 1) Evaluate if the node is a finding. 
		
		ResidentNode resident = node.getResidentNode(); 
		
		List<OVInstance> argumentList = new ArrayList<OVInstance>(); 
		
		for(int i = 0; i < node.getOvArray().length; i++){
			argumentList.add(OVInstance.getInstance(node.getOvArray()[i], node.getEntityArray()[i])); 
		}
		
		StateLink exactValue = kb.searchFinding(
				node.getResidentNode(), argumentList);
		
		/*
		 * Nota: como o algoritmo apenas sobe, é necessário continuar a avaliação
		 * acima mesmo quando o nó for setado como um finding, pois acima dele pode
		 * ter uma query ou nó que influência a query. (Caso fosse feita a avaliação
		 * acima e abaixo, não seria necessária esta subida, mas o algoritmo seria 
		 * mais complexo). Isto gerará um monte de nós candidados a serem excluidos
		 * no próximo passo.  
		 */
		if(exactValue!= null){
			//The node is a finding... 
			node.setState(exactValue.getState());
		}
		
		
		//---- 2) Create the parents of node from the resident nodes
		
		OrdinaryVariable[] ovFilledArray = node.getOvArray(); 
		LiteralEntityInstance[] entityFilledArray = node.getEntityArray(); 
	
		for(ResidentNode residentNodeParent: resident.getResidentNodeFatherList()){
			
			List<SimpleSSBNNode> createdNodesList = createParents(node, ovFilledArray, entityFilledArray,
					residentNodeParent);
			
			for(SimpleSSBNNode newNode: createdNodesList){
				evaluateNodeInMFragInstance(mFragInstance, newNode); 
			}
			
		}
		
		//---- 3) Create the parents of node from the input nodes
		for(InputNode inputNodeParent: resident.getInputNodeFatherList()){
			
			if(inputNodeParent.getResidentNodePointer().getResidentNode().equals(resident)){
				//Special case: the recursivity... 
				SimpleSSBNNode newNode = createRecursiveParents(node, ovFilledArray, entityFilledArray, 
						inputNodeParent);
				evaluateNodeInMFragInstance(mFragInstance, newNode); 
				
			}else{
				createParents(node, ovFilledArray, entityFilledArray,
						inputNodeParent);	
			}
			
		}
		
		node.setFinished(true); 
		

		mFragInstance.setEvaluated(true); 
	}

	/**
	 * Cria SSBNNodes pais de um node para determinado nó residente. 
	 * 
	 * @param node                    Nó para o qual o pai serão avaliados
	 * @param ovFilledArray           Variaveis ordinarias que já possuem os seus valores definidos
	 * @param entityFilledArray       Valores definidos para as variáveis ordinarias de ovFilledArray
	 * @param residentNodeParent      Pai a ser avaliado. 
	 */
	private List<SimpleSSBNNode> createParents(SimpleSSBNNode node,
			OrdinaryVariable[] ovFilledArray, LiteralEntityInstance[] entityFilledArray,
			ResidentNode residentNodeParent) {
		
		JacketNode nodeParent = new JacketNode(residentNodeParent); 
		
		return createParents(node, ovFilledArray, entityFilledArray, nodeParent); 
	}

	/**
	 * Cria SSBNNodes pais de um node para determinado nó residente. 
	 * 
	 * @param node                    Nó para o qual o pai serão avaliados
	 * @param ovFilledArray           Variaveis ordinarias que já possuem os seus valores definidos
	 * @param entityFilledArray       Valores definidos para as variáveis ordinarias de ovFilledArray
	 * @param residentNodeParent      Pai a ser avaliado. 
	 */
	private  List<SimpleSSBNNode> createParents(SimpleSSBNNode node,
			OrdinaryVariable[] ovFilledArray, LiteralEntityInstance[] entityFilledArray,
			InputNode inputNodeParent) {
		
		JacketNode nodeParent = new JacketNode(inputNodeParent); 
		
		return createParents(node, ovFilledArray, entityFilledArray, nodeParent); 
	}	
	
	private  List<SimpleSSBNNode> createParents(SimpleSSBNNode node,
			OrdinaryVariable[] ovFilledArray, LiteralEntityInstance[] entityFilledArray,
			JacketNode nodeParent) {
		
		if(internalDebug){
			System.out.println("[In] CreateParents");
			System.out.println("[Arg] Node=" + node.getResidentNode().getName());
			System.out.print("[Arg] ovFilledArray = [");
			for(int i = 0; i < ovFilledArray.length; i++){
				System.out.print(ovFilledArray[i] + " ");
			}
			System.out.println("]");
			System.out.print("[Arg] entityFilledArray= [");
			for(int i = 0; i < entityFilledArray.length; i++){
				System.out.print(entityFilledArray[i].getInstanceName() + " ");
			}
			System.out.println("]");
			System.out.println("[Arg] inputNodeParent= " + nodeParent.getResidentNode());
		}
		
		List<SimpleSSBNNode> ssbnCreatedList = new ArrayList<SimpleSSBNNode>();
		
		List<OrdinaryVariable> newNodeOvFaultList = new ArrayList<OrdinaryVariable>(); 
		
		//Fill the ovFault list. 
		for(OrdinaryVariable ov: nodeParent.getOrdinaryVariableList()){
			boolean find = false; 
			for(OrdinaryVariable ov2: ovFilledArray){
				if(ov2.equals(ov)){
					find = true; 
					break; 
				}
			}
			if(!find){
				newNodeOvFaultList.add(ov); 
			}
		}
		
		//Mount the combination of possible values for the ordinary variable fault
		List<String[]> possibleCombinationsForOvFaultList = new ArrayList<String[]>(); 
		
		if(newNodeOvFaultList.size()>0){
			possibleCombinationsForOvFaultList = node.getMFragInstance().
			        recoverCombinationsEntitiesPossibles(
					    ovFilledArray, 
				      	entityFilledArray, 
					    newNodeOvFaultList.toArray(
                    		 new OrdinaryVariable[newNodeOvFaultList.size()])); 
		}else{
			possibleCombinationsForOvFaultList.add(new String[0]); //A stub element
		}
		
		//Create the new node... 
		for(String[] possibleCombination: possibleCombinationsForOvFaultList){
			
			SimpleSSBNNode newNode = SimpleSSBNNode.getInstance(
					nodeParent.getResidentNode()); 
			
			//1. Add the ovInstances of the children that the father also have 
			for(int i = 0; i < node.getOvArray().length; i++){
				
				//Para um nó de input IX1 referente ao nó resident RX1 devemos recuperar 
				//a variável ordinária da HomeMFrag de RX1 correspondente a V.O. 
				//da MFrag de IX1 para então setar-mos o ssbnNode. 
				
				OrdinaryVariable correspondentOV = 
					nodeParent.getCorrespondentOrdinaryVariable(node.getOvArray()[i]);
				
				if(correspondentOV != null){
					newNode.setEntityForOv(
							correspondentOV, 
							node.getEntityArray()[i]); 
				}
			}
			
			//2. Create the new OVInstances for the combination
			for(int index = 0; index < newNodeOvFaultList.size(); index++){
				
				OrdinaryVariable correspondentOV = 
					nodeParent.getCorrespondentOrdinaryVariable(newNodeOvFaultList.get(index));
				
				newNode.setEntityForOv(
						correspondentOV, 
						LiteralEntityInstance.getInstance(possibleCombination[index], 
								newNodeOvFaultList.get(index).getValueType())); 
			}
			
			newNode = addNodeToMFragInstance(node, newNode); 
			System.out.println("Created new node: " + newNode);
			
			ssbnCreatedList.add(newNode); 
		}
		
		return ssbnCreatedList; 
	}	
	
	
	/**
	 * This class is used to offer to the resident node and the input node the 
	 * same comportment for the method "createParents"
	 * 
	 * @author Laecio
	 */
	private class JacketNode{
		
		private ResidentNode residentNode; 
		private InputNode inputNode; 
		
		private boolean isResidentNode = false; 
		
		protected JacketNode(ResidentNode _residentNode){
			this.residentNode = _residentNode;
			this.isResidentNode = true; 
		}

		protected JacketNode(InputNode _inputNode){
			this.inputNode = _inputNode;
			this.isResidentNode = false; 		
		}

		public ResidentNode getResidentNode() {
			if(isResidentNode){
				return residentNode;
			}else{
				return inputNode.getResidentNodePointer().getResidentNode(); 
			}
		}
		
		public Collection<OrdinaryVariable> getOrdinaryVariableList() {
			if(isResidentNode){
				return residentNode.getOrdinaryVariableList(); 
			}else{
				return inputNode.getOrdinaryVariableList(); 
			}
		}
		
		public OrdinaryVariable getCorrespondentOrdinaryVariable(OrdinaryVariable ov){
			if(isResidentNode){
				return ov; 
			}else{
				return inputNode.getResidentNodePointer().getCorrespondentOrdinaryVariable(ov);
			}
		}
		
		public boolean isResidentNode() {
			return isResidentNode;
		}
		
		public boolean isInputNode(){
			return !isResidentNode; 
		}
		
	}
	
	//The format of the MFrag in the recursion is: 
	//      INPUTNODE_A(NODE_A) PAI NODE_A 
	//That follows: 
	//       RESIDENTCHILD = NODE_A
	// (RESIDENTCHILD is the reference of the input INPUTNODE_A
	
	private  SimpleSSBNNode createRecursiveParents(SimpleSSBNNode node,
			OrdinaryVariable[] ovFilledArray, LiteralEntityInstance[] entityFilledArray,
			InputNode inputNodeParent) throws ImplementationRestrictionException, SSBNNodeGeneralException {
		
		ResidentNode residentNode = node.getResidentNode(); 
		
		
		//1) FIND THE ENTITY ORDEREABLE 
		List<OrdinaryVariable> ovOrdereableList = residentNode.getOrdinaryVariablesOrdereables();
		
		if(ovOrdereableList.size() > 1){
			throw new ImplementationRestrictionException(ImplementationRestrictionException.MORE_THAN_ONE_ORDEREABLE_VARIABLE);
		}
		
		if(ovOrdereableList.size() < 1){
			throw new ImplementationRestrictionException(ImplementationRestrictionException.RV_NOT_RECURSIVE);
		}
		
		OrdinaryVariable ovOrdereable = ovOrdereableList.get(0); //Have only one element... 
		
		//2) FIND THE PREVIOUS ELEMENT. 
		ObjectEntity objectEntityOrdereable = residentNode.getMFrag().
                        getMultiEntityBayesianNetwork().getObjectEntityContainer().
                        getObjectEntityByType(ovOrdereable.getValueType()); 
	
		LiteralEntityInstance ovOrdereableActualValue = node.getEntityForOv(ovOrdereable); 
		OVInstance ovInstanceOrdereable = OVInstance.getInstance(ovOrdereable, ovOrdereableActualValue); 
		
		if(ovInstanceOrdereable == null){
			throw new SSBNNodeGeneralException();
		}
		
		String nameEntity = ovInstanceOrdereable.getEntity().getInstanceName(); 
		
		ObjectEntityInstanceOrdereable objectEntityInstanceOrdereable = 
			(ObjectEntityInstanceOrdereable)objectEntityOrdereable.getInstanceByName(nameEntity);
		
		if(objectEntityInstanceOrdereable == null){
			throw new SSBNNodeGeneralException();
		}
		
		ObjectEntityInstanceOrdereable prev = objectEntityInstanceOrdereable.getPrev(); 

		LiteralEntityInstance ovOrdereablePreviusValue = 
			LiteralEntityInstance.getInstance(prev.getName(), ovOrdereable.getValueType());
		
		//3) Mount the father 
		
		/*
		 * Nota: uma pequena restrição aqui (fácil de ser retirada entretanto):
		 * Consideramos que o nó pai e o nó filho possuem os mesmos argumentos com 
		 * excessão do argumento recursivo. Isto mantém a compatibilidade com as 
		 * considerações feitas no algoritmo anterior.  
		 */ 
		
		SimpleSSBNNode newNode = SimpleSSBNNode.getInstance(residentNode); 
		for(int i = 0; i < node.getOvArray().length; i++){
			if(!node.getOvArray()[i].equals(ovOrdereable)){
				newNode.setEntityForOv(node.getOvArray()[i], ovOrdereablePreviusValue); 
			}else{
				newNode.setEntityForOv(node.getOvArray()[i], node.getEntityArray()[i]); 
			}
		}
		
		newNode = addNodeToMFragInstance(node, newNode);
		
		return newNode; 
	}

	/**
	 * Add the father node to the MFragInstance of the child node and add the link
	 * between the two nodes. Verify also if the father (newNode) already exists 
	 * in the ssbn, take the alread exist object if positive (return it). 
	 * 
	 * @param child  The node alread present in mFragInstance 
	 * @param father The new Node to be added. 
	 * @return       the new node
	 */
	private SimpleSSBNNode addNodeToMFragInstance(SimpleSSBNNode child,
			SimpleSSBNNode father) {
		
		father = ssbn.addSSBNNodeIfItDontAdded(father);
		
		child.addParent(father);
		child.getMFragInstance().addSSBNNode(father);
		child.getMFragInstance().addEdge(new SimpleEdge(father, child));
		
		return father;
	
	}	
	

	/**
	 * Evaluate the context nodes of a MFrag using the ordinary variables already
	 * instanciated. <b>
	 * 
	 * - Ordinary variables don't instanciated yet will be instanciated. <b>
	 * - Should have more than one reference for a ordinary variable <b>
	 * - Should have reference uncertainty problem (how return this problem) <b>
	 * - Should have ordinary variables that don't have instance for it <b>
	 * 
	 * Cases: 
	 * - Trivial case
	 * - Simple Search (one entity for ov)
	 * - Compost Search (more than one entity)
	 * - Undefined Context (more than one possible result)
	 * 
	 * @param mfrag MFrag evaluated
	 * @param ovInstances Ordinary variables already instanciated. 
	 * @throws SSBNNodeGeneralException 
	 * @throws ImplementationRestrictionException 
	 * @throws OVInstanceFaultException 
	 */
	public MFragInstance evaluateMFragContextNodes(MFragInstance mFragInstance) 
	                   throws ImplementationRestrictionException, 
	                          SSBNNodeGeneralException, 
	                          OVInstanceFaultException{
		
		//Consider that the tree with the know ordinary variables are already mounted. 
		//Consider that the only ordinary variables filled are the alread know OV
		List<OVInstance> ovInstances = mFragInstance.getOVInstances(); 
		
		for(ContextNode contextNode: mFragInstance.getContextNodeList()){
			
			
			//---> 1) Verify if the context node is soluted only with the know arguments. 
			List<OrdinaryVariable> ovInstancesFault = contextNode.getOVFaultForOVInstanceSet(ovInstances); 
			
			if(ovInstancesFault.size() == 0){
				boolean result = kb.evaluateContextNodeFormula(contextNode, ovInstances);
				if(result){
					mFragInstance.setStateEvaluationOfContextNode(contextNode, 
							ContextNodeEvaluationState.EVALUATION_OK); 
					break; 
				}else{
					System.out.println("Context Node Evaluation fail"); 
					mFragInstance.setStateEvaluationOfContextNode(contextNode, 
							ContextNodeEvaluationState.EVALUATION_FAIL);
					mFragInstance.setUseDefaultDistribution(true); 
					break; //TODO: the MFragInstance should continue to be evaluated?
				}
			}
			
			
			//---> 2) Use the Entity Tree Strategy. 
			SearchResult searchResult = kb.evaluateSearchContextNodeFormula(contextNode, ovInstances); 
			
			if(searchResult!= null){  
				
				//Result valid results: Add the result to the tree of result.
				try {
					
					mFragInstance.getEntityTree().updateTreeForNewInformation(
							searchResult.getOrdinaryVariableSequence(), 
							searchResult.getValuesResultList());

					mFragInstance.setStateEvaluationOfContextNode(contextNode, ContextNodeEvaluationState.EVALUATION_OK); 

				} catch (MFragContextFailException e) {
					e.printStackTrace(); 
					mFragInstance.setStateEvaluationOfContextNode(contextNode, ContextNodeEvaluationState.EVALUATION_FAIL); 
				    mFragInstance.setUseDefaultDistribution(true); 
				}
				
				break;
			}
			
			
			//---> 3) Use the Interation with user Strategy. 
			// To be developed yet... 
//			notInstanciatedOVList = mFragInstance.getListNotInstanciatedOV(); 
//			System.out.println("\nOVInstances don't found = " + notInstanciatedOVList.size());
//			for(OrdinaryVariable ov: notInstanciatedOVList){
//				System.out.println(ov.getName());
//			}
//			if (notInstanciatedOVList.size() != 0){
//				System.out.println("Try 2: Use the iteration aproach");
//				for(OrdinaryVariable ov: notInstanciatedOVList){
//					if(interationHelper!=null){
//						OVInstance ovInstance = interationHelper.getInstanceValueForOVFault(ov);
//						if(ovInstance != null){
//							mFragInstance.addInstanciatedOV(ovInstance.getOv(),	ovInstance.getEntity()); 
//						}
//					}
//				}
//			}
			
			//---> 4) Use the uncertainty Strategy. 
			//To be developed yet
			
			//--> 5) Nothing more to try... context fail
			mFragInstance.setStateEvaluationOfContextNode(contextNode, ContextNodeEvaluationState.EVALUATION_SEARCH); 
			mFragInstance.setUseDefaultDistribution(false); 
			
		}
		
		//Return mFragInstance with the ordinary variables filled. 
		return mFragInstance; 
	}
	
}



