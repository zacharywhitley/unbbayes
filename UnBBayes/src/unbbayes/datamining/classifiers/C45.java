/*
 * Created on 24/05/2003
 *
 */
package unbbayes.datamining.classifiers;

import java.io.*;
import java.util.*;

import javax.swing.*;
import javax.swing.tree.*;

import unbbayes.datamining.datamanipulation.*;
/**
 * @author Mário Henrique
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
public class C45 extends DecisionTreeLearning implements Serializable{

	/** Load resources file for internacionalization */
	private transient ResourceBundle resource;

	/** The root of the tree generated by the constructor */
	private JTree tree ;

	public void buildClassifier(InstanceSet data) throws Exception
		{
			  //internacionalization
			  resource = ResourceBundle.getBundle("unbbayes.datamining.classifiers.resources.ClassifiersResource");

			  //preliminary tests
			  if (!data.getClassAttribute().isNominal())
			  {
				throw new Exception(resource.getString("exception1"));
			  }

			Enumeration enum = data.enumerateInstances();
			while (enum.hasMoreElements())
			{
				Instance instance = (Instance)enum.nextElement();
				Enumeration enumAtt = data.enumerateAttributes();
				while (enumAtt.hasMoreElements())
				{
					if (instance.isMissing((Attribute)enumAtt.nextElement()))
					{
						throw new Exception(resource.getString("exception3"));
					}
				}
			}


			  //tree generation
			  makeTree(data);
		}

	protected void makeTree(InstanceSet data) throws Exception
	{
		//Contains methods to compute information gain and related actions
		ClassifierUtils2 utils = new ClassifierUtils2(data);
		//Queue to use this function recursively,keeping stack components (see below)
		ArrayList queue = new ArrayList();
		//Intance set variable used to keep the current one
		//InstanceSet instances = data;
		//Root of the tree, is constant during the function(isn't part of the final tree)
		DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");
		//Tree node variable used to keep the current one
		DefaultMutableTreeNode treeNode = root;


		int numInstances = data.numInstances();
		int numAttributes = data.numAttributes();
		int numClasses = data.numClasses();
		Attribute classAttribute = data.getClassAttribute();
		int classIndex = classAttribute.getIndex();
		ArrayList actualInst = new ArrayList(numInstances);
		Integer[] actualAtt = new Integer[numAttributes];
		for (int i=0;i<numInstances;i++)
		{
			actualInst.add(new Integer(i));
		}
		for (int i=0;i<numAttributes;i++)
		{
			actualAtt[i] = new Integer(i);
		}
		SplitObject split = new SplitObject();
		split.setAttributes(actualAtt);
		split.setInstances(actualInst);

		//start stack with the initial data
		queue.add(new QueueComponent(treeNode,split));

		QueueComponent queueComponent;
		Leaf leaf;
		double[] infoGains;
		int attributeIndex;
		double[] distribution;
		Instance inst;
		SplitObject[] splitData;
		DefaultMutableTreeNode treeNodeNew;
		Node node;

		//start recursive code
		while ((!queue.isEmpty()))
		{
			//gets the queue's first instance set and its parent
			queueComponent = (QueueComponent)queue.remove(0);
			treeNode = queueComponent.getParent();

			split = queueComponent.splitObject;
			actualInst = split.getInstances();
			numInstances = actualInst.size();

			//if no instance has reached this node - is leaf
			if (numInstances == 0)
			{
				leaf = new Leaf(Instance.missingValue(),new double[numClasses]);
				treeNode.add(new DefaultMutableTreeNode(leaf));
			}
			else
			{
				// compute array with the gain of each attribute.
				infoGains = utils.computeInfoGain(split);

				//gets attribute with maximum gain
				attributeIndex = Utils.maxIndex(infoGains);

				//make leaf if information gain is zero....
				if (Utils.eq(infoGains[attributeIndex], 0))
				{
					//computes the number of instances for each class
					distribution = new double[numClasses];
					for (int i=0;i<numInstances;i++)
					{
						inst = data.getInstance(((Integer)actualInst.get(i)).intValue());
						distribution[(int) inst.classValue()] += inst.getWeight();
					}

					leaf = new Leaf(classAttribute,distribution);
					treeNode.add(new DefaultMutableTreeNode(leaf));
				}

				//...Otherwise create successors.
				else
				{
					int realAttribute = -1;
					int i;
					actualAtt = split.getAttributes();
					numAttributes = actualAtt.length;
					for (i=0;i<numAttributes;i++)
					{
						if (actualAtt[i].intValue()!=classIndex)
						{
							realAttribute++;
							if (realAttribute==attributeIndex)
							{
								break;
							}
						}
					}

					splitData = utils.splitData(split, i);
					Attribute tempAtt = data.getAttribute(actualAtt[i].intValue());
					for (int j=0;j<splitData.length;j++)
					{
						treeNodeNew = new DefaultMutableTreeNode(new Node(tempAtt,j));
						treeNode.add(treeNodeNew);
						queue.add(new QueueComponent(treeNodeNew,splitData[j]));
					}
				}

			}

		}

		//makes tree
		if(root.isLeaf())
		{
			 root.setUserObject("NULL");
		}
		else
		{
			 treeNode = (DefaultMutableTreeNode)root.getFirstChild();
			 node = (Node)treeNode.getUserObject();
			 root.setUserObject(node.getAttributeName());
		}
		tree = new JTree(root);
	}

	public JTree getTree()
	{
		return tree;
	}

	public String toString()
	{
		Leaf leaf;
		Node node;
		Stack stack = new Stack();
		StringBuffer text = new StringBuffer();
		DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getModel().getRoot();

		stack.push(treeNode);
		//text.append(resource.getString("id3ToString"));

		while (!stack.empty())
		{
			treeNode = (DefaultMutableTreeNode)stack.pop();

			if(treeNode.isLeaf())
			{
				leaf = (Leaf)treeNode.getUserObject();
				text.append(": "+leaf.toString());
			}
			else
			{
				if(treeNode.getLevel()!=0)
				{
					text.append("\n");
					for (int i=0;i<treeNode.getLevel()-1;i++)
					{
						text.append("|	");
					}
					node = (Node)treeNode.getUserObject();
					text.append(node.toString());
				}

				for(int i=treeNode.getChildCount()-1;i>=0;i--)
				{
					stack.push(treeNode.getChildAt(i));
				}
			}
		}
		return  text.toString();
	}

	/**
	   * Classifies a given test instance using the decision tree.
	   *
	   * @param instance the instance to be classified
	   * @return the classification
	   */
	  public byte classifyInstance(Instance instance)
	  {
		Leaf leaf;
		Node node;
		Attribute att;
		double splitValue;
		String[] attValues;
		DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getModel().getRoot();
		DefaultMutableTreeNode treeNodeTemp;

		if (treeNode.isLeaf())
		{
			return -1;
		}

		while(!treeNode.getFirstChild().isLeaf())
		{
			treeNodeTemp = (DefaultMutableTreeNode)treeNode.getFirstChild();
			node = (Node)treeNodeTemp.getUserObject();
			att = node.getAttribute();
			//if (att.isNominal())
			//{
				treeNode = (DefaultMutableTreeNode)treeNode.getChildAt(instance.getValue(node.getAttribute()));
			//}
		}

		treeNode = (DefaultMutableTreeNode)treeNode.getFirstChild();
		leaf = (Leaf)treeNode.getUserObject();
		return leaf.getClassValue();
	  }

	/*************************************************************************/

	private class QueueComponent
	{
		private DefaultMutableTreeNode parent;
		private SplitObject splitObject;

		public QueueComponent(DefaultMutableTreeNode newParent, SplitObject splitObject)
		{
			parent = newParent;
			this.splitObject = splitObject;
		}

		public SplitObject getSplitObject()
		{
			return splitObject;
		}

		public DefaultMutableTreeNode getParent()
		{
			return parent;
		}
	}
}

