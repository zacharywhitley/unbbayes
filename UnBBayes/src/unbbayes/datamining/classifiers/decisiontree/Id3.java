package unbbayes.datamining.classifiers.decisiontree;

import java.io.*; //Used StringBuffer in method toString(int level)
import java.util.*;

import javax.swing.*;
import javax.swing.tree.*;

import unbbayes.datamining.datamanipulation.*;

/**
 * Class implementing an Id3 decision tree classifier. For more
 * information, see<p>
 *
 * R. Quinlan (1986). <i>Induction of decision
 * trees</i>. Machine Learning. Vol.1, No.1, pp. 81-106.<p>
 *
 * @author Mário Henrique Paes Vieira (mariohpv@bol.com.br)
 * @author Danilo Balby Silva Castanheira (danbalby@yahoo.com)
 * @version $1.0 $ (24/12/2001)
 */

public class Id3 extends DecisionTreeLearning implements Serializable
{	/** Load resources file for internacionalization */
	private ResourceBundle resource;
	
	/** The root of the tree generated by the constructor */
	private JTree tree ;
	
	/** used to store the computed info gains */
	private HashMap infoGainsMap = new HashMap();
	
	/**instances used to create tree */
	private InstanceSet instances;
	
		
	//---------------------------------------------------------------------//

	/**
   	* Builds Id3 decision tree classifier.
	*
   	* @param data The training data
   	* @exception Exception if classifier can't be built successfully
   	*/
  	public void buildClassifier(InstanceSet data) throws Exception
	{
          //internacionalization
          resource = ResourceBundle.getBundle("unbbayes.datamining.classifiers.resources.ClassifiersResource");
          
          //preliminary tests 
          //throwns an exception in case of numeric or missing  values
          if (!data.getClassAttribute().isNominal())
          {
            throw new Exception(resource.getString("exception1"));
          }
          		
		Enumeration enum = data.enumerateInstances();
		while (enum.hasMoreElements())
		{
			Instance instance = (Instance)enum.nextElement();
			Enumeration enumAtt = data.enumerateAttributes();
			while (enumAtt.hasMoreElements())
			{
				if (instance.isMissing((Attribute)enumAtt.nextElement()))
				{
					throw new Exception(resource.getString("exception3"));
				}
			}
		}
          
		  instances = data;
		  
		  //tree generation
          makeTree(instances);
  	}
  	
  	//---------------------------------------------------------------------//

	/**
   	* Method building Id3 tree.
   	*
   	* @param data The training data
   	* @exception Exception if decision tree can't be built successfully
   	*/
  	protected void makeTree(InstanceSet data) throws Exception
	{
    }
   
  //-----------------------------------------------------------------------//

  /**
   * Classifies a given test instance using the decision tree.
   *
   * @param instance the instance to be classified
   * @return the classification
   */
  public byte classifyInstance(Instance instance)
  {		
	/*Leaf leaf;
	Node node;
	Attribute att;
	double splitValue;
	String[] attValues;
	DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getModel().getRoot();
	DefaultMutableTreeNode treeNodeTemp;
		
	if (treeNode.isLeaf())
	{
		return -1;
	}
			
	while(!treeNode.getFirstChild().isLeaf())
	{
		treeNodeTemp = (DefaultMutableTreeNode)treeNode.getFirstChild();
		node = (Node)treeNodeTemp.getUserObject();
		att = node.getAttribute();
		if (att.isNominal())
		{
			treeNode = (DefaultMutableTreeNode)treeNode.getChildAt(instance.getValue(node.getAttribute()));
		}
		else
		{
			attValues = att.getAttributeValues();
			splitValue = node.getAttributeValue();
			
			if(Double.parseDouble(attValues[instance.getValue(att.getIndex())])>=splitValue)
			{
				treeNode = (DefaultMutableTreeNode)treeNode.getChildAt(0);
			}
			else
			{
				treeNode = (DefaultMutableTreeNode)treeNode.getChildAt(1);
			}
		}
    }
    
	treeNode = (DefaultMutableTreeNode)treeNode.getFirstChild();
	leaf = (Leaf)treeNode.getUserObject();
	return leaf.getClassValue();*/
	return 0;
     
  }
  
  //-----------------------------------------------------------------------//

  /**
   * Prints the decision tree using the private toString method from below.
   *
   * @return a textual description of the classifier
   */
  public String toString()
  {
	Leaf leaf;
	Node node;
	Stack stack = new Stack();
	StringBuffer text = new StringBuffer();
	DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getModel().getRoot();
	
	stack.push(treeNode);
	text.append(resource.getString("id3ToString"));
	 
	while (!stack.empty())
	{
		treeNode = (DefaultMutableTreeNode)stack.pop();
				
		if(treeNode.isLeaf())
		{
			leaf = (Leaf)treeNode.getUserObject();
			text.append(": "+leaf.toString());
		}
		else
		{
			if(treeNode.getLevel()!=0)
			{
				text.append("\n"); 
				for (int i=0;i<treeNode.getLevel()-1;i++)
				{
					text.append("|	");
				}
				node = (Node)treeNode.getUserObject();
				text.append(node.toString());
			}
						
			for(int i=treeNode.getChildCount()-1;i>=0;i--)
			{
				stack.push(treeNode.getChildAt(i));
			}
		}
	}
  	return  text.toString();
  }
  
  public double[] getInfoGains(DefaultMutableTreeNode node)
  {
  		return (double[])infoGainsMap.get(node);
  }

  //----------------------------------------------------------------------//

  /**
   * Get the tree build by id3 classifier using the private getTree method from below.
   *
   * @return a JTree object build by id3
   */
  public JTree getTree()
  {	
	return tree;
  }
  
  //----------------------------------------------------------------------//
  
  public InstanceSet getInstances()
  {
  	return instances;
  }
}

/*************************************************************************/

class QueueComponent
{
	private DefaultMutableTreeNode parent;
	private InstanceSet instances;
	
	public QueueComponent(DefaultMutableTreeNode newParent, InstanceSet newInstances)
	{
		parent = newParent;
		instances = newInstances;
	}
	
	public InstanceSet getInstances()
	{
		return instances;
	}
	
	public DefaultMutableTreeNode getParent()
	{
		return parent;
	}
}
