package unbbayes.datamining.classifiers;

import java.io.*; //Used StringBuffer in method toString(int level)
import java.util.*;

import javax.swing.*;
import javax.swing.tree.*;

import unbbayes.datamining.datamanipulation.*;

/**
 * Class implementing an Id3 decision tree classifier. For more
 * information, see<p>
 *
 * R. Quinlan (1986). <i>Induction of decision
 * trees</i>. Machine Learning. Vol.1, No.1, pp. 81-106.<p>
 *
 * @author Mário Henrique Paes Vieira (mariohpv@bol.com.br)
 * @author Danilo Balby 
 * @version $2.0 $ (08/05/2003)
 */

public class Id3 extends DecisionTreeLearning implements Serializable
{	/** Load resources file for internacionalization */
	private ResourceBundle resource;
	
	/** The root of the tree generated by the constructor */
	private JTree tree ;
	
	//---------------------------------------------------------------------//

	/**
   	* Builds Id3 decision tree classifier.
	*
   	* @param data The training data
   	* @exception Exception if classifier can't be built successfully
   	*/
  	public void buildClassifier(InstanceSet data) throws Exception
	{
          //internacionalization
          resource = ResourceBundle.getBundle("unbbayes.datamining.classifiers.resources.ClassifiersResource");
          
          //preliminary tests 
          //throwns an exception in case of numeric or missing  values
          if (!data.getClassAttribute().isNominal())
          {
            throw new Exception(resource.getString("exception1"));
          }
          Enumeration enumAtt = data.enumerateAttributes();
          while (enumAtt.hasMoreElements())
          {
            Attribute attr = (Attribute) enumAtt.nextElement();
            if (!attr.isNominal())
            {
              throw new Exception(resource.getString("exception2"));
            }
            Enumeration enum = data.enumerateInstances();
            while (enum.hasMoreElements())
            {
              if (((Instance) enum.nextElement()).isMissing(attr))
              {
                throw new Exception(resource.getString("exception3"));
              }
            }
          }
          
		  //tree generation
          makeTree(data);
  	}
  	
  	//---------------------------------------------------------------------//

	/**
   	* Method building Id3 tree.
   	*
   	* @param data The training data
   	* @exception Exception if decision tree can't be built successfully
   	*/
  	protected void makeTree(InstanceSet data) throws Exception
	{
          //Contains methods to compute information gain and related actions
          ClassifierUtils utils;
          //Queue to use this function recursively,keeping queue components (see below)
          ArrayList queue = new ArrayList();
		  //Intance set variable used to keep the current one
		  InstanceSet instances;
		  //Root of the tree, is constant during the function(isn't part of the final tree)
		  DefaultMutableTreeNode root = new DefaultMutableTreeNode("root"); 
          //Tree node variable used to keep the current one
          DefaultMutableTreeNode treeNode = root;
          
          Leaf leaf;
          Node node;
          Attribute splitAttribute;
          double[] infoGains;
          double[] distribution;
          Enumeration instEnum;
		  Instance inst;
          InstanceSet[] splitData;
          DefaultMutableTreeNode treeNodeNew;
          QueueComponent stackComponent;
        
          //start stack with the initial data
          queue.add(new QueueComponent(treeNode,data));
          
          //start recursive code
          while ((!queue.isEmpty()))
          {
			//gets the stack's first instance set and its parent  
			stackComponent = (QueueComponent)queue.remove(0);
			instances = stackComponent.getInstances();
			treeNode = stackComponent.getParent();
			
			utils = new ClassifierUtils(instances);
          	          	
          	//if no instance has reached this node - is leaf 
          	if (instances.numInstances() == 0)
          	{
            	leaf = new Leaf(Instance.missingValue(),new double[instances.numClasses()]);
            	treeNode.add(new DefaultMutableTreeNode(leaf));
          	}
          	else
          	{
          		// compute array with the gain of each attribute.
          		infoGains = utils.computeInfoGain();

          		// Compute the information gain mean
			    /* double meanInfoGains = Utils.sum(infoGains)/(double)(infoGains.length);

          		for (int i=0; i<data.numAttributes(); i++)
          		{
            		if (infoGains[i] > meanInfoGains)
            		{
              			Attribute att = (Attribute) data.getAttribute(i);
              			infoGains[att.getIndex()] = utils.computeGainRatio(data, att);

            		}
          		}*/

          		//gets attribute with maximum gain
          		splitAttribute = instances.getAttribute(Utils.maxIndex(infoGains));

          		//make leaf if information gain is zero....
          		if (Utils.eq(infoGains[splitAttribute.getIndex()], 0))
          		{
            		//computes the number of instances for each class
            		distribution = new double[instances.numClasses()];
            		instEnum = instances.enumerateInstances();
            		while (instEnum.hasMoreElements())
            		{
              			inst = (Instance) instEnum.nextElement();
              			distribution[(int) inst.classValue()] += inst.getWeight();
           			}
           			
            		leaf = new Leaf(instances.getClassAttribute(),distribution);
            		treeNode.add(new DefaultMutableTreeNode(leaf));
           		}
          		
          		//...Otherwise create successors.
          		else
          		{
					splitData = ClassifierUtils.splitData(instances, splitAttribute);
            		for (int j=0;j<splitAttribute.numValues();j++)
            		{
						treeNodeNew = new DefaultMutableTreeNode(new Node(splitAttribute,j));
						treeNode.add(treeNodeNew);
						queue.add(new QueueComponent(treeNodeNew,splitData[j]));
               		}
        		}
       		}
        }
        
       //makes tree
       if(root.isLeaf())
       {
       		root.setUserObject("NULL");
       }
       else 
       {
       		treeNode = (DefaultMutableTreeNode)root.getFirstChild();
       		node = (Node)treeNode.getUserObject();
       		root.setUserObject(node.getAttributeName());
       }
       tree = new JTree(root);
    }
   
  //-----------------------------------------------------------------------//

  /**
   * Classifies a given test instance using the decision tree.
   *
   * @param instance the instance to be classified
   * @return the classification
   */
  public byte classifyInstance(Instance instance)
  {		
	Leaf leaf;
	Node node;
	DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getModel().getRoot();
	DefaultMutableTreeNode treeNodeTemp;
		
	if (treeNode.isLeaf())
	{
		return -1;
	}
			
	while(!treeNode.getFirstChild().isLeaf())
	{
		treeNodeTemp = (DefaultMutableTreeNode)treeNode.getFirstChild();
		node = (Node)treeNodeTemp.getUserObject();
		treeNode = (DefaultMutableTreeNode)treeNode.getChildAt(instance.getValue(node.getAttribute()));
    }
    
	treeNode = (DefaultMutableTreeNode)treeNode.getFirstChild();
	leaf = (Leaf)treeNode.getUserObject();
	return leaf.getClassValue();
     
  }
  
  //-----------------------------------------------------------------------//

  /**
   * Prints the decision tree using the private toString method from below.
   *
   * @return a textual description of the classifier
   */
  public String toString()
  {
	Leaf leaf;
	Node node;
	Stack stack = new Stack();
	StringBuffer text = new StringBuffer();
	DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getModel().getRoot();
	
	stack.push(treeNode);
	text.append(resource.getString("toStringException2"));
	 
	while (!stack.empty())
	{
		treeNode = (DefaultMutableTreeNode)stack.pop();
				
		if(treeNode.getLevel()==0)
		{
			for(int i=0;i<treeNode.getChildCount();i++)
			{
				stack.push(treeNode.getChildAt(i));
			}
		}
		else if(treeNode.isLeaf())
		{
			leaf = (Leaf)treeNode.getUserObject();
			text.append(": "+leaf.toString());
		}
		else
		{
			text.append("\n");
			for (int i=0;i<treeNode.getLevel()-1;i++)
			{
				text.append("|	");
			}
			node = (Node)treeNode.getUserObject();
			text.append(node.toString());
						
			for(int i=0;i<treeNode.getChildCount();i++)
			{
				stack.push(treeNode.getChildAt(i));
			}
		}
	}
	return  text.toString();
  }


  //-----------------------------------------------------------------------//

  /**
   * Get the tree build by id3 classifier using the private getTree method from below.
   *
   * @return a JTree object build by id3
   */
  public JTree getTree()
  {	
	return tree;
  }
}

/*************************************************************************/

class QueueComponent
{
	private DefaultMutableTreeNode parent;
	private InstanceSet instances;
	
	public QueueComponent(DefaultMutableTreeNode newParent, InstanceSet newInstances)
	{
		parent = newParent;
		instances = newInstances;
	}
	
	public InstanceSet getInstances()
	{
		return instances;
	}
	
	public DefaultMutableTreeNode getParent()
	{
		return parent;
	}
}