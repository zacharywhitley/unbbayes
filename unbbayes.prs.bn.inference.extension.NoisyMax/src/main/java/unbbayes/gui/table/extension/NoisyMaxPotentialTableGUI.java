/**
 * 
 */
package unbbayes.gui.table.extension;

import java.awt.Color;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableModel;

import org.omg.CORBA.portable.ValueInputStream;

import unbbayes.gui.table.ColumnGroup;
import unbbayes.gui.table.ExcelAdapter;
import unbbayes.gui.table.GUIPotentialTable;
import unbbayes.gui.table.GroupableTableCellRenderer;
import unbbayes.gui.table.GroupableTableColumnModel;
import unbbayes.gui.table.GroupableTableHeader;
import unbbayes.gui.table.ReplaceTextCellEditor;
import unbbayes.prs.INode;
import unbbayes.prs.Node;
import unbbayes.prs.bn.PotentialTable;
import unbbayes.util.Debug;
import unbbayes.util.extension.bn.inference.IIndependenceCausalInfluenceCPTConverter;
import unbbayes.util.extension.bn.inference.NoisyMaxCPTConverter;

/**
 * This is basically a GUI for potential tables
 * which only displays a subset of cells 
 * @author Shou Matsumoto
 *
 */
public class NoisyMaxPotentialTableGUI extends GUIPotentialTable {
	
	/** This is lazily initialized at {@link #getICICPTConverter()} */
	private IIndependenceCausalInfluenceCPTConverter iciCPTConverter = null;

	/** Load resource file (multi-language support) from core GUI */
	private static ResourceBundle resource = unbbayes.util.ResourceController.newInstance().getBundle(
				unbbayes.gui.resources.GuiResources.class.getName(),
				Locale.getDefault(),
				NoisyMaxPotentialTableGUI.class.getClassLoader()
			);

	/**
	 * @param potentialTable
	 */
	public NoisyMaxPotentialTableGUI(PotentialTable potentialTable) {
		super(potentialTable);
		// TODO Auto-generated constructor stub
	}

	/**
	 * Builds a JTable which is basically equal to the ones generated by the superclass, 
	 * but it only exposes cells that determines a noisy-max distribution.
	 * Additionally, the names of the columns (i.e. the first few lines which represents
	 * the states of the parents) will be factored, so that it does not display combinations
	 * of parents' states. For example, for the network A->B<-C,
	 * with A, B, C being nodes with 3 states {0,1,2}, the table of B will look like:
	 * <br/>
	 * <br/>
	 * <pre>
	 * --------------------- 
	 *|   ||   A   |   C   | 
	 *    ||---------------- 
	 *|   || 1 | 2 | 1 | 2 | 
	 * --------------------- 
	 *| 0 ||p3 |p5 |p9 |p11|
	 *| 1 ||p4 |p6 |p10|p12| 
	 * --------------------- 
	 * </pre>
	 * Given that rows represents states of B, and columns are states of parents.
	 * You can see that we don't use combinations of states of parents. We simply
	 * list up states of parents (except 1st state), and we don't specify the last state of the node
	 * which is the owner of the table (because such value is 1-previous values in the same column). 
	 * This is because other columns in CPT are automatically 
	 * estimated in Noisy-Max distribution, as follows:
	 * <br/>
	 * <br/>
	 * P(B|A=0,C=0) = [100%, 0%,  0%]; <br/>
	 * P(B|A=1,C=0) = [p3,   p4,  1-p3-p4]; <br/>
	 * P(B|A=2,C=0) = [p5,   p6,  1-p5-p6]; <br/>
	 * P(B|A=0,C=1) = [p9,   p10, 1-p9-p10]; <br/>
	 * P(B|A=0,C=2) = [p11,  p12, 1-p11-p12]; <br/>
	 * P(B|A=1,C=1) = [p3*p9, p4*p10-(p3*p9), 1-previous]; <br/>
	 * P(B|A=1,C=2) = [p3*p11, (p3+p4)*(p11+p12)-(p3*p11), 1-previous]; <br/>
	 * P(B|A=2,C=1) = [p5*p9, (p5+p6)*(p9+p10)-(p5*p9), 1-previous]; <br/>
	 * P(B|A=2,C=2) = [p5*p11, (p5+p6)*(p11+p12)-(p5*p11), 1-previous]; <br/>
	 * <br/>
	 * 
	 * @see unbbayes.gui.table.GUIPotentialTable#makeTable()
	 */
	public JTable makeTable() {
		// extract the basic attributes to be read
		PotentialTable table = getPotentialTable();		// the CPT we are reading
		int numVariables = table.variableCount();		// Number of variables
		Node tableOwner = (Node)table.getVariableAt(0);	// node that owns the currently selected CPT
		
		// this is used to parse the strings at the cells of jtable and convert them to probabilities.
		NumberFormat df = NumberFormat.getInstance(Locale.getDefault());
		df.setMaximumFractionDigits(4);					// assume 4 numbers after fractional point

		// the number of combinations of parent's states that we have (i.e. related to number of columns we'd have in ordinal CPT)
		int nCombinationStates = table.tableSize() / tableOwner.getStatesSize();

		// the number of rows is the number of states the node has, minus the last column, because the prob. of last state is 1-previous.
		int numRows = tableOwner.getStatesSize() - 1;
		if (numRows <= 0) {
			// needs more states in order to build a noisy-max distribution
			return null;
		}

		// the number of columns is the sum of number of states of parents + 1, because we need extra column for the names of parents and states.
		int numColumns = 1;	// this is the "+1" portion of "parents +1"
		for (int i = 1; i < numVariables; i++) {
			// the 1st variable (variable at index 0) is the node itself, and others are parents.
			// we only need parents, so start iteration from index 1
			numColumns += table.getVariableAt(i).getStatesSize()- 1 ;	// we don't need to specify 1st state
		}
		if (numColumns <= 1) {
			// needs more parents&states in order to build a noisy-max distribution
			return null;
		}
		
		/*
		 * Constructing the data of the data model.
		 * E.g. data[3][4 + 1]
		 * |------------------------------------------------------| 
		 * | Node State 1 |    1    |    1    |    1    |    1    | 
		 * | Node State 2 |    0    |    0    |    0    |    0    |
		 * | Node State 3 |    0    |    0    |    0    |    0    |
		 * |------------------------------------------------------|
		 */
		String[][] data = new String[numRows][numColumns];

		/*
		 * Constructing the 2-line headers
		 * 
		 * |--------------|-------------------|-------------------| 
		 * | Parents      |         A         |         B         |
		 * |------------------------------------------------------| 
		 * | States       | State 1 | State 2 | State 1 | State 2 |
		 * |------------------------------------------------------| 
		 * 
		 */
		String[] column = new String[data[0].length];
		if (numVariables <= 1) {
			// If there is no parent, we cannot use noisy-max anyway
			throw new IllegalArgumentException("Noisy-max can only be used when parents are present.");
		} else {
			/*
			 * The 1st column of 2nd row of the header.
			 * |--------------| 
			 * | States       |
			 * |--------------- 
			 */
			column[0] = resource.getString("StatesTitle");
			if (numVariables > 1) {
				/*
				 * Other columns of 2nd row of the header.
				 * Repeats all states in the node until there are cells to fill. 
				 * 
				 * |-------------------|-------------------| 
				 * | State 1 | State 2 | State 1 | State 2 |
				 * ----------------------------------------| 
				 */
				for (int varIndex = 1, columnIndex = 1; varIndex < table.getVariablesSize(); varIndex++) {	
					// iterate over parents (i.e. variables of table except the 1st var)
					INode parent = table.getVariableAt(varIndex);
					// now, iterate over states of current parent
					int numStates = parent.getStatesSize();
					for (int stateIndex = 1; stateIndex < numStates; stateIndex++, columnIndex++) { 
						// start from stateIndex=1, because we don't need to specify 1st state of parent
						column[columnIndex] = parent.getStateAt(stateIndex);
						// note: columnIndex increments only when stateIndex increments, but it is not reset when handling the next parent
					}
				}
			}
		}
		
		/*
		 * Filling the data of the table. For example:
		 * 
		 * |------------------------------------------------------| 
		 * | Node State 1 |    1    |    1    |    1    |    1    | 
		 * | Node State 2 |    0    |    0    |    0    |    0    |
		 * | Node State 3 |    0    |    0    |    0    |    0    |
		 * |------------------------------------------------------|
		 * 
		 * Note: PotentialTable represents matrix (table) as a 1-dimension array/vector, like the following:
		 * 
		 * |------------------------------------------------------------------| 
		 * | Array Position | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 
		 * | Array Value    | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0  | 0  |
		 * |------------------------------------------------------------------|
		 * 
		 * So, we need to access PotentialTable linearly, but fill jtable as matrix (and vice-versa).
		 * Please, notice that we only need to specify cells which are important for noisy-max specification.
		 * These are cells which represents the non-zero state for 1 parent, and zero state for all other parents:
		 * P(B|A=1,C=0) = [p3,   p4,  1-p3-p4]; 
		 * P(B|A=2,C=0) = [p5,   p6,  1-p5-p6]; 
		 * P(B|A=0,C=1) = [p9,   p10, 1-p9-p10]; 
		 * P(B|A=0,C=2) = [p11,  p12, 1-p11-p12];
		 */
		if (numRows > 0) {
			// create an array whose each element has an index of the states of the variable in the table. 
			// E.g. [1,2,3] means state 1 of owner of the table, state 2 of 1st parent, and state 3 of 2nd parent.
			int[] multidimensionalCoord = table.getMultidimensionalCoord(0);	// argument 0 means states of all nodes are in 0.
			
			// Iterate on which parent will have non-zero state. E.g. when parent=A, we are extracting P(B|A=X,C=0); and when parent=C we are extracting P(B|A=0,C=X)
			for (int varIndex = 1, columnIndex = 1; varIndex < numVariables; varIndex++) {
				int numStatesParent = table.getVariableAt(varIndex).getStatesSize();	// how many states the current parent has
				// iterate on non-zero states of current parent, given all other parents are at state 0 (this and varIndex is related to the column of the jtable)
				for (multidimensionalCoord[varIndex] = 1; multidimensionalCoord[varIndex] < numStatesParent; multidimensionalCoord[varIndex]++, columnIndex++) {
					// note: columnIndex increments only when stateIndex increments, but it is not reset when handling the next parent
					// iterate on states of table owner (this is related to the row of the jtable)
					for (multidimensionalCoord[0] = 0; multidimensionalCoord[0] < numRows;  multidimensionalCoord[0]++) {
						// Note: numRows = number of states of table owner - 1 (because last state's prob is 1-previous, so we don't need to specify)
						data[multidimensionalCoord[0]][columnIndex] = "" + df.format(table.getValue(multidimensionalCoord));
					}
				}
				// set index of this variable to 0, so that in the next iteration all indexes are at 0
				multidimensionalCoord[varIndex] = 0;
			}
		}
		
		/*
		 * Filling the 1st column with names of the state of the owner of CPT
		 * 
		 * |--------------- 
		 * | Node State 1 | 
		 * | Node State 2 |
		 * | Node State 3 |
		 * |---------------
		 * 
		 * We don't need the last state of node, because it is 1-prob of previous states
		 */ 
		for (int i = 0; i < numRows; i++) {	// numRows is already number of states - 1
			// note: we don't need to specify the last state, because its probability is 1-previous
			data[i][0] = tableOwner.getStateAt(i);
		}
		
		/*
		 * Constructing the rest of the table.
		 * 
		 * |--------------|-------------------|-------------------| 
		 * | Father 1     | State 1 | State 2 | State 1 | State 2 |
		 * |------------------------------------------------------| 
		 * | Node State 1 |    1    |    1    |    1    |    1    | 
		 * | Node State 2 |    0    |    0    |    0    |    0    |
		 * | Node State 3 |    0    |    0    |    0    |    0    |
		 * |------------------------------------------------------|
		 */
		DefaultTableModel model = new DefaultTableModel();
		model.setDataVector(data, column);
		JTable jTable = new JTable();
		
		// This allows headers to be grouped (like merging cells of the header).
		jTable.setColumnModel(new GroupableTableColumnModel());
		jTable.setTableHeader(new GroupableTableHeader((GroupableTableColumnModel) jTable.getColumnModel()));
		jTable.setModel(model);
		
		// Extract Column model so that we can add new row&columns to header
		GroupableTableColumnModel columnModel = (GroupableTableColumnModel) jTable.getColumnModel();
		
		/*
		 * Default color of first column.
		 * |--------------- 
		 * | Parents      |
		 * |--------------| 
		 * | States       |
		 * |--------------- 
		 * 
		 */
		columnModel.getColumn(0).setHeaderRenderer(new GroupableTableCellRenderer());
		
		/*
		 * Default color of node's states
		 * |--------------- 
		 * | Node State 1 | 
		 * | Node State 2 |
		 * | Node State 3 |
		 * |---------------
		 * 
		 */
		columnModel.getColumn(0).setCellRenderer(new GroupableTableCellRenderer(Color.BLACK, Color.YELLOW));
		
		/*
		 * Set the 1st column header
		 * |--------------|---
		 * | Parents      |
		 * |--------------|---
		 */
		ColumnGroup columnNodeGroup = new ColumnGroup(new GroupableTableCellRenderer(), resource.getString("fatherCPT"));
		columnNodeGroup.add(columnModel.getColumn(0));
		columnModel.addColumnGroup(columnNodeGroup);
		
		/*
		 * Fill all other headers, except for the first (it has already been set). It ignores variableIndex = 0 (which is the node itself).
		 * ---|-------------------|-------------------| 
		 *    |         A         |         B         |
		 * ---|---------------------------------------| 
		 */
		for (int variableIndex = 1, columnIndex = 1; variableIndex < numVariables; variableIndex++) { 
			// column 0 does not need to be merged (it contains a label), so start from column 1.
			// similarly, variableIndex=0 is the owner of the table, but since we want to iterate on parents, start from 1
			Node parent = (Node)table.getVariableAt(variableIndex);
			
			// we will merge cells in the header, so that there is only 1 cell for all states of the parent. 
			// So we need to know how many cells to merge, and it is the number of states of the parent currently being visited.
			int numStatesParent = table.getVariableAt(variableIndex).getStatesSize()-1;  // subtract 1, because we don't need to specify 1st state in noisy max
			
			ColumnGroup columnGroup = new ColumnGroup(parent.getName()); // instantiate the "merged" cell
			
			// iterate on columns so that we create new columns and then merge
			for (int i = 0; i < numStatesParent; i++) {
				// how many cells to merge = numStatesParent
				columnGroup.add(columnModel.getColumn(columnIndex));	
				columnIndex++;
			}
			
			// add merged column to model
			columnModel.addColumnGroup(columnGroup);
		}
		
		jTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		
		// the following code was migrated from SEN controller to here
		// (feature:3315773) Allow copy/paste between JTable and Excel
		new ExcelAdapter(jTable);
		
		// (feature:3315761) Allow the selection of a single cell
		jTable.setCellSelectionEnabled(true);
		jTable.setRowSelectionAllowed(true);
		

		// Change the text cell editor to replace text instead of appending it for all columns.
		ReplaceTextCellEditor cellEditor = new ReplaceTextCellEditor();
		for (int i = 0; i < jTable.getColumnModel().getColumnCount(); i++) {
			jTable.getColumnModel().getColumn(i).setCellEditor(cellEditor);
		}

		// Shows the caret while editing cell.
		jTable.setSurrendersFocusOnKeystroke(true);
		
		this.fillWithDefaultTableChangeListener(jTable);
		
		return jTable;
	}

	/* (non-Javadoc)
	 * @see unbbayes.gui.table.GUIPotentialTable#fillWithDefaultTableChangeListener(javax.swing.JTable)
	 */
	public void fillWithDefaultTableChangeListener(JTable table) {
		if (table == null) {
			// ignore if no table was provided
			return;
		}
		
		// just use a final variable so that we can use it inside a listener
		// TODO use an argument instead of a final variable.
		final JTable jTable = table;
		
		jTable.getModel().addTableModelListener(new TableModelListener() {
			public void tableChanged(TableModelEvent e) {
				if (getPotentialTable() == null || getPotentialTable().getVariablesSize() <= 0) {
					Debug.println("No probabilistic table found");
					return;
				}
				// extract first 
				INode node = getPotentialTable().getVariableAt(0);
				// Change state name or reset to its previous value.
				if (e.getColumn() == 0) {
					if (!jTable.getValueAt(e.getLastRow(), e.getColumn()).toString().trim().equals("")) {
						node.setStateAt(
								jTable.getValueAt(e.getLastRow(),0).toString(), 
								e.getLastRow() - (jTable.getRowCount() + 1 - node.getStatesSize())	// +1 is because the jtable has 1 fewer rows than original CPT
							);
					} else {
						jTable.revalidate();
						jTable.setValueAt(
								node.getStateAt(e.getLastRow() - (jTable.getRowCount() + 1 - node.getStatesSize())),  // +1 is because the jtable has 1 fewer rows than original CPT
								e.getLastRow(),
								e.getColumn()
							);
					}
				// Change the CPT cell or reset to its previous value.
				} else if (getPotentialTable() != null) {
					// extracted the user input
					String valueText = jTable.getValueAt(e.getLastRow(), e.getColumn()).toString().replace(',', '.');
					
					// use a vector of indexes for each parent, because it's going to be easier in this way
					int[] coordinateOfCellInCPT = getPotentialTable().getMultidimensionalCoord(0);
					coordinateOfCellInCPT[0] = e.getLastRow();	// the row represents the state of the owner of the table (variable at index 0)
					
					// find which state of which variable (parent) is associated with selected column in JTable
					
					int numVariables 	 = getPotentialTable().getVariablesSize();	// we'll iterate on variables declared in CPT
					int variableIndex 	 = 1;										// this will be the index of the variable related to the cell selected in jtable
					
					// visit columns from the beginning, in order to search for the index of variable
					for (int index1stInColumn = 1 ; variableIndex < numVariables ; variableIndex++) {  // index1stInColumn will point to 1st column (of jtable) of each variable
						// each variable occupies a number of columns which is number of states of associated parent - 1 (-1 because we don't specify 1st state)
						int numColumns = getPotentialTable().getVariableAt(variableIndex).getStatesSize() - 1;	
						if (index1stInColumn + numColumns > e.getColumn()) {
							// columnIndex will exceeded selected column in next iteration, so the selected column is related to the current variable
							// and the difference e.getColumn() - columnIndex is related to the index of state of the variable
							coordinateOfCellInCPT[variableIndex] = e.getColumn() - index1stInColumn + 1;		// +1 because we did not include 0-th state in jtable
							break;
						}
						// move columnIndex to 1st column of next variable
						index1stInColumn += numColumns;
						
					}
							
							
					try {
						float value = Float.parseFloat(valueText);
						
						// calculate the sum of prob of all states except the last state, because the prob of last state is 1 - the sum
						float sum = 0f;
						
						// clone coordinateOfCellInCPT, and use it in order to iterate only on cells of current column in CPT
						int[] coordinateForIterationOnSameColumn = getPotentialTable().getMultidimensionalCoord(getPotentialTable().getLinearCoord(coordinateOfCellInCPT));
						// iterate on cells of current column in CPT
						int stateSizeMinus1 = getPotentialTable().getVariableAt(variableIndex).getStatesSize() - 1;	// - 1 because we don't need to iterate on last state
						for (coordinateForIterationOnSameColumn[0] = 0; coordinateForIterationOnSameColumn[0] < stateSizeMinus1; coordinateForIterationOnSameColumn[0]++) {
							if (coordinateForIterationOnSameColumn[0] == coordinateOfCellInCPT[0]) {
								// this is the value being updated now
								sum += value;	
							} else {
								// other values
								sum += getPotentialTable().getValue(coordinateForIterationOnSameColumn);
							}
						}
						// check if sum is consistent
						if (sum < 0f || sum > 1f) {
							// it's an invalid edit. Do not make any updates
							JOptionPane.showMessageDialog(null, getResource().getString("numberFormatError"), getResource().getString("error"), JOptionPane.ERROR_MESSAGE);
						} else {
							// Note: at this point, sum is consistent, and 1-sum will be also consistent
							
							// check in advance if ICI class is available
							IIndependenceCausalInfluenceCPTConverter ici = getICICPTConverter();
							if (ici == null) {
								// if not ready, we cannot use noisy-max
								throw new NullPointerException(getResource().getString("argumentMissing") + " : getICICPTConverter() == null");
							}
							
							// update the value inserted by the user
							getPotentialTable().setValue(coordinateOfCellInCPT , value);
							
							// point to last cell
							coordinateForIterationOnSameColumn[0] = node.getStatesSize()-1;	
							
							// set the last cell of the column as 1-sum
							getPotentialTable().setValue(coordinateForIterationOnSameColumn, 1f-sum);
							
							
							// force other cells of CPT to become a noisy-max distribution
							ici.forceCPTToIndependenceCausalInfluence(getPotentialTable());
						}
						
					} catch (NumberFormatException nfe) {
						// Just show the error message if the value is not empty.
						if (!valueText.trim().equals("")) {
							JOptionPane.showMessageDialog(null, 
									getResource().getString("numberFormatError"), 
									getResource().getString("error"),
									JOptionPane.ERROR_MESSAGE);
						}
						jTable.revalidate();
						jTable.setValueAt(
								"" + getPotentialTable().getValue(coordinateOfCellInCPT),
								e.getLastRow(), 
								e.getColumn()
							);
						
						// there's no need to update other cells in order to become a noisy-or distribution
					}
				}
			}
		});
	}

	/**
	 * @return the iciCPTConverter: object responsible for reading specific columns of the CPT
	 * and automatically fill other cells of the same CPT in order to result in some
	 * distribution with independence of causal influence (ICI).
	 * Noisy-max has ICI property.
	 * If it was null, this method will lazy-initialize and instantiate {@link NoisyMaxCPTConverter}
	 * @see NoisyMaxCPTConverter
	 */
	public IIndependenceCausalInfluenceCPTConverter getICICPTConverter() {
		// lazy initialization
		if (iciCPTConverter == null) {
			iciCPTConverter = new NoisyMaxCPTConverter();
		}
		return iciCPTConverter;
	}

	/**
	 * @param iciCPTConverter : object responsible for reading specific columns of the CPT
	 * and automatically fill other cells of the same CPT in order to result in some
	 * distribution with independence of causal influence (ICI).
	 * Noisy-max has ICI property.
	 * @see NoisyMaxCPTConverter
	 */
	public void setICICPTConverter(IIndependenceCausalInfluenceCPTConverter iciCPTConverter) {
		this.iciCPTConverter = iciCPTConverter;
	}

	

}
