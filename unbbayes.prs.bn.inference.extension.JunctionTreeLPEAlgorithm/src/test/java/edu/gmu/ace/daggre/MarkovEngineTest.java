/**
 * 
 */
package edu.gmu.ace.daggre;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import junit.framework.TestCase;
import unbbayes.io.NetIO;
import unbbayes.prs.Edge;
import unbbayes.prs.INode;
import unbbayes.prs.Node;
import unbbayes.prs.bn.Clique;
import unbbayes.prs.bn.JunctionTreeAlgorithm;
import unbbayes.prs.bn.PotentialTable;
import unbbayes.prs.bn.ProbabilisticNetwork;
import unbbayes.prs.bn.ProbabilisticNode;
import unbbayes.prs.bn.Separator;
import unbbayes.prs.bn.inference.extension.AssetAwareInferenceAlgorithm;
import unbbayes.prs.bn.inference.extension.ZeroAssetsException;
import unbbayes.prs.exception.InvalidParentException;
import unbbayes.util.Debug;
import edu.gmu.ace.daggre.MarkovEngineImpl.AddTradeNetworkAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.BalanceTradeNetworkAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.DummyTradeAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.InexistingQuestionException;
import edu.gmu.ace.daggre.MarkovEngineImpl.RebuildNetworkAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.ResolveQuestionNetworkAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.StructureChangeNetworkAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.VirtualTradeAction;
import edu.gmu.ace.daggre.ScoreSummary.SummaryContribution;

/**
 * @author Shou Matsumoto
 *
 */
public class MarkovEngineTest extends TestCase {
	
	private static final int THREAD_NUM = 1; //75;	// quantity of threads to use in order to test multi-thread behavior

	public static final int MAX_NETWIDTH = 3;
	public static final int MAX_STATES = 5;
	public static final int MIN_STATES = 2;
	
	/** Error margin used when comparing 2 probability values */
	public static final float PROB_ERROR_MARGIN = 0.0005f;

	/** Error margin used when comparing 2 asset (score) values */
	public static final float ASSET_ERROR_MARGIN = .5f;
	
	private MarkovEngineImpl engine = (MarkovEngineImpl) MarkovEngineImpl.getInstance((float)Math.E, (float)(10.0/Math.log(100)), 0);

	private boolean isToUseQValues = false;

	/**
	 * @param name
	 */
	public MarkovEngineTest(String name) {
		super(name);
	}

	/* (non-Javadoc)
	 * @see junit.framework.TestCase#setUp()
	 */
	protected void setUp() throws Exception {
		super.setUp();
		engine.setToUseQValues(isToUseQValues());
		engine.setCurrentLogBase((float) Math.E);
		engine.setCurrentCurrencyConstant((float) (10/Math.log(100)));
		engine.setDefaultInitialAssetTableValue(0f);
		engine.setToReturnEVComponentsAsScoreSummary(false);
		engine.setToDeleteResolvedNode(true);
		engine.initialize();
		Debug.setDebug(true);
	}

	/* (non-Javadoc)
	 * @see junit.framework.TestCase#tearDown()
	 */
	protected void tearDown() throws Exception {
		super.tearDown();
	}

	/** This was created just to run addQuestion in multiple threads and same transaction*/
	private class AddQuestionThread extends Thread{
		private final long questionID;
		private Long transactionKey;
		public AddQuestionThread(Long transactionKey, long questionID) {
			super();
			this.questionID = questionID;
			this.transactionKey = transactionKey;
		}
		public void run() {
			boolean isToCommitTransaction = false;
			if (transactionKey == null) {
				// if no transaction key was provided, 
				// we shall test several threads in several transactions
				transactionKey = engine.startNetworkActions();
				isToCommitTransaction = true;
			}
			engine.addQuestion(
					transactionKey, 
					new Date(), 
					questionID, 
					Math.max(MIN_STATES, Math.min(1 + (int)(MAX_STATES*Math.random()), MAX_STATES)), // between MIN_STATES and MAX_STATES 
					null
				);
			if (isToCommitTransaction) {
				// transactionKey was null -> several threads + several transactions case
				engine.commitNetworkActions(transactionKey);
			}
		}
	}
	

	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#addQuestion(long, java.util.Date, long, int, java.util.List)}.
	 */
	public final void testAddQuestion() {
		// initial assertion
		assertNotNull(engine.getProbabilisticNetwork());
		
		// no nodes in network.
		assertEquals(0, engine.getProbabilisticNetwork().getNodeCount());
		
		// case 1 : several threads in 1 transaction
		
		// start transaction
		long transactionKey = engine.startNetworkActions();
		
		// run addQuestion in THREAD_NUM threads
		Thread[] threads = new AddQuestionThread[THREAD_NUM];
        for (int i = 0; i < THREAD_NUM; i++) {
            threads[i] = new AddQuestionThread(transactionKey, i);
            threads[i].start();
        }
        
        // wait until the threads are finished
        for (int i = 0; i < THREAD_NUM; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
            	e.printStackTrace();
                fail(e.getMessage());
            }
        }
		
        // assert actions were added in order of date
        List<NetworkAction> actions = engine.getNetworkActionsMap().get(transactionKey);
        for (int i = 1; i < actions.size(); i++) {
        	// it is inconsistent if previous action was created afer next action.
			assertFalse(actions.get(i-1).getWhenCreated().after(actions.get(i).getWhenCreated()));
		}
        
        // commit transaction
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			engine.addQuestion(transactionKey, new Date(), Long.MAX_VALUE, 2, null);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// check if network contains THREAD_NUM nodes 
		assertEquals(THREAD_NUM, engine.getProbabilisticNetwork().getNodeCount());
		
		// check if network contains nodes with ID from 0 to THREAD_NUM-1
		for (int i = 0; i < THREAD_NUM; i++) {
			assertNotNull(engine.getProbabilisticNetwork().getNode(Integer.toString(i)));
		}
		
		// check consistency of marginal probabilities
		Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
		assertNotNull(probLists);
		assertEquals(engine.getProbabilisticNetwork().getNodeCount(), probLists.size());
		for (Long questionId : probLists.keySet()) {
			// check consistency of marginal prob value
			List<Float> prob = probLists.get(questionId);
			assertNotNull("Question " + questionId, prob);
			assertFalse("Question " + questionId + " = " + prob,prob.isEmpty());
			float sum = 0.0f;
			for (Float value : prob) {
				assertTrue("Question " + questionId + " = " + prob, value >= 0.0f);
				assertTrue("Question " + questionId + " = " + prob, value <= 1.0f);
				sum += value;
			}
			assertEquals("Question " + questionId + " = " + prob, 1.0f, sum, PROB_ERROR_MARGIN);
		}
		
		// reset engine
		engine.initialize();
		assertNotNull(engine.getProbabilisticNetwork());
		assertEquals(0, engine.getProbabilisticNetwork().getNodeCount());
		
		
		// case 2 : several transactions, several threads.
		// run addQuestion in THREAD_NUM threads
		threads = new AddQuestionThread[THREAD_NUM];
        for (int i = 0; i < THREAD_NUM; i++) {
        	// by passing null as transactionKey, AddQuestionThread will call startNetworkActions and commitNetworkActions for each thread
            threads[i] = new AddQuestionThread(null, i);
            threads[i].start();
        }
        
        // wait until the threads are finished
        for (int i = 0; i < THREAD_NUM; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
            	e.printStackTrace();
                fail(e.getMessage());
            }
        }
        
     	// check if network contains THREAD_NUM nodes 
		assertEquals(THREAD_NUM, engine.getProbabilisticNetwork().getNodeCount());
		
		// check if network contains nodes with ID from 0 to THREAD_NUM-1
		for (int i = 0; i < THREAD_NUM; i++) {
			assertNotNull(engine.getProbabilisticNetwork().getNode(Integer.toString(i)));
		}
		
		// check consistency of marginal probabilities
		probLists = engine.getProbLists(null, null, null);
		assertNotNull(probLists);
		assertEquals(engine.getProbabilisticNetwork().getNodeCount(), probLists.size());
		for (Long questionId : probLists.keySet()) {
			// check consistency of marginal prob value
			List<Float> prob = probLists.get(questionId);
			assertNotNull("Question " + questionId, prob);
			assertFalse("Question " + questionId + " = " + prob,prob.isEmpty());
			float sum = 0.0f;
			for (Float value : prob) {
				assertTrue("Question " + questionId + " = " + prob, value >= 0.0f);
				assertTrue("Question " + questionId + " = " + prob, value <= 1.0f);
				sum += value;
			}
			assertEquals("Question " + questionId + " = " + prob, 1.0f, sum, PROB_ERROR_MARGIN);
		}
		
		// check if we can add same nodes again
		Node duplicateNode = engine.getProbabilisticNetwork().getNodeAt((int) (Math.random()*engine.getProbabilisticNetwork().getNodeCount()));
		try {
			engine.addQuestion(null, new Date(), Long.parseLong(duplicateNode.getName()), duplicateNode.getStatesSize(), null);
			fail("Should report duplicate node " + duplicateNode);
		} catch (IllegalArgumentException e) {
			//ok
		}
		
		// check that we cannot add a resolved node
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), Long.parseLong(duplicateNode.getName()), (int)(Math.random()*duplicateNode.getStatesSize()));
		try {
			engine.addQuestion(transactionKey, new Date(), Long.parseLong(duplicateNode.getName()), (int)(Math.random()*5)+1, null);
			fail("Should report duplicate node " + duplicateNode);
		} catch (IllegalArgumentException e) {
			//ok
		}
		
		// same test with transactionKey == null
		engine.resolveQuestion(null, new Date(), Long.parseLong(duplicateNode.getName()), (int)(Math.random()*duplicateNode.getStatesSize()));
		try {
			engine.addQuestion(null, new Date(), Long.parseLong(duplicateNode.getName()), (int)(Math.random()*5)+1, null);
			fail("Should report duplicate node " + duplicateNode);
		} catch (IllegalArgumentException e) {
			//ok
		}
	}

	/**created just to represent a BN edge using only IDs*/
	private class QuestionPair{
		public final Long right;
		public final Long left;
		public QuestionPair (Long left, Long right) {
			this.left = left;
			this.right = right;
			
		}
		/* (non-Javadoc)
		 * @see java.lang.Object#hashCode()
		 */
		public int hashCode() {
			return new Integer(right.hashCode() + left.hashCode()).hashCode();
		}
		/* (non-Javadoc)
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		public boolean equals(Object obj) {
			if (obj == null) {
				return false;
			}
			if (obj instanceof QuestionPair) {
				QuestionPair pair = (QuestionPair) obj;
				return this.left.equals(pair.left) && this.right.equals(pair.right);
			}
			return false;
		}
		/* (non-Javadoc)
		 * @see java.lang.Object#toString()
		 */
		public String toString() {
			return "(" + this.left + "," + this.right + ")";
		}
		
	}
	
	/** This was created just to run addQuestionAssumption in multiple threads*/
	private class AddQuestionAssumptionThread extends Thread{
		private Long transactionKey;
		private final Collection<QuestionPair> generatedEdges;
		private final List<Long> generatedNodes;
		private final Map<Long, Integer> parentNumCounters;
		public AddQuestionAssumptionThread(Long transactionKey, List<Long> generatedNodes, Collection<QuestionPair> generatedEdges, Map<Long,Integer> parentNumCounters) {
			super();
			this.transactionKey = transactionKey;
			this.generatedNodes = generatedNodes;
			this.generatedEdges = generatedEdges;
			this.parentNumCounters = parentNumCounters;
		}
		public void run() {
			boolean isToCommitTransaction = false;
			synchronized (generatedNodes) {
				if (transactionKey == null) {
					// if no transaction key was provided, 
					// we shall test several threads in several transactions
					transactionKey = engine.startNetworkActions();
					isToCommitTransaction = true;
				}
				List<Long> newNodes = new ArrayList<Long>();
				synchronized (parentNumCounters) {
					int overallIterationNum = (int)(5*Math.random() + 1);	// do at least 1 operation
					for (int j = 0; j < overallIterationNum; j++) {
						if (Math.random() < .6) {
							int nodeIterationNum = (int)(5*Math.random());
							for (int i = 0; i < nodeIterationNum; i++) {
								Long nodeID = (long) generatedNodes.size();
								engine.addQuestion(
										transactionKey, 
										new Date(), 
										nodeID, 
										Math.max(MIN_STATES, Math.min(1 + (int)(MAX_STATES*Math.random()), MAX_STATES)), // between MIN_STATES and MAX_STATES
										null
								);
								newNodes.add(nodeID);
								generatedNodes.add(nodeID);
								parentNumCounters.put(nodeID, 0);
							}
						}
						if (generatedNodes.size() >= 2) {
							if (Math.random() < .5) {
								int edgeIterationNum = (int)(5*Math.random());
								synchronized (generatedEdges) {
									for (int i = 0; i < edgeIterationNum; i++) {
										// randomly pick destination of edge
										long child = (long) (generatedNodes.size() * Math.random());
										// randomly pick origins of edges
										List<Long> parents = new ArrayList<Long>();
										do {
											long destination = (long) (generatedNodes.size() * Math.random());
											if (destination < child) {
												// make sure destination  > origin always, so that loop becomes impossible
												long aux = destination;
												destination = child;
												child = aux;
											} else if (destination == child) {
												continue;	// pick random again
											}
											parents.add(destination);
										} while (parents.isEmpty() || (Math.random() < .7));
										// limit the max quantity of parents to 5
										if (parentNumCounters.get(child) + parents.size() > MAX_NETWIDTH) {
											continue;
										}
										// origin should always be smaller than anything in destination
										try {
											engine.addQuestionAssumption(
													transactionKey, 
													new Date(), 
													child, 
													parents, 
													((Math.random()<.5)?null:new ArrayList<Float>())
											);
											int actuallyAddedParentsCounter = 0;
											for (Long parent : parents) {
												if (generatedEdges.add(new QuestionPair(parent, child))) {
													actuallyAddedParentsCounter++;
												}
											}
											parentNumCounters.put(child, parentNumCounters.get(child) + actuallyAddedParentsCounter);
										} catch (InexistingQuestionException e) {
											i--;
											continue;
//											e.printStackTrace();
										}
									}
								}
							}
						}
				}
				}
				if (isToCommitTransaction) {
					// transactionKey was null -> several threads + several transactions case
					try {
						engine.commitNetworkActions(transactionKey);
					} catch (Exception e) {
						generatedNodes.removeAll(newNodes);
						e.printStackTrace();
					}
				}
			}
		}
	}
	
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#addQuestionAssumption(long, java.util.Date, long, long, java.util.List)}.
	 */
	public final void testAddQuestionAssumption() {
		// initial assertion
		assertNotNull(engine.getProbabilisticNetwork());
		
		// no nodes in network.
		assertEquals(0, engine.getProbabilisticNetwork().getNodeCount());
		
		// no edges in network
		assertEquals(0, engine.getProbabilisticNetwork().getEdges().size());
		
		
		// case 1 : several threads in 1 transaction
		

		// start transaction
		long transactionKey = engine.startNetworkActions();
		
		
		// run addQuestion in THREAD_NUM threads
		AddQuestionAssumptionThread[] threads = new AddQuestionAssumptionThread[THREAD_NUM];
		List<Long> generatedNodes = Collections.synchronizedList(new ArrayList<Long>());
		Set<QuestionPair> generatedEdges = Collections.synchronizedSet(new HashSet<QuestionPair>());
		Map<Long, Integer> parentNumCounters = new ConcurrentHashMap<Long, Integer>();
        for (int i = 0; i < THREAD_NUM; i++) {
            threads[i] = new AddQuestionAssumptionThread(transactionKey, generatedNodes, generatedEdges,parentNumCounters);
            threads[i].start();
        }
        
        // wait until the threads are finished
        for (int i = 0; i < THREAD_NUM; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
            	e.printStackTrace();
                fail(e.getMessage());
            }
        }
		
        // commit transaction
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			engine.addQuestionAssumption(transactionKey, new Date(), (long)0, Collections.singletonList((long)1), null);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// check if data structures are synchronized
		assertEquals(parentNumCounters.keySet().size(), generatedNodes.size());
		int parentNumCounterValuesSum = 0;
		for (Integer numParents : parentNumCounters.values()) {
			parentNumCounterValuesSum += numParents;
		}
		assertEquals(parentNumCounterValuesSum, generatedEdges.size());
		
		// check if network contains all nodes and edges
		assertEquals(generatedNodes.size(), engine.getProbabilisticNetwork().getNodeCount());
		assertEquals(generatedEdges.size(), engine.getProbabilisticNetwork().getEdges().size());
		
		for (Long nodeID : generatedNodes) {
			assertEquals(nodeID + " is not present in " + engine.getProbabilisticNetwork(),
					Long.toString(nodeID),
					engine.getProbabilisticNetwork().getNode(Long.toString(nodeID)).getName());
		}
		for (QuestionPair pair : generatedEdges) {
			Node node1 = engine.getProbabilisticNetwork().getNode(Long.toString(pair.left));
			Node node2 = engine.getProbabilisticNetwork().getNode(Long.toString(pair.right));
			assertNotNull(pair.left + " is null", node1);
			assertNotNull(pair.right + " is null", node2);
			assertFalse(pair.left + ".equals(" + pair.right+")", node1.equals(node2));
			assertFalse(pair.left + "->" + pair.right + " is not present in " + engine.getProbabilisticNetwork(),
					engine.getProbabilisticNetwork().hasEdge(node1, node2) < 0);
		}
		
		// check consistency of marginal probabilities
		Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
		assertNotNull(probLists);
		assertEquals(engine.getProbabilisticNetwork().getNodeCount(), probLists.size());
		for (Long questionId : probLists.keySet()) {
			// check consistency of marginal prob value
			List<Float> prob = probLists.get(questionId);
			assertNotNull("Question " + questionId, prob);
			assertFalse("Question " + questionId + " = " + prob,prob.isEmpty());
			float sum = 0.0f;
			for (Float value : prob) {
				assertTrue("Question " + questionId + " = " + prob, value >= 0.0f);
				assertTrue("Question " + questionId + " = " + prob, value <= 1.0f);
				sum += value;
			}
			assertEquals("Question " + questionId + " = " + prob, 1.0f, sum, PROB_ERROR_MARGIN);
		}
		
		// reset engine
		engine.initialize();
		assertNotNull(engine.getProbabilisticNetwork());
		assertEquals(0, engine.getProbabilisticNetwork().getNodeCount());
		
		
		// case 2 : several transactions, several threads.
		
		// run addQuestion in THREAD_NUM threads
		threads = new AddQuestionAssumptionThread[THREAD_NUM];
		generatedNodes.clear();
		generatedEdges.clear();
        for (int i = 0; i < THREAD_NUM; i++) {
        	// by passing null as transactionKey, AddQuestionThread will call startNetworkActions and commitNetworkActions for each thread
            threads[i] = new AddQuestionAssumptionThread(null, generatedNodes, generatedEdges, parentNumCounters);
            threads[i].start();
        }
        
        // wait until the threads are finished
        for (int i = 0; i < THREAD_NUM; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
            	e.printStackTrace();
                fail(e.getMessage());
            }
        }
        
        // check if network contains all nodes and edges
		assertEquals(generatedNodes.size(), engine.getProbabilisticNetwork().getNodeCount());
		assertEquals(generatedEdges.size(), engine.getProbabilisticNetwork().getEdges().size());
		for (Long nodeID : generatedNodes) {
			assertEquals(nodeID + " is not present in " + engine.getProbabilisticNetwork(),
					Long.toString(nodeID),
					engine.getProbabilisticNetwork().getNode(Long.toString(nodeID)).getName());
		}
		for (QuestionPair pair : generatedEdges) {
			Node node1 = engine.getProbabilisticNetwork().getNode(Long.toString(pair.left));
			Node node2 = engine.getProbabilisticNetwork().getNode(Long.toString(pair.right));
			assertNotNull(pair.left + " is null", node1);
			assertNotNull(pair.right + " is null", node2);
			assertFalse(pair.left + ".equals(" + pair.right+")", node1.equals(node2));
			assertFalse(pair.left + "->" + pair.right + " is not present in " + engine.getProbabilisticNetwork(),
					engine.getProbabilisticNetwork().hasEdge(node1, node2) < 0);
		}
		
		// check consistency of marginal probabilities
		probLists = engine.getProbLists(null, null, null);
		assertNotNull(probLists);
		assertEquals(engine.getProbabilisticNetwork().getNodeCount(), probLists.size());
		for (Long questionId : probLists.keySet()) {
			// check consistency of marginal prob value
			List<Float> prob = probLists.get(questionId);
			assertNotNull("Question " + questionId, prob);
			assertFalse("Question " + questionId + " = " + prob,prob.isEmpty());
			float sum = 0.0f;
			for (Float value : prob) {
				assertTrue("Question " + questionId + " = " + prob, value >= 0.0f);
				assertTrue("Question " + questionId + " = " + prob, value <= 1.0f);
				sum += value;
			}
			assertEquals("Question " + questionId + " = " + prob, 1.0f, sum, PROB_ERROR_MARGIN);
		}
		
		// case 3 : edges being substituted
		
		// reset engine
		engine.initialize();
		assertNotNull(engine.getProbabilisticNetwork());
		assertEquals(0, engine.getProbabilisticNetwork().getNodeCount());
		
		
		/*
		 * Create following net
		 *  0<-1
		 *  ^
		 *  |
		 *  2
		 */
		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0, 2, null);
		engine.addQuestion(transactionKey, new Date(), 1, 2, null);
		engine.addQuestion(transactionKey, new Date(), 2, 2, null);
		List<Long> assumptiveQuestionIds = new ArrayList<Long>();
		assumptiveQuestionIds.add((long) 1);
		assumptiveQuestionIds.add((long) 2);
		engine.addQuestionAssumption(transactionKey, new Date(), 0, assumptiveQuestionIds, null);
		engine.commitNetworkActions(transactionKey);
		// check network structure consistency
		assertEquals(3, engine.getProbabilisticNetwork().getNodeCount());
		assertNotNull(engine.getProbabilisticNetwork().getNode("0"));
		assertNotNull(engine.getProbabilisticNetwork().getNode("1"));
		assertNotNull(engine.getProbabilisticNetwork().getNode("2"));
		assertEquals(2,engine.getProbabilisticNetwork().getNode("0").getParents().size());
		assertEquals(0,engine.getProbabilisticNetwork().getNode("1").getParents().size());
		assertEquals(0,engine.getProbabilisticNetwork().getNode("2").getParents().size());
		assertEquals(2, engine.getProbabilisticNetwork().getEdges().size());
		assertNotNull(engine.getProbabilisticNetwork().hasEdge(
				engine.getProbabilisticNetwork().getNode("1"), 
				engine.getProbabilisticNetwork().getNode("0"))
			);
		assertNotNull(engine.getProbabilisticNetwork().hasEdge(
				engine.getProbabilisticNetwork().getNode("2"), 
				engine.getProbabilisticNetwork().getNode("0"))
			);
		// check cpt
		for (Node node : engine.getProbabilisticNetwork().getNodes()) {
			PotentialTable cpt = ((ProbabilisticNode)node).getProbabilityFunction();
			for (int i = 0; i < cpt.tableSize(); i++) {
				assertEquals("Node " + node + ", index " + i, .5, cpt.getValue(i), PROB_ERROR_MARGIN);
			}
		}
		
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork() && !engine.isToAddArcsWithoutReboot()) {
			/*
			 * Modify to following net
			 *  0<-1
			 *  |
			 *  V
			 *  2
			 */
			transactionKey = engine.startNetworkActions();
			// delete edge 2->0 (leave only 1 -> 0)
			assumptiveQuestionIds = new ArrayList<Long>();
			assumptiveQuestionIds.add((long) 1);
			List<Float> cpd = new ArrayList<Float>();
			cpd.add(.8f);
			cpd.add(.2f);
			cpd.add(.1f);
			cpd.add(.9f);
			engine.addQuestionAssumption(transactionKey, new Date(), 0, assumptiveQuestionIds, cpd);	// let 1->0 substitute the old edges
			
			// add edge 0 -> 2
			assumptiveQuestionIds = new ArrayList<Long>();
			assumptiveQuestionIds.add((long) 0);
			engine.addQuestionAssumption(transactionKey, new Date(), 2, assumptiveQuestionIds, cpd);
			
			engine.commitNetworkActions(transactionKey);
			
			// check network structure consistency
			assertEquals(3, engine.getProbabilisticNetwork().getNodeCount());
			assertNotNull(engine.getProbabilisticNetwork().getNode("0"));
			assertNotNull(engine.getProbabilisticNetwork().getNode("1"));
			assertNotNull(engine.getProbabilisticNetwork().getNode("2"));
			assertEquals(1,engine.getProbabilisticNetwork().getNode("0").getParents().size());
			assertEquals(0,engine.getProbabilisticNetwork().getNode("1").getParents().size());
			assertEquals(1,engine.getProbabilisticNetwork().getNode("2").getParents().size());
			assertEquals(2, engine.getProbabilisticNetwork().getEdges().size());
			assertNotNull(engine.getProbabilisticNetwork().hasEdge(
					engine.getProbabilisticNetwork().getNode("1"), 
					engine.getProbabilisticNetwork().getNode("0"))
					);
			assertNotNull(engine.getProbabilisticNetwork().hasEdge(
					engine.getProbabilisticNetwork().getNode("0"), 
					engine.getProbabilisticNetwork().getNode("2"))
					);
			// check cpts of each node
			ProbabilisticNode nodeToTest = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode("0");
			PotentialTable cpt = nodeToTest.getProbabilityFunction();
			assertEquals(4, cpt.tableSize());
			assertEquals(.8f, cpt.getValue(0), PROB_ERROR_MARGIN);
			assertEquals(.2f, cpt.getValue(1), PROB_ERROR_MARGIN);
			assertEquals(.1f, cpt.getValue(2), PROB_ERROR_MARGIN);
			assertEquals(.9f, cpt.getValue(3), PROB_ERROR_MARGIN);
			nodeToTest = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode("1");
			cpt = nodeToTest.getProbabilityFunction();
			assertEquals(2, cpt.tableSize());
			assertEquals(.5f, cpt.getValue(0), PROB_ERROR_MARGIN);
			assertEquals(.5f, cpt.getValue(1), PROB_ERROR_MARGIN);
			nodeToTest = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode("2");
			cpt = nodeToTest.getProbabilityFunction();
			assertEquals(4, cpt.tableSize());
			assertEquals(.8f, cpt.getValue(0), PROB_ERROR_MARGIN);
			assertEquals(.2f, cpt.getValue(1), PROB_ERROR_MARGIN);
			assertEquals(.1f, cpt.getValue(2), PROB_ERROR_MARGIN);
			assertEquals(.9f, cpt.getValue(3), PROB_ERROR_MARGIN);
			
			// check consistency of marginal probabilities
			probLists = engine.getProbLists(null, null, null);
			assertNotNull(probLists);
			assertEquals(engine.getProbabilisticNetwork().getNodeCount(), probLists.size());
			for (Long questionId : probLists.keySet()) {
				// check consistency of marginal prob value
				List<Float> prob = probLists.get(questionId);
				assertNotNull("Question " + questionId, prob);
				assertFalse("Question " + questionId + " = " + prob,prob.isEmpty());
				float sum = 0.0f;
				for (Float value : prob) {
					assertTrue("Question " + questionId + " = " + prob, value >= 0.0f);
					assertTrue("Question " + questionId + " = " + prob, value <= 1.0f);
					sum += value;
				}
				assertEquals("Question " + questionId + " = " + prob, 1.0f, sum, PROB_ERROR_MARGIN);
			}
			
			
			// case 3 : edges being substituted in same transaction
			
			engine.initialize();
			assertNotNull(engine.getProbabilisticNetwork());
			assertEquals(0, engine.getProbabilisticNetwork().getNodeCount());
			
			transactionKey = engine.startNetworkActions();
			
			/*
			 * Create following net
			 *  0<-1
			 *  ^
			 *  |
			 *  2
			 */
			engine.addQuestion(transactionKey, new Date(), 0, 2, null);
			engine.addQuestion(transactionKey, new Date(), 1, 2, null);
			engine.addQuestion(transactionKey, new Date(), 2, 2, null);
			assumptiveQuestionIds = new ArrayList<Long>();
			assumptiveQuestionIds.add((long) 1);
			assumptiveQuestionIds.add((long) 2);
			engine.addQuestionAssumption(transactionKey, new Date(), 0, assumptiveQuestionIds, null);
			
			/*
			 * Modify to following net
			 *  0<-1
			 *  |
			 *  V
			 *  2
			 */
			// delete edge 2->0 (leave only 1 -> 0)
			assumptiveQuestionIds = new ArrayList<Long>();
			assumptiveQuestionIds.add((long) 1);
			cpd = new ArrayList<Float>();
			cpd.add(.8f);
			cpd.add(.2f);
			cpd.add(.1f);
			cpd.add(.9f);
			engine.addQuestionAssumption(transactionKey, new Date(), 0, assumptiveQuestionIds, cpd);	// let 1->0 substitute the old edges
			
			// add edge 0 -> 2
			assumptiveQuestionIds = new ArrayList<Long>();
			assumptiveQuestionIds.add((long) 0);
			engine.addQuestionAssumption(transactionKey, new Date(), 2, assumptiveQuestionIds, cpd);
			
			engine.commitNetworkActions(transactionKey);
			
			
			// check network structure consistency
			assertEquals(3, engine.getProbabilisticNetwork().getNodeCount());
			assertNotNull(engine.getProbabilisticNetwork().getNode("0"));
			assertNotNull(engine.getProbabilisticNetwork().getNode("1"));
			assertNotNull(engine.getProbabilisticNetwork().getNode("2"));
			assertEquals(1,engine.getProbabilisticNetwork().getNode("0").getParents().size());
			assertEquals(0,engine.getProbabilisticNetwork().getNode("1").getParents().size());
			assertEquals(1,engine.getProbabilisticNetwork().getNode("2").getParents().size());
			assertEquals(2, engine.getProbabilisticNetwork().getEdges().size());
			assertNotNull(engine.getProbabilisticNetwork().hasEdge(
					engine.getProbabilisticNetwork().getNode("1"), 
					engine.getProbabilisticNetwork().getNode("0"))
					);
			assertNotNull(engine.getProbabilisticNetwork().hasEdge(
					engine.getProbabilisticNetwork().getNode("0"), 
					engine.getProbabilisticNetwork().getNode("2"))
					);
			// check cpts of each node
			nodeToTest = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode("0");
			cpt = nodeToTest.getProbabilityFunction();
			assertEquals(4, cpt.tableSize());
			assertEquals(.8f, cpt.getValue(0), PROB_ERROR_MARGIN);
			assertEquals(.2f, cpt.getValue(1), PROB_ERROR_MARGIN);
			assertEquals(.1f, cpt.getValue(2), PROB_ERROR_MARGIN);
			assertEquals(.9f, cpt.getValue(3), PROB_ERROR_MARGIN);
			nodeToTest = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode("1");
			cpt = nodeToTest.getProbabilityFunction();
			assertEquals(2, cpt.tableSize());
			assertEquals(.5f, cpt.getValue(0), PROB_ERROR_MARGIN);
			assertEquals(.5f, cpt.getValue(1), PROB_ERROR_MARGIN);
			nodeToTest = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode("2");
			cpt = nodeToTest.getProbabilityFunction();
			assertEquals(4, cpt.tableSize());
			assertEquals(.8f, cpt.getValue(0), PROB_ERROR_MARGIN);
			assertEquals(.2f, cpt.getValue(1), PROB_ERROR_MARGIN);
			assertEquals(.1f, cpt.getValue(2), PROB_ERROR_MARGIN);
			assertEquals(.9f, cpt.getValue(3), PROB_ERROR_MARGIN);
			
			// check consistency of marginal probabilities
			probLists = engine.getProbLists(null, null, null);
			assertNotNull(probLists);
			assertEquals(engine.getProbabilisticNetwork().getNodeCount(), probLists.size());
			for (Long questionId : probLists.keySet()) {
				// check consistency of marginal prob value
				List<Float> prob = probLists.get(questionId);
				assertNotNull("Question " + questionId, prob);
				assertFalse("Question " + questionId + " = " + prob,prob.isEmpty());
				float sum = 0.0f;
				for (Float value : prob) {
					assertTrue("Question " + questionId + " = " + prob, value >= 0.0f);
					assertTrue("Question " + questionId + " = " + prob, value <= 1.0f);
					sum += value;
				}
				assertEquals("Question " + questionId + " = " + prob, 1.0f, sum, PROB_ERROR_MARGIN);
			}
			
			// check that we can add arcs related to resolved nodes
			engine.addQuestion(null, new Date(), Long.MAX_VALUE, 3, null);
			engine.addQuestion(null, new Date(), Long.MIN_VALUE, 3, null);
			engine.resolveQuestion(null, new Date(), 1, 0);
			engine.addQuestionAssumption(null, new Date(), 1, Collections.singletonList(Long.MAX_VALUE), null);
			engine.addQuestionAssumption(null, new Date(), Long.MIN_VALUE, Collections.singletonList(1L), null);
			
			// check that if we are using same transaction, it's also OK 
			transactionKey = engine.startNetworkActions();
			engine.resolveQuestion(transactionKey, new Date(), 0L, 0);
			engine.addQuestionAssumption(transactionKey, new Date(),0L, Collections.singletonList(Long.MAX_VALUE), null);
			engine.addQuestionAssumption(null, new Date(), Long.MIN_VALUE, Collections.singletonList(0L), null);
			engine.commitNetworkActions(transactionKey);
		}
		
	}

	/**
	 * Test method for 
	 * {@link edu.gmu.ace.daggre.MarkovEngineImpl#addCash(long, java.util.Date, long, float, java.lang.String)},
	 * {@link edu.gmu.ace.daggre.MarkovEngineImpl#getCash(long, List, List)},
	 * {@link edu.gmu.ace.daggre.MarkovEngineImpl#getAssetsIfStates(long, long, List, List)}.
	 */
	public final void testCashAndAssets() {
		/*
		 * Create following net
		 *  0<-1
		 *  ^
		 *  |
		 *  2
		 */
		Long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0, 2, null);
		engine.addQuestion(transactionKey, new Date(), 1, 2, null);
		engine.addQuestion(transactionKey, new Date(), 2, 2, null);
		List<Long> assumptiveQuestionIds = new ArrayList<Long>();
		assumptiveQuestionIds.add((long) 1);
		assumptiveQuestionIds.add((long) 2);
		engine.addQuestionAssumption(transactionKey, new Date(), 0, assumptiveQuestionIds, null);
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			engine.addCash(transactionKey, new Date(), Long.MAX_VALUE, 10, "To fail");
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		// do not continue test if we are not using assets at all
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			return;
		}
		// global cash should be 0 initially (i.e. q-values are initialized as 1)
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(Float.NaN, engine.getCash(1, null, null), ASSET_ERROR_MARGIN);
		} else {
			assertEquals(0f, engine.getCash(1, null, null), ASSET_ERROR_MARGIN);
		}
		List<Float> assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, null, null);
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertNull(assetsIfStates);
		} else {
			assertEquals(2, assetsIfStates.size());
			assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
			assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		}
		
		// test some conditional cash as well
		// non-null conditions
		List<Long> assumptionIds = new ArrayList<Long>();
		List<Integer> assumedStates = new ArrayList<Integer>();
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(Float.NaN, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		} else {
			assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		}
		
		// 1 = 0
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 1); assumedStates.add(0);	// node 1, state 0
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(Float.NaN, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		} else {
			assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		}
		
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, Collections.singletonList((long)1), Collections.singletonList(0));
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertNull(assetsIfStates);
		} else {
			assertEquals(2, assetsIfStates.size());
			assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
			assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		}
		try {
			engine.getAssetsIfStates((long)1, (long)1, Collections.singletonList((long)1), Collections.singletonList(0));
			fail("Should throw exception, because question = assumption");
		} catch (IllegalArgumentException e) {
			// OK, because question == 1 && assumption == 1 is invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, Collections.singletonList((long)1), Collections.singletonList(0));
		assertEquals(2, assetsIfStates.size());
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);

		// 1 = 0, 0 = null, 2 = null (equivalent to only 1 = 0)
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0); assumedStates.add(null);	// node 0, state null
		assumptionIds.add((long) 1); assumedStates.add(0);		// node 1, state 0
		assumptionIds.add((long) 2); assumedStates.add(null);	// node 2, state null
		assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assumptionIds.remove(0); assumedStates.remove(0);	// remove node 0 from assumption
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(4, assetsIfStates.size());	// will return table of assets, due to 2 = null
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(2), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(3), ASSET_ERROR_MARGIN);
		assumptionIds.set(1, (long)0); assumedStates.set(1, null);	// remove 2 from assumptions and add 0=null
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(4, assetsIfStates.size());
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(2), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(3), ASSET_ERROR_MARGIN);
		
		// 1 = 0, 0 = 0
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 1); assumedStates.add(0);	// node 1, state 0
		assumptionIds.add((long) 0); assumedStates.add(0);	// node 0, state 0
		assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assumptionIds.remove(0); assumedStates.remove(0);	// remove node 1 from assumption
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.add((long)1); assumedStates.add(0);	// re-add 1 = 0
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);

		// 2 = 1, 0 = 1
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 2); assumedStates.add(1);	// node 2, state 1
		assumptionIds.add((long) 0); assumedStates.add(1);	// node 0, state 1
		assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.remove(0); assumedStates.remove(0);	// remove 2 = 1
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// 1 = 1, 2 = 0
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 1); assumedStates.add(1);	// node 1, state 1
		assumptionIds.add((long) 2); assumedStates.add(0);	// node 2, state 0
		assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.remove(1); assumedStates.remove(1);	// remove 2 = 0
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(0f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(0f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// 0 = 0, 1 = 0, 2 = 1
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0); assumedStates.add(0);	// node 0, state 0
		assumptionIds.add((long) 1); assumedStates.add(0);	// node 1, state 0
		assumptionIds.add((long) 2); assumedStates.add(1);	// node 2, state 1
		assertEquals(0f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		try {
			engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		
		// add 100 cash
		transactionKey = engine.startNetworkActions();
		engine.addCash(transactionKey, new Date(), 1, 100f, "Just to test");
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			engine.addCash(transactionKey, new Date(), Long.MAX_VALUE-1, 10, "To fail");
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// test assumptions == null
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		

		// global cash should be 100 now
		assertEquals(100f, engine.getCash(1, null, null), ASSET_ERROR_MARGIN);
		
		
		// test some conditional cash as well
		// non-null conditions
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// 1 = 0
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 1); assumedStates.add(0);	// node 1, state 0
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);

		// 1 = 0, 0 = null, 2 = null (equivalent to only 1 = 0)
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0); assumedStates.add(null);	// node 0, state null
		assumptionIds.add((long) 1); assumedStates.add(0);		// node 1, state 0
		assumptionIds.add((long) 2); assumedStates.add(null);	// node 2, state null
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assumptionIds.remove(0); assumedStates.remove(0);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(4, assetsIfStates.size());	
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(2), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(3), ASSET_ERROR_MARGIN);
		assumptionIds.set(1, (long)0); assumedStates.set(1, null);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(4, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(2), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(3), ASSET_ERROR_MARGIN);
		
		// 1 = 0, 0 = 0
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 1); assumedStates.add(0);	// node 1, state 0
		assumptionIds.add((long) 0); assumedStates.add(0);	// node 0, state 0
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.remove(1); assumedStates.remove(1);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);

		// 2 = 1, 0 = 1
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 2); assumedStates.add(1);	// node 2, state 1
		assumptionIds.add((long) 0); assumedStates.add(1);	// node 0, state 1
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.remove(0); assumedStates.remove(0);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// 1 = 1, 2 = 0
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 1); assumedStates.add(1);	// node 1, state 1
		assumptionIds.add((long) 2); assumedStates.add(0);	// node 2, state 0
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		try {
			engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
			fail("Should throw exception, because assumption contains question");
		} catch (IllegalArgumentException e) {
			// OK, because if assumptions contain the question, then  it is an invalid argument
			assertNotNull(e);
		}
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());	
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.remove(1); assumedStates.remove(1);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// 0 = 0, 1 = 0, 2 = 1
		assumptionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0); assumedStates.add(0);	// node 0, state 0
		assumptionIds.add((long) 1); assumedStates.add(0);	// node 1, state 0
		assumptionIds.add((long) 2); assumedStates.add(1);	// node 2, state 1
		assertEquals(100f, engine.getCash(1, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		assumptionIds.remove(0); assumedStates.remove(0);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.set(0, (long)0); assumedStates.set(0, 0);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assumptionIds.set(1, (long)1); assumedStates.set(1, 0);
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, assumptionIds, assumedStates);
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		
		// do some extra test regarding the structure 1 -> 0 <- 2
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, Collections.singletonList((long)1), Collections.singletonList(1));
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)0, Collections.singletonList((long)2), Collections.singletonList(1));
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, Collections.singletonList((long)0), Collections.singletonList(1));
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, Collections.singletonList((long)1), Collections.singletonList(1));
		assertEquals(2, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)2, Collections.singletonList((long)1), null);
		assertEquals(4, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(2), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(3), ASSET_ERROR_MARGIN);	
		assetsIfStates = engine.getAssetsIfStates((long)1, (long)1, Collections.singletonList((long)2), (List)Collections.emptyList());
		assertEquals(4, assetsIfStates.size());
		assertEquals(100f, assetsIfStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(2), ASSET_ERROR_MARGIN);
		assertEquals(100f, assetsIfStates.get(3), ASSET_ERROR_MARGIN);			
		
		float INITIAL_ASSETS = 1000.0f;

		MarkovEngineImpl me = (MarkovEngineImpl) MarkovEngineImpl.getInstance();
		((MarkovEngineImpl)me).setCurrentLogBase(2);
		((MarkovEngineImpl)me).setCurrentCurrencyConstant(100);
		((MarkovEngineImpl)me).setDefaultInitialAssetTableValue((float) ((MarkovEngineImpl)me).getQValuesFromScore(INITIAL_ASSETS));
		
		transactionKey = me.startNetworkActions();
		me.addQuestion(transactionKey, new Date(), 1L, 2, null);
		me.commitNetworkActions(transactionKey);
		
		assertFalse(Double.isInfinite(me.getCash(2L, null, null)));
		
		// TODO test disconnected network cases
		
	}

	/**
	 * Test method for 
	 * {@link edu.gmu.ace.daggre.MarkovEngineImpl#addTrade(long, java.util.Date, long, long, long, java.util.List, java.util.List, java.util.List, java.util.List, java.lang.Boolean)},
	 * {@link MarkovEngineImpl#getCash(long, List, List)}, 
	 * {@link MarkovEngineImpl#getEditLimits(long, long, int, List, List)},
	 * {@link MarkovEngineImpl#getProbList(long, List, List)},
	 * {@link MarkovEngineImpl#getAssetsIfStates(long, long, List, List)}.
	 * The tested data is equivalent to the one in 
	 * https://docs.google.com/document/d/179XTjD5Edj8xDBvfrAP7aDtvgDJlXbSDQQR-TlM5stw/edit.
	 * <br/>
	 * The DEF net looks like the following.		<br/>
	 * Note: uniform distribution for all nodes.	<br/>
	 * D--->F										<br/>
	 * | 											<br/>
	 * V  											<br/>
	 * E											<br/>
	 * 
	 * The sequence is:<br/>
	 * <br/>
	 * There are two cliques {D, E}, and {D, F}, initial asset tables have q-value as 100 in every cell. <br/>
	 *	Current marginal probabilities are:	<br/>
	 *	Variables    D             E              F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.5 0.5]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Trade-1: Tom would like to make a bet on E=e1, that has current probability as 0.5. First of all, we need to calculate Tom’s edit limit (in this case, there is no assumption):	<br/> 
	 *	Given E=e1, min-q1 = 100	<br/>
	 *	Given E~=e1, min-q2 = 100	<br/>
	 *	From Equation (1), edit interval is [0.005, 0.995].	<br/> 
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55 (current)	<br/>
	 *	<br/>	
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.55 0.45]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Tom’s min-q is 90, at the following 4 min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     1     2     1	<br/>
	 *	     1     2     2	<br/>
	 *	     2     2     1	<br/>
	 *	     2     2     2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-2: Now Tom would like to make another conditional bet on E=e1 given D=d1 (current P(E=e1|D=d1) = 0.55). Again, let us calculate his edit limits first (in this case, we have assumed variable D=d1). And note that Tom’s asset tables are not the initial ones any more, but updated from last trade he did, now:	<br/> 
	 *	Given E=e1, and D=d1, min-q1 = 110	<br/>
	 *	Given E~=e1, and D=d1, min-q2 = 90	<br/>
	 *	From Equation (1), edit interval is [0.005, 0.995]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9 (current)	<br/>
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.725 0.275]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Tom’s min-q is 20, at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     1     2    1	<br/>
	 *	     1     2    2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-3: Joe came and intended to make a bet on E=e1 given D=d2 (current P(E=e1|D=d2) is 0.55). This will be his first edit, so he has initial asset tables before his trade.	<br/> 
	 *	Edit limit:	<br/>
	 *	Given E=e1, and D=d2, min-q1 = 100	<br/>
	 *	Given E~=e1, and D=d2, min-q2 = 100	<br/>
	 *	From Equation (1), edit interval is [0.0055, 0.9955]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4 (current)	<br/> 
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.65 0.35]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Joe’s min-q is 72.72727272727..., at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     1    1	<br/>
	 *	     2     1    2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-4: Now Amy is interested in changing P(F=f1|D=d1), which is currently 0.5. It will be her first edit, so she also has initial asset tables before the trade.	<br/> 
	 *	Edit limit:	<br/>
	 *	Given F=f1, and D=d1, min-q1 = 100	<br/>
	 *	Given F~=f1, and D=d1, min-q2 = 100	<br/>
 	 *	From Equation (1), edit interval is [0.005, 0.995]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3 (current)	<br/>
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.65 0.35]   [0.4 0.6]	<br/>
	 *	<br/>	
	 *	Amy’s min-q is 60, at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     1     1    1	<br/>
	 *	     1     2    1	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-5: Joe would like to trade again on P(F=f1|D=d2), which is currently 0.5.	<br/> 
	 *	Edit limit:	<br/>
	 *	Given F=f1, and D=d2, min-q1 = 72.727272727	<br/>
	 *	Given F~=f1, and D=d2, min-q2 = 72.727272727	<br/>
	 *	From Equation (1), edit interval is [0.006875, 0.993125]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.65 0.35]   [0.2 0.8]	<br/>
	 *	<br/>	
	 *	Joe’s min-q is 14.54545454546, at the following unique min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     1    1	<br/>
	 *	<br/>	
	 *	At this point, the model DEF reaches the status that has the same CPTs as the starting CPTs for the experimental model DEF we used in our AAAI 2012 paper.	<br/> 
	 *	<br/>	
	 *	From now on, we run test cases described in the paper.	<br/> 
	 *	<br/>	
	 *	Trade-6: Eric would like to trade on P(E=e1), which is currently 0.65.	<br/> 
	 *	To decide long or short, S(E=e1) = 10, S(E~=e1)=10, no difference because this will be Eric’s first trade.	<br/>
	 *	Edit limit:	<br/>
	 *	Given F=f1, and D=d2, min-q1 = 100	<br/>
	 *	Given F~=f1, and D=d2, min-q2 = 100	<br/>
	 *	From Equation (1), edit interval is [0.0065, 0.9965]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	Eric1:	P(E=e1) = 0.65 to 0.8 (current)	<br/>
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5824, 0.4176]   [0.8, 0.2]   [0.2165, 0.7835]	<br/>
	 *	<br/>	
	 *	Eric’s expected score is S=10.1177.	<br/>
	 *	Eric’s min-q is 57.142857, at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     2    1	<br/>
	 *	     2     2    2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-7: Eric would like to make another edit. This time, he is interested on changing P(D=d1|F=f2), which is currently 0.52.	<br/> 
	 *	To decide long or short, S(D=d1, F=f2) = 10.36915, S(D~=d1, F=f2)=9.7669.	<br/>
	 *	Edit limit:	<br/>
	 *	Given D=d1, and F=f2 , min-q1 = 57.142857	<br/>
	 *	Given D~=d1, and F=f2, min-q2 = 57.142857	<br/>
	 *	From Equation (1), edit interval is [0.0091059, 0.9916058]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	Eric1:	P(E=e1) = 0.65 to 0.8	<br/> 
	 *	Eric2:	P(D=d1|F=f2) = 0.52 to 0.7 (current)	<br/>
	 *	<br/>	  
	 *	Variables   D                            E                             F	<br/> 
	 *	Marginals   [0.7232, 0.2768]   [0.8509, 0.1491]   [0.2165, 0.7835]	<br/>
	 *	<br/>	
	 *	Eric’s expected score is now 10.31615.	<br/> 
	 *	Eric’s min-q is 35.7393, at the following unique min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     2    2	<br/>
	 *	<br/> 
	 *  The transaction is committed at each trade (trades are not committed at once).
	 */	
	public final void testAddTrade() {
		
		// crate transaction for generating the DEF network
		long transactionKey = engine.startNetworkActions();
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// commit changes
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			List<Float> newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, engine.getCash(userNameToIDMap.get("Tom"), null, null), ASSET_ERROR_MARGIN);
			assertEquals(1, engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		} 
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		}
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		
		// check whether probability prior to edit is really 0.5
		List<Float> probList = engine.getProbList(0x0E, null, null);
		assertEquals(2 , probList.size());
		assertEquals(0.5f , probList.get(0) , PROB_ERROR_MARGIN);
		assertEquals(0.5f , probList.get(1) , PROB_ERROR_MARGIN);
		
		// edit interval of P(E=e1) should be [0.005, 0.995]
		List<Float> editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, null, null);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.005f, editInterval.get(0), PROB_ERROR_MARGIN );
			assertEquals(0.995f, editInterval.get(1), PROB_ERROR_MARGIN );
		}
		
		// obtain conditional probabilities and assets of the edited clique, prior to edit, so that we can use it to check assets after edit
		List<Float> cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		List<Float> cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// check that no one has made any trade on any question yet.
		for (String user : userNameToIDMap.keySet()) {
			assertEquals(user, 0, engine.getTradedQuestions(userNameToIDMap.get(user)).size());
		}
		
		// do edit
		transactionKey = engine.startNetworkActions();
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			).size());
		engine.commitNetworkActions(transactionKey);
		
		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(1, engine.getTradedQuestions(userNameToIDMap.get("Tom")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0El));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		List<Float> cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		List<Float> cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		
		// check that new marginal of E is [0.55 0.45], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.55f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.45f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that Tom's min-q is 90 (and the cash is supposedly the log value of 90)
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);	 // null means unconditional cash, which is supposedly the global minimum
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(90f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(90f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 and any values for D and F, by asserting that cash conditioned to such states are equals to the min
		// d, e, f are always going to be the assumption nodes in this test
		List<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check minimal condition of LPE: e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(1));
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(0));
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.55, .45, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.55f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
		assertEquals(0.45f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
		assertEquals(0.55f , probList.get(2),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
		assertEquals(0.45f , probList.get(3),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(E=e1|D=d1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, assumptionIds, assumedStates);	// (node == 0x0E && state == 0) == e1
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, prior to edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}

		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		engine.commitNetworkActions(transactionKey);
		
		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(1, engine.getTradedQuestions(userNameToIDMap.get("Tom")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0El));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.725 0.275] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.725f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.275f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d1, e2 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check minimal condition of LPE: d1, e2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// TODO assert getAssetsIf

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
		}

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.9, .1, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.9f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
		assertEquals(0.1f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
		assertEquals(0.55f , probList.get(2),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
		assertEquals(0.45f , probList.get(3),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(E=e1|D=d2) should be [0.0055, 0.9955]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0E, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0055f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9955f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(E=e1|D=d2) = 0.4 and P(E=e2|D=d2) = 0.6
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(1, engine.getTradedQuestions(userNameToIDMap.get("Joe")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Joe")).contains(0x0El));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.65 0.35] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 72.727272...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(72.727272f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(72.727272f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d2, e1 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check minimal condition of LPE: d2, e1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1);
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// TODO assert getAssetsIf
		
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
		}

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.5, .5, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		probList = engine.getProbList(0x0F, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(F=f1|D=d1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0F, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(F=f1|D=d1) = 0.3 and P(F=f2|D=d1) = 0.7  
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(1, engine.getTradedQuestions(userNameToIDMap.get("Amy")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Amy")).contains(0x0Fl));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.4 .6], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.4f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.6f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d1, f1 and any value E
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check minimal condition of LPE: d1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0F);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0F);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// TODO assert getAssetsIf
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.3, .7, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		probList = engine.getProbList(0x0F, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.3f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.7f , probList.get(1),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(F=f1|D=d2) should be [0.006875, 0.993125]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0F, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.006875f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.993125, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(F=f1|D=d2) = 0.1 and P(F=f2|D=d2) = 0.9
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		engine.commitNetworkActions(transactionKey);

		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Joe")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Joe")).contains(0x0El));
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Joe")).contains(0x0Fl));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.2 .8], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.8f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check probabilities given assumptions outside the same clique
		probList = engine.getProbList(0x0E, Collections.singletonList((long)0x0F), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0.775f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.225f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, Collections.singletonList((long)0x0F), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0.6188f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.3813f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, Collections.singletonList((long)0x0E), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0.2385f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7615f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, Collections.singletonList((long)0x0E), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0.1286f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.8714f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d2, e1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// TODO assert getAssetsIf
		
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
		}

		
		// Eric bets P(E=e1) = .65 -> .8
		
		// check whether probability prior to edit is really = [.65, .35]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(2, probList.size());
		assertEquals(0.65f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.35f , probList.get(1),PROB_ERROR_MARGIN );
		
		
		// edit interval of P(E=e1) should be [0.0065, 0.9965]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0E, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0065f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9965f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(E=e1) = 0.8 and P(E=e2) = 0.2
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(1, engine.getTradedQuestions(userNameToIDMap.get("Eric")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0El));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(10.1177, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.8 0.2] (this is expected value), F is [0.2165, 0.7835], and D is [0.5824, 0.4176]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5824f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.4176f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 57.142857...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(57.142857f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(57.142857f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 and any D or F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		
		// check whether probability prior to edit is really [d1f2, d2f2] = [.52, .48]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		probList = engine.getProbList(0x0D, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.52f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.48f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(1);	// set f2 as assumed state
		
		// edit interval of P(D=d1|F=f2) should be [0.0091059, 0.9916058]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(D=d1|F=f2) = 0.7 and P(D=d2|F=f2) = 0.3
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
		).size());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Eric")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0Dl));
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0El));
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}

		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(10.31615, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// check that min-q is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE is d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		

		// Eric makes a bet which makes his assets-q to go below 1, but the algorithm does not allow it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// get history before transaction, so that we can make sure new transaction is not added into history
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		List<Float> tradeReturn = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false	// do not allow negative assets
			);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertNull(tradeReturn);
		} else {
			// do not test scenarios after this, because they all test conditions when trade was out of limit (which will not occur when engine.isToAddArcsOnlyToProbabilisticNetwork == true)
			return;
		}
		
		// this is supposedly going to commit empty transaction
		engine.commitNetworkActions(transactionKey);
		// make sure history was not changed
		assertEquals(questionHistory, engine.getQuestionHistory(0x0DL, null, null));
		

		// check that the questions that can be retrieved from getTradedQuestions are still the same.
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Eric")).size());
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0Dl));
			assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0El));
		}

		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "OK", Long.MIN_VALUE, (long)0x0D, newValues, null, null, false);
			fail("It's not be supposed to reuse a commited transaction.");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			// check that assets and conditional probs did not change
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals( "Index = " + i, cliqueAssetsBeforeTrade.get(i), cliqueAssetsAfterTrade.get(i), ASSET_ERROR_MARGIN );
				assertEquals( "Index = " + i, cliqueProbsBeforeTrade.get(i), cliqueProbsAfterTrade.get(i), PROB_ERROR_MARGIN );
			}
		}
		
		
		// check that marginals have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// check that min-q has not changed
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE has not changed - still d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		

		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// add question disconnected question C
		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), (long)0x0C, 2, null);
		engine.commitNetworkActions(transactionKey);
		

		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// check that probabilities and assets related to old node did not change
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
		
		// Amy bets P(C=c1) = .5 -> .05
		
		// check whether probability of C prior to edit is really [.5, .5] no matter what combination of other nodes
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds = new ArrayList<Long>(3);	assumedStates = new ArrayList<Integer>(3);
		assumptionIds.add((long)0x0D);	assumptionIds.add((long)0x0E);
		assumedStates.add((Math.random() < .5)?1:0); assumedStates.add((Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds.set(0, (long)0x0D);	assumptionIds.set(1, (long)0x0F);
		assumedStates.set(0, (Math.random() < .5)?1:0); assumedStates.set(1, (Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds.set(0, (long)0x0E);	assumptionIds.set(1, (long)0x0F);
		assumedStates.set(0, (Math.random() < .5)?1:0); assumedStates.set(1, (Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds.set(0, (long)0x0E);	assumptionIds.set(1, (long)0x0F); assumptionIds.add((long)0x0D); 
		assumedStates.set(0, (Math.random() < .5)?1:0); assumedStates.set(1, (Math.random() < .5)?1:0); assumedStates.add((Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		
		// edit interval of P(C=c1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0C, 0, null, null);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0083f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916667f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// set P(C=c1) = 0.05 and   P(C=c1) = 0.95
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.05f);
		newValues.add(.95f);
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(C=c1) = 0.05", 
				userNameToIDMap.get("Amy"), 
				0x0C, 
				newValues, 
				null, 
				null, 
				false
			).size());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Amy")).size());
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Amy")).contains(0x0Fl));
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Amy")).contains(0x0Cl));
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// check assets
		List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0C, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals( 10,  engine.getQValuesFromScore(assetsIfStates.get(0)), ASSET_ERROR_MARGIN );
		assertEquals( 190,  engine.getQValuesFromScore(assetsIfStates.get(1)), ASSET_ERROR_MARGIN );
		
		// check that marginals of C is [.05,.95], and others have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(0.05f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.95f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 6...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(6f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(6f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that new LPE of Amy is independent of E
		assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(0)), ASSET_ERROR_MARGIN);
		assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(1)), ASSET_ERROR_MARGIN);
		
		// check that LPE is d1 c1 f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0C);		// 2nd node is C; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, c1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// c1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, c1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, c2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, c2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, c1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check incomplete condition of LPE: c1
		cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(0));
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(1));
		assertTrue("Obtained cash = " + cash, minCash < cash);
		

		// Eric makes a bet which makes his assets-q to go below 1, and the algorithm allows it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		assertEquals(2, engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				true	// allow negative assets
			).size());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Eric")).size());
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0El));
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Eric")).contains(0x0Dl));
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that cash is smaller or equal to 0
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertTrue("Obtained unexpected cash = " + minCash, minCash <= 0);
	
		Map<Long, List<Float>> probListsBeforeTrade = engine.getProbLists(null, null, null);
		
		// test the case in which the trade will make the assets to go negative, but it cannot be previewed (it will throw exception only on commit)
		transactionKey = engine.startNetworkActions();
		
		// add a new question in the same transaction, so that we guarantee that trade cannot be previewed
		List<Float> initProbs = new ArrayList<Float>();
		initProbs.add(.9f); initProbs.add(.0999f); initProbs.add(.0001f);
		engine.addQuestion(transactionKey, new Date(), 0x0AL, 3, initProbs);
		
		// add a trade which will make user asset to go below zero and cannot be previewed
		newValues = new ArrayList<Float>();
		newValues.add(.0001f); newValues.add(.0999f);  newValues.add(.9f); 
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(A = [.0001, .0999, .9])", 
				userNameToIDMap.get("Amy"), 
				0x0AL, 
				newValues, 
				null, 
				null, 
				false
			).isEmpty());
		try {
			engine.commitNetworkActions(transactionKey);
			fail("This is expected to throw ZeroAssetsException");
		} catch (ZeroAssetsException e) {
			assertNotNull(e);
		}
		

		// check that the question can be retrieved from getTradedQuestions.
		assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Amy")).size());
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Amy")).contains(0x0Fl));
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Amy")).contains(0x0Cl));
		
		// probability of nodes present before this transaction must remain unchanged
		Map<Long, List<Float>> probListsAfterTrade = engine.getProbLists(null, null, null);
		for (Long id : probListsBeforeTrade.keySet()) {
			assertEquals("question = " + id , probListsBeforeTrade.get(id).size(), probListsAfterTrade.get(id).size());
			for (int i = 0; i < probListsBeforeTrade.get(id).size(); i++) {
				assertEquals("Question = " + id , probListsBeforeTrade.get(id).get(i), probListsAfterTrade.get(id).get(i), PROB_ERROR_MARGIN);
			}
		}
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Tom contains d1, e2 and any value F
		assumedStates = new ArrayList<Integer>();
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0DL); assumptionIds.add(0x0EL); assumptionIds.add(0x0FL); 
		
		// check combination d1, e1, f1 (not min)
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		try {
			List<Long> questionIds = new ArrayList<Long>();
			questionIds.add(13L); questionIds.add(14L); questionIds.add(15L); 
			questionIds.add(12L); questionIds.add(10L);
			List<Integer> states = new ArrayList<Integer>();
			states.add(0); states.add(0); states.add(0); 
			states.add(0); states.add(0);
			for (int i = 0; i < 32; i++) {
				states.set(0, i%2); states.set(1,(i/2)%2); states.set(2,(i/4)%2); 
				states.set(3,(i/16)%2); states.set(4,(i/32)%2);
//				System.out.println(engine.getJointProbability(questionIds, states));
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		// test invalid assumptions
		transactionKey = engine.startNetworkActions();
		
		// add a in which the assumptions will be ignored
		newValues = new ArrayList<Float>();
		newValues.add(.5f); newValues.add(.5f); 
		assertFalse( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(F|E = e2) = [.5,.5]", 
				userNameToIDMap.get("Tom"), 
				0x0FL, 
				newValues, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		assertEquals(2, engine.getTradedQuestions(userNameToIDMap.get("Tom")).size());
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0El));
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0Fl));
		
		// check that marginal of F is [.5,.5] (i.e. condition E was ignored)
		probList = engine.getProbList(0x0FL, null, null);
		assertEquals(2, probList.size());
		assertEquals(.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that in the history, the assumption E was ignored
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertNotNull(questionHistory);
		assertFalse(questionHistory.isEmpty());
		AddTradeNetworkAction action = (AddTradeNetworkAction) questionHistory.get(questionHistory.size()-1);
		assertEquals((long)0x0F, (long)action.getQuestionId());
		assertTrue("Assumptions = " + action.getTradeId(), action.getAssumptionIds().isEmpty());
		
		List<Float> editLimits = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0DL, 0, null, null);
		assertEquals(2, editLimits.size());
		assertTrue(editLimits.toString() , editLimits.get(0) > 0);
		assertTrue(editLimits.toString() , editLimits.get(0) < 1);
		assertTrue(editLimits.toString() , editLimits.get(1) > 0);
		assertTrue(editLimits.toString() , editLimits.get(1) < 1);
		assertTrue(editLimits.toString() , editLimits.get(0) < 0.5 && 0.5 < editLimits.get(1));
	
		// test disconnected assumptions
		transactionKey = engine.startNetworkActions();
		
		// add a in which the assumptions will be ignored
		newValues = new ArrayList<Float>();
		newValues.add(.5f); newValues.add(.5f); 
		assertFalse( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(D|A = a1) = [.5,.5]", 
				userNameToIDMap.get("Tom"), 
				0x0DL, 
				newValues, 
				Collections.singletonList(0x0AL), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		engine.commitNetworkActions(transactionKey);
		

		// check that the question can be retrieved from getTradedQuestions.
		assertEquals(3, engine.getTradedQuestions(userNameToIDMap.get("Tom")).size());
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0Dl));
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0El));
		assertTrue(engine.getTradedQuestions(userNameToIDMap.get("Tom")).contains(0x0Fl));
		
		// check that marginal of D is [.5,.5] (i.e. condition A was ignored)
		probList = engine.getProbList(0x0DL, null, null);
		assertEquals(2, probList.size());
		assertEquals(.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that in the history, the assumption A was ignored
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertNotNull(questionHistory);
		assertFalse(questionHistory.isEmpty());
		action = (AddTradeNetworkAction) questionHistory.get(questionHistory.size()-1);
		assertEquals((long)0x0D, (long)action.getQuestionId());
		assertTrue("Assumptions = " + action.getTradeId(), action.getAssumptionIds().isEmpty());
		
		assertNotNull(engine.getScoreSummaryObject(userNameToIDMap.get("Tom"), null, null, null));
		if (engine.isToRetriveOnlyTradeHistory()) {
			assertTrue(engine.getQuestionHistory(null, null, null).isEmpty());
		} else {
			assertFalse(engine.getQuestionHistory(null, null, null).isEmpty());
		}
		assertFalse(engine.previewBalancingTrade(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(Float.isNaN(engine.getCash(userNameToIDMap.get("Tom"), null, null)));
		assertNotNull(engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0AL, 2, null, null));
		assertEquals(0,engine.getMaximumValidAssumptionsSublists(0x0AL, null, 1).get(0).size());
		assertTrue(engine.getPossibleQuestionAssumptions(0x0A, null).isEmpty());
		assertNotNull(engine.getScoreDetails(userNameToIDMap.get("Tom"), 0x0AL, null, null));
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		
	}
	
	

	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#addTrade(long, Date, String, long, long, List, List, List, boolean)}.
	 * This method performs the same test of {@link #testAddTrade()},
	 * but it executes everything in a single transaction.
	 */
	public final void testAddTradeInOneTransaction () {
		
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Tom"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			// OK. This is the expected
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			).isEmpty());
		
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Joe"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			// OK. This is the expected
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Amy"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			// OK. This is the expected
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Eric"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			// OK. This is the expected
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			).isEmpty());
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// make sure users were not created
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue(engine.getUserToAssetAwareAlgorithmMap().isEmpty());
		}
		
		// check that we can retrieve out-of-clique probs and expected scores
		List<Float> floatList = engine.getProbList(0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertNotNull(floatList);
		assertEquals(2, floatList.size());
		
		floatList = engine.scoreUserQuestionEvStates(userNameToIDMap.get("Eric"),0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertNotNull(floatList);
			assertEquals(2, floatList.size());
		}
		
		floatList = engine.getCashPerStates(userNameToIDMap.get("Eric"),0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertNotNull(floatList);
			assertEquals(2, floatList.size());
		}
		
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		floatList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, floatList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, floatList.get(1), PROB_ERROR_MARGIN);
		floatList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, floatList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, floatList.get(1), PROB_ERROR_MARGIN);
		floatList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, floatList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, floatList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
	}
	
	/**
	 * This will do {@link #testAddTradeInOneTransaction()},
	 * but will include the trades in reverse order (but the
	 * {@link NetworkAction#getWhenCreated()} is in correct order).
	 * This method tests whether the {@link MarkovEngineImpl}
	 */
	public final void testAddTradeInOneTransactionReverseOrder () {
		
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// variable to retain probabilities to set.
		List<Float> newValues = null;
		
		// Let's create a mapping from user names to user IDs
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		userNameToIDMap.put("Joe", (long) 1);
		userNameToIDMap.put("Amy", (long) 2);
		userNameToIDMap.put("Eric", (long) 3);
		
		// create edge D->F
		engine.addQuestion(transactionKey, new Date(3), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(1), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestionAssumption(transactionKey, new Date(5), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->E 
		engine.addQuestion(transactionKey, new Date(2), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestionAssumption(transactionKey, new Date(4), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(16), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
			).isEmpty()
		);
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(15), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
				).isEmpty());
		
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(14), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(13), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
				).isEmpty());
		
		
		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(12), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty()
		);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(11), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(10), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty()
		);
				
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(9), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(8), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(7), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			).isEmpty());
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(6), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
//		assertTrue(engine.addCash(transactionKey, new Date(3), 999L, engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		newValues = new ArrayList<Float>(2);
		newValues.add(0.9f);		
		newValues.add(0.1f);		
		engine.addTrade(transactionKey, new Date(2), "Trade to revert", 999L, 0x0EL, newValues, null, null, true);
		try {
			engine.doBalanceTrade(transactionKey, new Date(3), "Undo the last trade", 999L, 0x0EL, null, null);
			if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Should not allow balance operation when assets are not used.");
			}
		} catch(UnsupportedOperationException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		List<Float> probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
	}
	
	

	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#addTrade(long, Date, String, long, long, List, List, List, boolean)}.
	 * This method performs the same test of {@link #testAddTradeInOneTransaction()},
	 * but q-values are set to a very high values.
	 * but it executes everything in a single transaction.
	 */
	public final void testAddTradeInOneTransactionWithHighAssets () {
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		
		double initialQ = engine.getQValuesFromScore(5000.0f);
		if (engine.getDefaultInferenceAlgorithm().isToUseQValues()) {
			engine.setDefaultInitialAssetTableValue((float) initialQ);
		} else {
			// we are not using q-values anymore
			engine.setDefaultInitialAssetTableValue(engine.getScoreFromQValues(initialQ));
		}
		
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			).isEmpty());
		
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			).isEmpty());
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		List<Float> probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20*initialQ/100)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20*initialQ/100, engine.getQValuesFromScore(minCash), ASSET_ERROR_MARGIN*initialQ/100);
		}
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60*initialQ/100)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60*initialQ/100, engine.getQValuesFromScore(minCash), ASSET_ERROR_MARGIN*initialQ/100);
		}
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545*initialQ/100)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545*initialQ/100, engine.getQValuesFromScore(minCash), ASSET_ERROR_MARGIN*initialQ/100);
		}
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(engine.getScoreFromQValues(35.7393*initialQ/100), minCash, ASSET_ERROR_MARGIN);
			assertEquals(35.7393*initialQ/100, engine.getQValuesFromScore(minCash), ASSET_ERROR_MARGIN*initialQ/100);
		}
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
	}
	
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#addTrade(long, Date, String, long, long, List, List, List, boolean)},
	 * {@link MarkovEngineImpl#addQuestion(long, Date, long, int, List)},
	 * {@link MarkovEngineImpl#addQuestionAssumption(long, Date, long, List, List)}.
	 * This method performs the trades in {@link #testAddTrade()}, but it creates nodes and edges
	 * after some trade was performed.
	 */
	public final void testAddQuestionAfterTrade() {
		
		List<List<Long>> questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		assertTrue(questionAssumptionGroups.toString(), questionAssumptionGroups.isEmpty());
		
		// generate node E
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.commitNetworkActions(transactionKey);
		
		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.size());
		
		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		}
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		
		// check whether probability prior to edit is really 0.5
		List<Float> probList = engine.getProbList(0x0E, null, null);
		assertEquals(2 , probList.size());
		assertEquals(0.5f , probList.get(0) , PROB_ERROR_MARGIN);
		assertEquals(0.5f , probList.get(1) , PROB_ERROR_MARGIN);
		
		// edit interval of P(E=e1) should be [0.005, 0.995]
		List<Float> editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, null, null);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.005f, editInterval.get(0), PROB_ERROR_MARGIN );
			assertEquals(0.995f, editInterval.get(1), PROB_ERROR_MARGIN );
		}
		
		// obtain conditional probabilities and assets of the edited clique, prior to edit, so that we can use it to check assets after edit
		List<Float> cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, null, null, false);
		List<Float> cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, null, null);
		assertEquals(2, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(2, cliqueAssetsBeforeTrade.size());
		}
		
		// do edit
		transactionKey = engine.startNetworkActions();
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		List<Float> cliqueProbsAfterTrade = engine.getProbList((long)0x0E, null, null, false);
		List<Float> cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E,null, null);
		assertEquals(2, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(2, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.55 0.45], and the others have not changed (remains 50%)
		try {
			engine.getProbList(0x0D, null, null);
			fail("Node was not created yet.");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);	// this is supposed to happen
		}
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.55f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.45f, probList.get(1), PROB_ERROR_MARGIN);
		try {
			engine.getProbList(0x0F, null, null);
			fail("Node was not created yet.");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);	// this is supposed to happen
		}
		
		// check that Tom's min-q is 90 (and the cash is supposedly the log value of 90)
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);	 // null means unconditional cash, which is supposedly the global minimum
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(90f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(90f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 
		// all nodes are always going to be the assumption nodes in this test
		List<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0E);
		
		// check e1
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// e1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check e2
		assumedStates.set(0, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);


		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.size());
		assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.get(0).size());
		
		// create node D and edge D->E
		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		engine.commitNetworkActions(transactionKey);

		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			if (engine.isToAddArcsWithoutReboot()) {
				assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.size());
			} else {
				assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.size());
			}
		} else {
			assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.size());
		}
		assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.get(0).size());
		
		// check that probs and assets did not change
		
		// check that marginal of E is [0.55 0.45], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.55f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.45f, probList.get(1), PROB_ERROR_MARGIN);
		try {
			engine.getProbList(0x0F, null, null);
			fail("Node does not exist");
		} catch (IllegalArgumentException e) {
			assertNotNull(e); // this is supposed to happen
		}
		
		// check that Tom's min-q is 90 (and the cash is supposedly the log value of 90)
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);	 // null means unconditional cash, which is supposedly the global minimum
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(90f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(90f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 and any values for D, by asserting that cash conditioned to such states are equals to the min
		// d, e are always going to be the assumption nodes in this test
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		
		// check combination d1, e1 (not min)
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check minimal condition of LPE: e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(1));
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(0));
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.55, .45, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.55f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
		assertEquals(0.45f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
		assertEquals(0.55f , probList.get(2),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
		assertEquals(0.45f , probList.get(3),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(E=e1|D=d1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, assumptionIds, assumedStates);	// (node == 0x0E && state == 0) == e1
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, prior to edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}

		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.725 0.275] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.725f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.275f, probList.get(1), PROB_ERROR_MARGIN);
		try {
			engine.getProbList(0x0F, null, null);
			fail("Node was not created yet");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);	// this is expected
		}
		
		// check that min-q is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d1, e2 
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		
		// check combination d1, e1 (not min)
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
		}

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.9, .1, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.9f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
		assertEquals(0.1f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
		assertEquals(0.55f , probList.get(2),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
		assertEquals(0.45f , probList.get(3),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(E=e1|D=d2) should be [0.0055, 0.9955]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0E, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0055f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9955f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(E=e1|D=d2) = 0.4 and P(E=e2|D=d2) = 0.6
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.65 0.35] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		try {
			engine.getProbList(0x0F, null, null);
			fail();
		} catch (Exception e) {
			assertNotNull(e);
		}
		
		// check that min-q is 72.727272...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(72.727272f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(72.727272f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d2, e1 
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		
		// check combination d1, e1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}


		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			if (engine.isToAddArcsWithoutReboot()) {
				assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.size());
			} else {
				assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.size());
			}
		} else {
			assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.size());
		}
		assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.get(0).size());
		
		// create node F and edge D->F
		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		engine.commitNetworkActions(transactionKey);
		

		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			if (engine.isToAddArcsWithoutReboot()) {
				assertEquals(questionAssumptionGroups.toString(), 3, questionAssumptionGroups.size());
				assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.get(0).size());
				assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.get(1).size());
				assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.get(2).size());
			} else {
				assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.size());
				for (List<Long> group : questionAssumptionGroups) {
					assertEquals(questionAssumptionGroups.toString(), 2, group.size());
				}
			}
		} else {
			assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.size());
			for (List<Long> group : questionAssumptionGroups) {
				assertEquals(questionAssumptionGroups.toString(), 2, group.size());
			}
		}
		
		// check that probs and assets did not change
		
		// check that marginal of E is still [0.65 0.35] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q of Joe is 72.727272...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(72.727272f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(72.727272f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Joe contains d2, e1 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check minimal condition of LPE: d2, e1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1);
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check that min-q of Tom is still 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Tom still contains d1, e2 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check minimal condition of LPE: d1, e2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
		}

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.5, .5, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		probList = engine.getProbList(0x0F, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(F=f1|D=d1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0F, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(F=f1|D=d1) = 0.3 and P(F=f2|D=d1) = 0.7  
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.4 .6], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.4f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.6f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d1, f1 and any value E
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check minimal condition of LPE: d1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0F);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0F);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// TODO assert getAssetsIf
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.3, .7, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		probList = engine.getProbList(0x0F, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.3f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.7f , probList.get(1),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(F=f1|D=d2) should be [0.006875, 0.993125]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0F, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.006875f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.993125, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(F=f1|D=d2) = 0.1 and P(F=f2|D=d2) = 0.9
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.2 .8], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.8f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d2, e1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// TODO assert getAssetsIf
		
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
		}

		
		// Eric bets P(E=e1) = .65 -> .8
		
		// check whether probability prior to edit is really = [.65, .35]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(2, probList.size());
		assertEquals(0.65f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.35f , probList.get(1),PROB_ERROR_MARGIN );
		
		
		// edit interval of P(E=e1) should be [0.0065, 0.9965]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0E, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0065f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9965f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(E=e1) = 0.8 and P(E=e2) = 0.2
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.8 0.2] (this is expected value), F is [0.2165, 0.7835], and D is [0.5824, 0.4176]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5824f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.4176f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 57.142857...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(57.142857f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(57.142857f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 and any D or F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		
		// check whether probability prior to edit is really [d1f2, d2f2] = [.52, .48]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		probList = engine.getProbList(0x0D, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.52f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.48f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(1);	// set f2 as assumed state
		
		// edit interval of P(D=d1|F=f2) should be [0.0091059, 0.9916058]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// set P(D=d1|F=f2) = 0.7 and P(D=d2|F=f2) = 0.3
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
		);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsAfterTrade.size());
			for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
				assertEquals(
						"Index = " + i, 
						cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
						engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
						ASSET_ERROR_MARGIN
						);
			}
		}
		
		// check that new marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// check that min-q is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE is d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		

		// Eric makes a bet which makes his assets-q to go below 1, but the algorithm does not allow it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(4, cliqueAssetsBeforeTrade.size());
		}
		
		// get history before transaction, so that we can make sure new transaction is not added into history
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		List<Float> tradeReturn = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false	// do not allow negative assets
				);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertNull( tradeReturn );
		}
		// this is supposedly going to commit empty transaction
		engine.commitNetworkActions(transactionKey);
		// make sure history was not changed
		assertEquals(questionHistory, engine.getQuestionHistory(0x0DL, null, null));
		
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			// do not test anymore, because the following tests are for when user provided a trade outside the bound (which does not exist when isToAddArcsOnlyToProbabilisticNetwork == true)
			return;
		}
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		// check that assets and conditional probs did not change
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals( "Index = " + i, cliqueAssetsBeforeTrade.get(i), cliqueAssetsAfterTrade.get(i), ASSET_ERROR_MARGIN );
			assertEquals( "Index = " + i, cliqueProbsBeforeTrade.get(i), cliqueProbsAfterTrade.get(i), PROB_ERROR_MARGIN );
		}
		
		
		// check that marginals have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// check that min-q has not changed
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE has not changed - still d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
		
		// Eric makes a bet which makes his assets-q to go below 1, and the algorithm allows it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				true	// allow negative assets
			);
		engine.commitNetworkActions(transactionKey);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that cash is smaller or equal to 0
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertTrue("Obtained unexpected cash = " + minCash, minCash <= 0);
		
		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		if (engine.isToAddArcsWithoutReboot()) {
			assertEquals(questionAssumptionGroups.toString(), 3, questionAssumptionGroups.size());
			assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.get(0).size());
			assertEquals(questionAssumptionGroups.toString(), 1, questionAssumptionGroups.get(1).size());
			assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.get(2).size());
		} else {
			assertEquals(questionAssumptionGroups.toString(), 2, questionAssumptionGroups.size());
			for (List<Long> group : questionAssumptionGroups) {
				assertEquals(questionAssumptionGroups.toString(), 2, group.size());
			}
		}
		
	}
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#addTrade(long, Date, String, long, long, List, List, List, boolean)},
	 * {@link MarkovEngineImpl#addQuestion(long, Date, long, int, List)},
	 * {@link MarkovEngineImpl#addQuestionAssumption(long, Date, long, List, List)}.
	 * This method performs the same test of {@link #testAddQuestionAfterTrade()},
	 * but it executes everything in a single transaction.
	 */
	public final void testAddQuestionAfterTradeInOneTransaction() {
		
		List<List<Long>> questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		assertEquals(questionAssumptionGroups.toString(), 0, questionAssumptionGroups.size());
		
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro

		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Tom"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			// OK. This is the expected
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			);
		
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			);
		

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Joe"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			);
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Amy"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			} else {
				throw e;
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// create node F and  edge D->F
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			);
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			);
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Eric"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			}else {
				throw e;
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			);
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
		);
		
		// if true, the quantity of cliques has changed
		
		// add new node C and random edge from or to C
		engine.addQuestion(transactionKey, new Date(), 0x0C, 2, null);
		if (Math.random() < .5) {
			// edge from C
			if (Math.random() < .5) {
//				System.out.println("Edge C->D");
				engine.addQuestionAssumption(transactionKey, new Date(), 0x0D, Collections.singletonList((long)0x0C), null);
			}
			if (Math.random() < .5) {
//				System.out.println("Edge C->E");
				engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long)0x0C), null);
			}
			if (Math.random() < .5) {
//				System.out.println("Edge C->F");
				engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long)0x0C), null);
			}
		} else {
			// edge to C
			List<Long> parentQuestionIds = new ArrayList<Long>();
			if (Math.random() < .5) {
				parentQuestionIds.add((long)0x0D);
			}
			if (Math.random() < .5) {
				parentQuestionIds.add((long)0x0E);
			}
			if (Math.random() < .5) {
				parentQuestionIds.add((long)0x0F);
			}
//			System.out.println("Edge " + parentQuestionIds + " -> C");
			engine.addQuestionAssumption(transactionKey, new Date(), 0x0C, parentQuestionIds, null);
		}
//		List<Long> parentQuestionIds = new ArrayList<Long>();
//		parentQuestionIds.add(0x0EL); parentQuestionIds.add(0x0FL);
//		engine.addQuestionAssumption(transactionKey, new Date(), 0x0C, parentQuestionIds, null);
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		assertTrue(questionAssumptionGroups.toString(), questionAssumptionGroups.size() >= 1);
		
		// check that final marginal of C is [.5,.5], E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		Map<Long,List<Float>> probsList = engine.getProbLists(null, null, null);
		assertEquals(0.5f, probsList.get(0x0CL).get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probsList.get(0x0CL).get(1), PROB_ERROR_MARGIN);
		assertEquals(0.7232f, probsList.get(0x0DL).get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probsList.get(0x0DL).get(1), PROB_ERROR_MARGIN);
		assertEquals(0.8509f, probsList.get(0x0EL).get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probsList.get(0x0EL).get(1), PROB_ERROR_MARGIN);
		assertEquals(0.2165f, probsList.get(0x0FL).get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probsList.get(0x0FL).get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			if (Float.isNaN(cash)) {
				for (Node node : engine.getProbabilisticNetwork().getNodes()) {
					System.out.println(node.getParents() + "->" + node);
				}
				fail();
			}
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
	}
	
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#getPossibleQuestionAssumptions(long, java.util.List)}
	 * and {@link edu.gmu.ace.daggre.MarkovEngineImpl#getQuestionAssumptionGroups()}.
	 */
	public final void testGetPossibleQuestionAssumptionsAndGetQuestionAssumptionGroups() {
		
		// Case 0: no network
		
		do {
			try {
				engine.getPossibleQuestionAssumptions((long)(Math.random()*Integer.MAX_VALUE), ((Math.random()<.5)?null:((List)Collections.emptyList())));
				fail("It is impossible to obtain questions from a Bayes Net which was not created yet...");
			}catch (IllegalArgumentException e) {
				// OK. 
				assertNotNull(e);
			}
		} while (Math.random() < .5);
		
		assertTrue(engine.getQuestionAssumptionGroups().isEmpty());
		
		// Case 1: 0
		
		engine.initialize();
		long transactionKey = engine.startNetworkActions();
		// create question 0
		engine.addQuestion(transactionKey, new Date(), 0, (int)(2+(Math.random()*3)), null);
		engine.commitNetworkActions(transactionKey);
		do {
			try {
				engine.getPossibleQuestionAssumptions((long)(1 + Math.random()*Integer.MAX_VALUE), ((Math.random()<.5)?null:((List)Collections.emptyList())));
				fail("Only question 0 is present");
			}catch (IllegalArgumentException e) {
				assertNotNull(e); // OK. 
			}
		} while (Math.random() < .5);
		try {
			engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)0));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		List<Long> assumptions = engine.getPossibleQuestionAssumptions(0, null);
		assertTrue("There is only 1 question in the network...",assumptions.isEmpty());
		assumptions = engine.getPossibleQuestionAssumptions(0, (List)Collections.emptyList());
		assertTrue("There is only 1 question in the network...",assumptions.isEmpty());
		

		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		assertEquals(1, engine.getQuestionAssumptionGroups().size());
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(0L));
		
		// Case 2: 1->0
		
		engine.initialize();
		transactionKey = engine.startNetworkActions();
		// create questions 0,1
		engine.addQuestion(transactionKey, new Date(), 0, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 1, (int)(2+(Math.random()*3)), null);
		// create edge 1->0 
		engine.addQuestionAssumption(transactionKey, new Date(), 0, Collections.singletonList((long)1), null);
		engine.commitNetworkActions(transactionKey);
		do {
			try {
				engine.getPossibleQuestionAssumptions((long)(Math.random()*Integer.MIN_VALUE), ((Math.random()<.5)?null:((List)Collections.emptyList())));
				fail("These questions are not present");
			}catch (IllegalArgumentException e) {
				assertNotNull(e); // OK. 
			}
		} while (Math.random() < .5);
		try {
			engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)0));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)1));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		assumptions = engine.getPossibleQuestionAssumptions(0, null);
		assertEquals(1, assumptions.size());
		assertEquals(1,assumptions.get(0).longValue());
		assumptions = engine.getPossibleQuestionAssumptions(0, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertEquals(1,assumptions.get(0).longValue());
		assumptions = engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)1));
		assertEquals(1, assumptions.size());
		assertEquals(1,assumptions.get(0).longValue());
		assumptions = engine.getPossibleQuestionAssumptions(1, null);
		assertEquals(1, assumptions.size());
		assertEquals(0,assumptions.get(0).longValue());
		assumptions = engine.getPossibleQuestionAssumptions(1, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertEquals(0,assumptions.get(0).longValue());
		assumptions = engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)0));
		assertEquals(1, assumptions.size());
		assertEquals(0,assumptions.get(0).longValue());
		
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		assertEquals(1, engine.getQuestionAssumptionGroups().size());
		assertEquals(2, engine.getQuestionAssumptionGroups().get(0).size());
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(0L));
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(1L));
		
		// Case 3: 1->0<-2
		engine.initialize();
		transactionKey = engine.startNetworkActions();
		// create questions 0,1,2
		engine.addQuestion(transactionKey, new Date(), 0, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 1, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 2, (int)(2+(Math.random()*3)), null);
		// create edges 1->0 and 2->0
		ArrayList<Long> parentQuestionIds = new ArrayList<Long>(2);
		parentQuestionIds.add((long)1); parentQuestionIds.add((long)2);
		engine.addQuestionAssumption(transactionKey, new Date(), 0, parentQuestionIds, null);
		engine.commitNetworkActions(transactionKey);
		try {
			// assumptions contains main node
			engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)0));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)1));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			engine.getPossibleQuestionAssumptions(2, Collections.singletonList((long)2));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		List<Long> assumptionIds;	// list to hold more than 2 assumptions
		try {
			// assumptions contains main node
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add((long)0);
			assumptionIds.add((long)((Math.random()<.5)?1:2));
			if (Math.random() < .5) {
				assumptionIds.add((long)(assumptionIds.contains((long)1)?2:1));
			}
			engine.getPossibleQuestionAssumptions(0, assumptionIds);
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add((long)1);
			assumptionIds.add((long)((Math.random()<.5)?0:2));
			if (Math.random() < .5) {
				assumptionIds.add((long)(assumptionIds.contains((long)0)?2:0));
			}
			engine.getPossibleQuestionAssumptions(1, assumptionIds);
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add((long)2);
			assumptionIds.add((long)((Math.random()<.5)?0:1));
			if (Math.random() < .5) {
				assumptionIds.add((long)(assumptionIds.contains((long)0)?1:0));
			}
			engine.getPossibleQuestionAssumptions(2, assumptionIds);
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// test inexistent assumptions
			assumptionIds = new ArrayList<Long>();
			do {
				assumptionIds.add((long)(Math.random()*Integer.MIN_VALUE) - 1);
			} while (Math.random() < .5);
			engine.getPossibleQuestionAssumptions(0, assumptionIds);
			fail("Assumptions must exist in the Bayes Net");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		assumptions = engine.getPossibleQuestionAssumptions(0, null);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(0, (List)Collections.emptyList());
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)1));
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)2));
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)1); assumptionIds.add((long)2);
		assumptions = engine.getPossibleQuestionAssumptions(0, assumptionIds);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(1, null);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(1, (List)Collections.emptyList());
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)0));
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)2));
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)2));
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)0); assumptionIds.add((long)2);
		assumptions = engine.getPossibleQuestionAssumptions(1, assumptionIds);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(2, null);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)1));
		assumptions = engine.getPossibleQuestionAssumptions(2, (List)Collections.emptyList());
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)1));
		assumptions = engine.getPossibleQuestionAssumptions(2, Collections.singletonList((long)0));
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)1));
		assumptions = engine.getPossibleQuestionAssumptions(2, Collections.singletonList((long)1));
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)1));
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)0); assumptionIds.add((long)1);
		assumptions = engine.getPossibleQuestionAssumptions(2, assumptionIds);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assertTrue(assumptions.contains((long)1));
		

		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		assertEquals(1, engine.getQuestionAssumptionGroups().size());
		assertEquals(3, engine.getQuestionAssumptionGroups().get(0).size());
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(0L));
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(1L));
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(2L));
		
		// case 4: 1<-0->2
		engine.initialize();
		transactionKey = engine.startNetworkActions();
		// create questions 0,1,2
		engine.addQuestion(transactionKey, new Date(), 0, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 1, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 2, (int)(2+(Math.random()*3)), null);
		// create edges 1<-0 and 2<-0
		engine.addQuestionAssumption(transactionKey, new Date(), 1, Collections.singletonList((long)0), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 2, Collections.singletonList((long)0), null);
		engine.commitNetworkActions(transactionKey);
		try {
			// assumptions contains main node
			engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)0));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)1));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			engine.getPossibleQuestionAssumptions(2, Collections.singletonList((long)2));
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add((long)0);
			assumptionIds.add((long)((Math.random()<.5)?1:2));
			if (Math.random() < .5) {
				assumptionIds.add((long)(assumptionIds.contains((long)1)?2:1));
			}
			engine.getPossibleQuestionAssumptions(0, assumptionIds);
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add((long)1);
			assumptionIds.add((long)((Math.random()<.5)?0:2));
			if (Math.random() < .5) {
				assumptionIds.add((long)(assumptionIds.contains((long)0)?2:0));
			}
			engine.getPossibleQuestionAssumptions(1, assumptionIds);
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// assumptions contains main node
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add((long)2);
			assumptionIds.add((long)((Math.random()<.5)?0:1));
			if (Math.random() < .5) {
				assumptionIds.add((long)(assumptionIds.contains((long)0)?1:0));
			}
			engine.getPossibleQuestionAssumptions(2, assumptionIds);
			fail("Question cannot be assumption of itself");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		try {
			// test inexistent assumptions
			assumptionIds = new ArrayList<Long>();
			do {
				assumptionIds.add((long)(Math.random()*Integer.MIN_VALUE) - 1);
			} while (Math.random() < .5);
			engine.getPossibleQuestionAssumptions(0, assumptionIds);
			fail("Assumptions must exist in the Bayes Net");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		assumptions = engine.getPossibleQuestionAssumptions(0, null);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(0, (List)Collections.emptyList());
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assertTrue(assumptions.contains((long)2));
		assumptions = engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)1));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)1));
		assumptions = engine.getPossibleQuestionAssumptions(0, Collections.singletonList((long)2));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)2));
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)1); assumptionIds.add((long)2);
		assumptions = engine.getPossibleQuestionAssumptions(0, assumptionIds);
		assertEquals(0, assumptions.size());
		assumptions = engine.getPossibleQuestionAssumptions(1, null);
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assumptions = engine.getPossibleQuestionAssumptions(1, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assumptions = engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)0));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assumptions = engine.getPossibleQuestionAssumptions(1, Collections.singletonList((long)2));
		assertEquals(0, assumptions.size());
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)0); assumptionIds.add((long)2);
		assumptions = engine.getPossibleQuestionAssumptions(1, assumptionIds);
		assertEquals(0, assumptions.size());
		assumptions = engine.getPossibleQuestionAssumptions(2, null);
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assumptions = engine.getPossibleQuestionAssumptions(2, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assumptions = engine.getPossibleQuestionAssumptions(2, Collections.singletonList((long)0));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)0));
		assumptions = engine.getPossibleQuestionAssumptions(2, Collections.singletonList((long)1));
		assertEquals(0, assumptions.size());
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)0); assumptionIds.add((long)1);
		assumptions = engine.getPossibleQuestionAssumptions(2, assumptionIds);
		assertEquals(0, assumptions.size());
		

		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		assertEquals(2, engine.getQuestionAssumptionGroups().size());
		assertEquals(2, engine.getQuestionAssumptionGroups().get(0).size());
		assertEquals(2, engine.getQuestionAssumptionGroups().get(1).size());
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(0L));
		assertTrue(engine.getQuestionAssumptionGroups().get(1).contains(0L));
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(1L) || engine.getQuestionAssumptionGroups().get(1).contains(1L));
		assertTrue(engine.getQuestionAssumptionGroups().get(0).contains(2L) || engine.getQuestionAssumptionGroups().get(1).contains(2L));
		
		// disconnected case: 0, 1->2, 3->4<-5, 6<-7->8
		engine.initialize();
		transactionKey = engine.startNetworkActions();
		// create questions 0,1,2
		engine.addQuestion(transactionKey, new Date(), 0, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 1, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 2, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 3, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 4, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 5, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 6, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 7, (int)(2+(Math.random()*3)), null);
		engine.addQuestion(transactionKey, new Date(), 8, (int)(2+(Math.random()*3)), null);
		// create edges 1->2,  3->4<-5, 7->6, and 7->8
		engine.addQuestionAssumption(transactionKey, new Date(), 2, Collections.singletonList((long)1), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 4, Collections.singletonList((long)3), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 4, Collections.singletonList((long)5), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 6, Collections.singletonList((long)7), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 8, Collections.singletonList((long)7), null);
		engine.commitNetworkActions(transactionKey);
		for (long i = 0; i < 9; i++) {
			try {
				// assumptions contains main node
				engine.getPossibleQuestionAssumptions(i, Collections.singletonList(i));
				fail("Question cannot be assumption of itself: " + i);
			}catch (IllegalArgumentException e) {
				assertNotNull(e); // OK. 
			}
			try {
				// assumptions contains main node
				assumptionIds = new ArrayList<Long>();
				assumptionIds.add(i);
				do {
					long assumptionToAdd = (long)((Math.random()*9));
					if (assumptionToAdd == i) {
						continue;
					}
					assumptionIds.add(assumptionToAdd);
				} while (Math.random() < .5);
				engine.getPossibleQuestionAssumptions(i, assumptionIds);
				fail("Question cannot be assumption of itself: " + i + ", assumptions: " + assumptionIds);
			}catch (IllegalArgumentException e) {
				assertNotNull(e); // OK. 
			}
		}
		try {
			// test inexistent assumptions
			assumptionIds = new ArrayList<Long>();
			do {
				assumptionIds.add((long)(Math.random()*Integer.MIN_VALUE) - 1);
			} while (Math.random() < .5);
			engine.getPossibleQuestionAssumptions(0, assumptionIds);
			fail("Assumptions must exist in the Bayes Net");
		}catch (IllegalArgumentException e) {
			assertNotNull(e); // OK. 
		}
		// 0,
		assertEquals(0,  engine.getPossibleQuestionAssumptions(0, null).size());
		assertEquals(0,  engine.getPossibleQuestionAssumptions(0, (List)Collections.emptyList()).size());
		for (long i = 1; i < 9; i++) {
			assertEquals(0,  engine.getPossibleQuestionAssumptions(0, Collections.singletonList(i)).size());
		}
		// 1->2,
		assumptions = engine.getPossibleQuestionAssumptions(1, null);
		assertEquals(1, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(2L));
		assumptions = engine.getPossibleQuestionAssumptions(2, null);
		assertEquals(1, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(1L));
		assumptions = engine.getPossibleQuestionAssumptions(1, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(2L));
		assumptions = engine.getPossibleQuestionAssumptions(2, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(1L));
		assumptions = engine.getPossibleQuestionAssumptions(1, Collections.singletonList(2L));
		assertEquals(1, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(2L));
		assumptions = engine.getPossibleQuestionAssumptions(2, Collections.singletonList(1L));
		assertEquals(1, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(1L));
		// invalid conditions
		assertTrue(engine.getPossibleQuestionAssumptions(1, Collections.singletonList(0L)).isEmpty());
		assertTrue(engine.getPossibleQuestionAssumptions(2, Collections.singletonList(0L)).isEmpty());
		for (long i = 3; i < 8; i++) {
			assertTrue(engine.getPossibleQuestionAssumptions(1, Collections.singletonList(i)).isEmpty());
			assertTrue(engine.getPossibleQuestionAssumptions(2, Collections.singletonList(i)).isEmpty());
		}
		// 3->4<-5,
		assumptions = engine.getPossibleQuestionAssumptions(3, null);
		assertEquals(2, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(4L));
		assertTrue("Assumptions = " + assumptions, assumptions.contains(5L));
		assumptions = engine.getPossibleQuestionAssumptions(4, null);
		assertEquals(2, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(3L));
		assertTrue("Assumptions = " + assumptions, assumptions.contains(5L));
		assumptions = engine.getPossibleQuestionAssumptions(5, null);
		assertEquals(2, assumptions.size());
		assertTrue("Assumptions = " + assumptions, assumptions.contains(3L));
		assertTrue("Assumptions = " + assumptions, assumptions.contains(4L));
		for (long i = 0; i < 8; i++) {
			if (i >= 3 && i <= 5) {
				i = 6;
			}
			assertTrue(engine.getPossibleQuestionAssumptions(3, Collections.singletonList(i)).isEmpty());
			assertTrue(engine.getPossibleQuestionAssumptions(4, Collections.singletonList(i)).isEmpty());
			assertTrue(engine.getPossibleQuestionAssumptions(5, Collections.singletonList(i)).isEmpty());
		}
		// 6<-7->8
		assumptions = engine.getPossibleQuestionAssumptions(7, null);
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)6));
		assertTrue(assumptions.contains((long)8));
		assumptions = engine.getPossibleQuestionAssumptions(7, (List)Collections.emptyList());
		assertEquals(2, assumptions.size());
		assertTrue(assumptions.contains((long)6));
		assertTrue(assumptions.contains((long)8));
		assumptions = engine.getPossibleQuestionAssumptions(7, Collections.singletonList((long)6));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)6));
		assumptions = engine.getPossibleQuestionAssumptions(7, Collections.singletonList((long)8));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)8));
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)6); assumptionIds.add((long)8);
		assumptions = engine.getPossibleQuestionAssumptions(7, assumptionIds);
		assertEquals(0, assumptions.size());
		assumptions = engine.getPossibleQuestionAssumptions(6, null);
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)7));
		assumptions = engine.getPossibleQuestionAssumptions(6, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)7));
		assumptions = engine.getPossibleQuestionAssumptions(6, Collections.singletonList((long)7));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)7));
		assumptions = engine.getPossibleQuestionAssumptions(6, Collections.singletonList((long)8));
		assertEquals(0, assumptions.size());
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)7); assumptionIds.add((long)8);
		assumptions = engine.getPossibleQuestionAssumptions(6, assumptionIds);
		assertEquals(0, assumptions.size());
		assumptions = engine.getPossibleQuestionAssumptions(8, null);
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)7));
		assumptions = engine.getPossibleQuestionAssumptions(8, (List)Collections.emptyList());
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)7));
		assumptions = engine.getPossibleQuestionAssumptions(8, Collections.singletonList((long)7));
		assertEquals(1, assumptions.size());
		assertTrue(assumptions.contains((long)7));
		assumptions = engine.getPossibleQuestionAssumptions(8, Collections.singletonList((long)6));
		assertEquals(0, assumptions.size());
		assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add((long)7); assumptionIds.add((long)6);
		assumptions = engine.getPossibleQuestionAssumptions(8, assumptionIds);
		assertEquals(0, assumptions.size());
		// disconnected nodes as assumptions
		for (long i = 0; i < 6; i++) {
			assumptions = engine.getPossibleQuestionAssumptions((Math.random()<.34)?7:(Math.random()<.34)?6:8, Collections.singletonList(i));
			assertEquals(0, assumptions.size());
		}
		
		// test getQuestionAssumptionGroups for disconnected net: 0, 1->2, 3->4<-5, 6<-7->8
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		assertEquals(5, engine.getQuestionAssumptionGroups().size());
		for (List<Long> clique : engine.getQuestionAssumptionGroups()) {
			assertTrue("Clique = " + clique, clique.size() >= 1 && clique.size() <= 3);
			if (clique.size() == 1) {	// 0
				assertTrue("Clique = " + clique, clique.contains(0L));
			} else if (clique.size() == 2) {	// 1->2 or 6<-7->8
				assertTrue("Clique = " + clique, ( clique.contains(1L) && clique.contains(2L) ) 
						|| ( clique.contains(6L) && clique.contains(7L) ) 
						|| ( clique.contains(8L) && clique.contains(7L) ) );
			} else {	// 3->4<-5
				assertTrue("Clique = " + clique, clique.contains(3L));
				assertTrue("Clique = " + clique, clique.contains(4L));
				assertTrue("Clique = " + clique, clique.contains(5L));
			}
		}
	}
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#previewBalancingTrade(long, long, java.util.List, java.util.List)},
	 * {@link MarkovEngineImpl#doBalanceTrade(long, Date, String, long, long, List, List)}.
	 * Note: this method will not test {@link MarkovEngineImpl#previewBalancingTrade(long, long, List, List)}
	 * directly, because {@link MarkovEngineImpl#doBalanceTrade(long, Date, String, long, long, List, List)}
	 * calls {@link MarkovEngineImpl#previewBalancingTrade(long, long, List, List)} internally.
	 */
	public final void testBalanceTrade() {
		if (engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			// no need to test balancing trades if we are not dealing with assets
			return;
		}
		// perform the same sequence of trades of testAddTradeInOneTransaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Tom"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			);
		
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			);
		

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Joe"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		
		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			);
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Amy"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			);
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			);
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Eric"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			);
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
		);
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			engine.doBalanceTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, null, null);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// test invalid questions and assumptions
		for (String key : userNameToIDMap.keySet()) {
			// invalid question
			do {
				try {
					long questionId = (long) (Math.random()*Integer.MIN_VALUE);
					engine.previewBalancingTrade(
							userNameToIDMap.get(key), 
							questionId, 
							(List)((Math.random() < .5)?null:Collections.emptyList()), 
							(List)((Math.random() < .5)?null:Collections.emptyList())
						);
					fail(questionId + " should be an invalid question.");
				} catch (IllegalArgumentException e) {
					assertNotNull(e);	// ok
				}
			} while (Math.random() < .5);
			// invalid assumption
			do {
				try {
					// choose question 0x0D, 0x0E, or 0x0F randomly
					long questionId = (Math.random() < .33)?0x0D:((Math.random() < .5)?0x0E:0x0F);
					List<Long> assumptionIds = new ArrayList<Long>();
					// fill assumptionIds with invalid assumptions
					// assumption is invalid if assumptionIds contain questionId
					if (Math.random() < .5) {
						assumptionIds.add(questionId);
					}
					// assumption is invalid if it contains inexistent node
					do {
						assumptionIds.add((long)(Math.random()*Integer.MIN_VALUE));
					} while (Math.random() < .5);
					// fill valid states (the nodes have only 2 states - 0 or 1)
					List<Integer> assumedStates = new ArrayList<Integer>();
					for (int i = 0; i < assumptionIds.size(); i++) {
						assumedStates.add((Math.random() < .5)?0:1);
					}
					engine.previewBalancingTrade(
							userNameToIDMap.get(key), 
							questionId, 
							assumptionIds, 
							assumedStates
						);
					fail("Questions " + assumptionIds + " and states " + assumedStates + " are invalid assumptions of question " +  questionId);
				} catch (IllegalArgumentException e) {
					assertNotNull(e);	// ok
				}
			} while (Math.random() < .5);
		}
		
		// test valid balance trades
		
		
		
		// prepare the transaction which will make users to exit (balance) from question given assumptions
		transactionKey = engine.startNetworkActions();
		
		// Available users are Joe, Tom, Amy, Eric. For each user, randomly generate question|assumptions to balance
		Map<String, Long> userToQuestionToBalanceMap = new HashMap<String, Long>();					// map to store the question user has chosen
		Map<String, List<Long>> userToAssumptionMap = new HashMap<String, List<Long>>();			// map to store user's assumptions
		Map<String, List<Integer>> userToAssumedStatesMap = new HashMap<String, List<Integer>>();	// map to store user's assumed states
		
		// generate random balance requests for each user
		for (String user : userNameToIDMap.keySet()) {
			// choose question randomly from [0x0D, 0x0E, 0x0F]
			long question = ((Math.random() < .33)?0x0D:((Math.random() < .5)?0x0E:0x0F));
			userToQuestionToBalanceMap.put(user, question);
			
			// setup assumption randomly
			List<Long> assumptions = new ArrayList<Long>();
			if (question > 0x0D) {	
				// 0x0E and 0x0F can only have 1 assumption, which is 0x0D
				if (Math.random() < .5) {
					assumptions.add((long)0x0D);
				}
			} else {
				// 0x0D can have either 0x0E or 0x0F as assumptions, but never both simultaneously.
				if (Math.random() < .5) {
					/*
					 * Assume question + 1 (but choose 0x0D if question is 0x0F).
					 * E.g. if question == 0x0D, then assumption == 0x0E;
					 * if question == 0x0E, then assumption == 0x0F;
					 * if question == 0x0F, then assumption == 0x0D;
					 */
					assumptions.add(((question == 0x0F)?0x0D:(question+1)));
				} else if (Math.random() < .5) {	
					/*
					 * Assume question - 1 (but choose 0x0F if question is 0x0D).
					 * E.g. if question == 0x0D, then assumption == 0x0F;
					 * if question == 0x0E, then assumption == 0x0D;
					 * if question == 0x0F, then assumption == 0x0E;
					 */
					assumptions.add(((question == 0x0D)?0x0F:(question-1)));
				}
			}
			userToAssumptionMap.put(user, assumptions);
			
			// setup states of the assumptions correctly regarding assumptions
			List<Integer> states = new ArrayList<Integer>();
			for (int i = 0; i < assumptions.size(); i++) {
				states.add((Math.random() < .5)?0:1);	// nodes have supposedly 2 states: 0,1
			}
			userToAssumedStatesMap.put(user, states);
			
			// add trade into transaction
			engine.doBalanceTrade(transactionKey, new Date(), user + " balances question " + question, userNameToIDMap.get(user), question, assumptions, states);
		}
		
		// execute trade which will balance the assets of the users
		engine.commitNetworkActions(transactionKey);
		
		// check if users have quit the questions correctly
		for (String user : userNameToIDMap.keySet()) {
			// extract the user's choices from the maps
			long questionId = userToQuestionToBalanceMap.get(user);
			List<Long> assumptionIds = userToAssumptionMap.get(user);
			List<Integer> assumedStates = userToAssumedStatesMap.get(user);
			// The condition to exit (balance) from a trade is to make the assets to become the same for each states of a node.
			List<Float> assets = engine.getAssetsIfStates(userNameToIDMap.get(user), questionId, assumptionIds, assumedStates);
			// since assumedStates has the same size of assumptionIds, size of assets must be equal to quantity of states (i.e. 2)
			assertEquals("User = " + user + ", question = " + questionId + ", assumptions = " + assumptionIds + ", states = " + assumedStates, 2, assets.size() );
			// the asset values must be the same for all states if we did exit (balanced) correctly
			assertEquals(
					"User = " + user + ", question = " + questionId + ", assumptions = " + assumptionIds + ", states = " + assumedStates,
					assets.get(0), assets.get(1), ASSET_ERROR_MARGIN
				);
		}
		
		// check from the history that the balancing trades were successfully created
		HashSet<BalanceTradeNetworkAction> balanceTradesInHistory = new HashSet<MarkovEngineImpl.BalanceTradeNetworkAction>();
		for (Long questionId : new HashSet<Long>(userToQuestionToBalanceMap.values())) {
			for (QuestionEvent event : engine.getQuestionHistory(questionId, null, null)) {
				if (!(event instanceof StructureChangeNetworkAction)
						&& !(event.getQuestionId().longValue() != questionId)) {
					assertNotNull(event.getUserId());
				}
				if (event instanceof BalanceTradeNetworkAction) {
					balanceTradesInHistory.add((BalanceTradeNetworkAction) event);
				}
			}
		}
		
		// we have created 1 trade per user
		assertEquals(userNameToIDMap.keySet().size(), balanceTradesInHistory.size());
		for (String user : userNameToIDMap.keySet()) {
			// check that trades of all users were actually treated
			boolean found = false;
			for (BalanceTradeNetworkAction action : balanceTradesInHistory) {
				if (action.getUserId().equals(userNameToIDMap.get(user))) {
					found = true;
					break;
				}
			}
			if (!found) {
				fail("Did not find balancing trade of user " + user);
			}
		}
		

		// test invalid assumptions
		transactionKey = engine.startNetworkActions();
		
		// add a in which the assumptions will be ignored
		assertTrue( engine.doBalanceTrade(
				transactionKey, 
				new Date(), 
				"Tom balances P(E|F = f1)", 
				userNameToIDMap.get("Tom"), 
				0x0EL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList(1) 
			));
		engine.commitNetworkActions(transactionKey);
		
		// check that Tom has exited E (i.e. condition F was ignored)
		List<Float> assetIfStates = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0EL, null, null);
		assertEquals(2, assetIfStates.size());
		assertEquals(assetIfStates.get(0), assetIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// check that in the history, the assumption F was ignored
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0EL, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(qe.getUserId());
			}
		}
		assertNotNull(questionHistory);
		assertFalse(questionHistory.isEmpty());
		BalanceTradeNetworkAction action = (BalanceTradeNetworkAction) questionHistory.get(questionHistory.size()-1);
		assertEquals((long)0x0E, (long)action.getQuestionId());
		assertTrue("Assumptions = " + action.getTradeId(), action.getAssumptionIds().isEmpty());
	}

	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#resolveQuestion(long, java.util.Date, long, int)}.
	 */
	public final void testResolveQuestion() {
		
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// check probs and assets before resolution D = d1
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		List<Float> probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		List<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// this map will store the conditional cashes for posterior comparison. 
		// E.g. Tom -> [Cash(d1,e1,f1),Cash(d1,e1,f2),Cash(d1,e2,f1),Cash(d1,e2,f2),Cash(d2,e1,f1),Cash(d2,e1,f2),Cash(d2,e2,f1),Cash(d2,e2,f2)]
		Map<String, List<Float>> mapOfConditionalCash = new HashMap<String, List<Float>>();
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		mapOfConditionalCash.put("Tom", new ArrayList<Float>());
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Tom").add(cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Tom").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Tom").add(cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Tom").add(cash);

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		mapOfConditionalCash.put("Amy", new ArrayList<Float>());
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Amy").add(cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Amy").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Amy").add(cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Amy").add(cash);
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		mapOfConditionalCash.put("Joe",new ArrayList<Float>());
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		mapOfConditionalCash.put("Eric",new ArrayList<Float>());
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// get the expected score per D for each user
		Map<Long, Float> expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}
		
		// resolve to d1
		long transactionKey = engine.startNetworkActions();
		assertTrue(engine.resolveQuestion(transactionKey, new Date(), (long)0x0D, 0));
		assertTrue(engine.commitNetworkActions(transactionKey));
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// cannot reuse same transaction key
		try {
			engine.resolveQuestion(transactionKey, new Date(), (long)0x0E, 0);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// assert that D is not accessible anymore
		try {
			probList = engine.getProbList((long)0x0D, null, null);
			// marginals of resolved questions can still be retrieved if engine is set to retrieve such values from history.
			if (!engine.isToObtainProbabilityOfResolvedQuestions()) {
				fail("D should not be present anymore");
			} else {
				// check that final marginal of D is [1, 0]
				assertEquals(2, probList.size());
				assertEquals(1f, probList.get(0), PROB_ERROR_MARGIN);
				assertEquals(0f, probList.get(1), PROB_ERROR_MARGIN);
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToObtainProbabilityOfResolvedQuestions()) {
				// marginals of resolved questions can still be retrieved if engine is set to retrieve such values from history.
				e.printStackTrace();
				fail(e.getMessage());
			} else {
				assertNotNull(e);
			}
		}
		try {
			probList = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null);
			if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
				// from December 2012, resolved assumptions are ignored if the state is either not specified or valid 
				// (if invalid, it will throw exception, though)
				assertEquals(2, probList.size());
				assertEquals(0.9509f, probList.get(0), PROB_ERROR_MARGIN);
				assertEquals(0.0491f, probList.get(1), PROB_ERROR_MARGIN);
			} else {
				// check that final marginal of E is [0.9509, 0.0491]
				assertEquals(4, probList.size());
				assertEquals(0.9509f, probList.get(0), PROB_ERROR_MARGIN);
				assertEquals(0.0491f, probList.get(1), PROB_ERROR_MARGIN);
				assertEquals(0f, probList.get(2), PROB_ERROR_MARGIN);
				assertEquals(0f, probList.get(3), PROB_ERROR_MARGIN);
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			List<Float> assetsIfStates = engine.getAssetsIfStates(userId, (long)0x0D, null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				if (engine.isToDeleteResolvedNode()) {
					fail("D should not be present anymore");
				} else {
					// make sure the impossible state has assets == 0
					assertEquals(2, assetsIfStates.size());
					assertTrue(Float.isInfinite(assetsIfStates.get(1)));	// 0 of q-value means -infinite assets
				}
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			List<Float> assetsIfStates = engine.getAssetsIfStates(userId, (long)0x0E, Collections.singletonList((long)0x0D), null);
			if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
				// after 2013 Jan, resolved questions are ignored if it's in settled state, and NaN is returned if not in settled state
				List<Float> assetsIfStatesWithoutAssumption = engine.getAssetsIfStates(userId, (long)0x0E, null, null);
				if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
					assertEquals(assetsIfStatesWithoutAssumption.size(), assetsIfStates.size());
					for (int i = 0; i < assetsIfStates.size(); i++) {
						assertEquals(assetsIfStatesWithoutAssumption.get(i), assetsIfStates.get(i), ASSET_ERROR_MARGIN);
					}
				}
			} else if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// make sure the impossible state has assets == 0
				assertEquals(4, assetsIfStates.size());
				assertTrue(Float.isInfinite(assetsIfStates.get(2)));	// 0 of q-value means -infinite assets
				assertTrue(Float.isInfinite(assetsIfStates.get(3)));	// 0 of q-value means -infinite assets
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			cash = engine.getCash(userId, Collections.singletonList((long)0x0D), Collections.singletonList(1));
			if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
				// from 2013 Jan, resolved questions are properly treated
				assertEquals(Float.NaN, cash, ASSET_ERROR_MARGIN);
			} else {
				// make sure the impossible state has assets == 0
				fail("Should throw exeption indicating that assets == inconsistent (or 0)");
//				assertTrue("Cash = " + cash, Float.isInfinite(cash));	// 0 of q-value means -infinite assets
			}
		} catch (IllegalStateException e) {
			e.printStackTrace();
			fail();
		} catch (ZeroAssetsException e) {
			// OK. Impossible state yields zero 
			assertNotNull(e);
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			try {
				Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
				List<Float> balancingTrade = engine.previewBalancingTrade(userId, (long)0x0D, null, null);
				fail("D should not be resolvable anymore: " + balancingTrade);
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
			try {
				Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
				List<Float> balancingTrade = engine.previewBalancingTrade(userId, (long)((Math.random() < .5)?0x0E:0x0F), Collections.singletonList((long)0x0D), Collections.singletonList(1));
				fail("D should not be resolvable anymore: " + balancingTrade);
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			List<Float> newValues = new ArrayList<Float>();
			newValues.add((float) Math.random());	newValues.add(1-newValues.get(0));
			engine.previewTrade(userId, (long)0x0D, newValues, null, null);
			fail("D should not be present anymore");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			List<Float> newValues = new ArrayList<Float>();
			newValues.add((float) Math.random());	newValues.add(1-newValues.get(0));
			engine.previewTrade(userId, (long)((Math.random() < .5)?0x0E:0x0F), newValues, Collections.singletonList((long)0x0D), Collections.singletonList(((Math.random()<.5)?0:1)));
			fail("D should not be present anymore");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			engine.getEditLimits(userId, (long)0x0D, (Math.random() < .5)?0:1, null, null);
			fail("D should not be present anymore");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		try {
			Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			engine.getEditLimits(userId, (long)((Math.random() < .5)?0x0E:0x0F), (Math.random() < .5)?0:1, Collections.singletonList((long)0x0D), Collections.singletonList(((Math.random()<.5)?0:1)));
			fail("D should not be present anymore");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		try {
			List<Long> assumptions = engine.getPossibleQuestionAssumptions((long)0x0D, null);
			if (engine.isToDeleteResolvedNode()) {
				fail("D should not be present anymore");
			} else {
				assertNotNull(assumptions);
				assertEquals(2, assumptions.size());
				assertTrue(assumptions.contains((long)0x0E));
				assertTrue(assumptions.contains((long)0x0F));
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		try {
			List<Long> assumptions = engine.getPossibleQuestionAssumptions((long)((Math.random() < .5)?0x0E:0x0F), Collections.singletonList((long)0x0D));
			if (engine.isToDeleteResolvedNode()) {
				fail("D should not be present anymore");
			} else {
				assertNotNull(assumptions);
				assertEquals(1, assumptions.size());
				assertTrue(assumptions.contains((long)0x0D));
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		Long userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
		try {
			float scoreUserQuestionEv = engine.scoreUserQuestionEv(userId, (long)0x0D, null, null);
			if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
				//　from Jan 30, 2013, scoreUserQuestionEv of a resolved question will be equal to scoreUserEv.
				assertEquals(engine.scoreUserEv(userId, null, null), scoreUserQuestionEv, ASSET_ERROR_MARGIN);
			}
		} catch (ZeroAssetsException e) {
			e.printStackTrace();
			fail(e.getMessage() + ", userId = " + userId);
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		try {
			userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			long questionId = (long)((Math.random() < .5)?0x0E:0x0F);
			assumedStates = (List) Collections.singletonList(((Math.random()<.5)?0:1));
			float scoreUserQuestionEv = engine.scoreUserQuestionEv(userId, questionId, Collections.singletonList((long)0x0D), assumedStates);
			if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
				//　from Jan 30, 2013, scoreUserQuestionEv of a resolved question will be equal to scoreUserEv.
				if (assumedStates.get(0).intValue() == 0) {
					assertEquals(engine.scoreUserEv(userId, null, null), scoreUserQuestionEv, ASSET_ERROR_MARGIN);
				} else {
					assertEquals(Float.NaN, scoreUserQuestionEv, ASSET_ERROR_MARGIN);
				}
			}
		} catch (ZeroAssetsException e) {
			e.printStackTrace();
			fail(e.getMessage());
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			try {
				userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
				List<Float> scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userId, (long)0x0D, null, null);
				if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
					// from 2013 Jan, resolved questions are properly treated by using NaN in states other than the settled
					assertEquals(2, scoreUserQuestionEvStates.size());
					assertEquals(engine.scoreUserEv(userId, null, null), scoreUserQuestionEvStates.get(0), ASSET_ERROR_MARGIN);
					assertEquals(Float.NaN, scoreUserQuestionEvStates.get(1));
				}
			} catch (IllegalArgumentException e) {
				if (engine.isToDeleteResolvedNode()) {
					assertNotNull(e);
				} else {
					e.printStackTrace();
					fail(e.getMessage());
				}
			}
		}
		try {
			userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			long questionId = (long)((Math.random() < .5)?0x0E:0x0F);
			assumedStates = Collections.singletonList(((Math.random()<.5)?0:1));
			List<Float> scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userId, questionId, Collections.singletonList((long)0x0D), assumedStates);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				if (engine.isToDeleteResolvedNode()) {
//				fail("D should not be present anymore");
					// from 2013 Jan, resolved questions are properly handled by using NaN when state is other than the settled.
					if (assumedStates.get(0).intValue() == 0 ) {
						// assumption is in the settled state, so it's the same of ignoring such assumption
						List<Float> scoreUserQuestionEvStatesIgnoringAssumptions = engine.scoreUserQuestionEvStates(userId, questionId, null, null);
						assertEquals(scoreUserQuestionEvStatesIgnoringAssumptions.size(), scoreUserQuestionEvStates.size());
						for (int i = 0; i < scoreUserQuestionEvStates.size(); i++) {
							assertEquals(scoreUserQuestionEvStatesIgnoringAssumptions.get(i), scoreUserQuestionEvStates.get(i), ASSET_ERROR_MARGIN);
						}
					} else {
						// the assumption is not in the settled state
						for (Float score : scoreUserQuestionEvStates) {
							assertEquals(Float.NaN, score);
						}
					}
				}
			}
		} catch (IllegalArgumentException e) {
			if (engine.isToDeleteResolvedNode()) {
				assertNotNull(e);
			} else {
				e.printStackTrace();
				fail(e.getMessage());
			}
		}
		
		// assert that D is not accessible in transactional methods as well
		try {
			userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			transactionKey = engine.startNetworkActions();
			List<Float> newValues = new ArrayList<Float>();
			newValues.add((float) Math.random());	newValues.add(1-newValues.get(0));
			engine.addTrade(transactionKey, new Date(), "To fail", userId, (long)0x0D, newValues, null, null, false);
			fail("D should not be present anymore");
		} catch (IllegalArgumentException e) {
			engine.commitNetworkActions(transactionKey);
			assertNotNull(e);
		}
		try {
			userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
			transactionKey = engine.startNetworkActions();
			List<Float> newValues = new ArrayList<Float>();
			newValues.add((float) Math.random());	newValues.add(1-newValues.get(0));
			engine.addTrade(transactionKey, new Date(), "To fail", userId, (long)((Math.random()<.5)?0x0E:0x0F), newValues, Collections.singletonList((long)0x0D), Collections.singletonList(((Math.random()<.5)?0:1)), false);
			fail("D should not be present anymore");
		} catch (IllegalArgumentException e) {
			engine.commitNetworkActions(transactionKey);
			assertNotNull(e);
		}
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			try {
				userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
				transactionKey = engine.startNetworkActions();
				engine.doBalanceTrade(transactionKey, new Date(), "To fail", userId, (long)0x0D, null, null );
				fail("D should not be present anymore");
			} catch (IllegalArgumentException e) {
				engine.commitNetworkActions(transactionKey);
				assertNotNull(e);
			}
			
			try {
				userId = userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy");
				transactionKey = engine.startNetworkActions();
				engine.doBalanceTrade(transactionKey, new Date(), "To fail", userId, (long)((Math.random()<.5)?0x0E:0x0F), Collections.singletonList((long)0x0D), Collections.singletonList(((Math.random()<.5)?0:1)));
				fail("D should not be present anymore");
			} catch (IllegalArgumentException e) {
				engine.commitNetworkActions(transactionKey);
				assertNotNull(e);
			}
		}
		
		
		// history and score detail/summary can be accessed normally
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertFalse(engine.getQuestionHistory((long) 0x0D, null, null).isEmpty());
		}
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0DL, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertFalse(engine.getScoreDetails(userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy"), (long)0x0D, null, null).isEmpty());
		try {
			assertNotNull(engine.getScoreSummary(userNameToIDMap.get((Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":(Math.random() < .25)?"Tom":"Amy"), (long)0x0D, null, null));
		} catch (IllegalStateException e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		// revert trade should be OK
		transactionKey = engine.startNetworkActions();
		engine.revertTrade(transactionKey, new Date(), new Date(new Date().getTime() + 1), (long)0x0D);	// use future date, so that nothing is actually reverted
		engine.commitNetworkActions(transactionKey);
		
		
		// check that final marginal of E is [0.9509, 0.0491], F is  [0.2416, 0.7584]
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.9509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.0491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2416f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7584f, probList.get(1), PROB_ERROR_MARGIN);
		if (engine.isToObtainProbabilityOfResolvedQuestions()) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(1f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0f, probList.get(1), PROB_ERROR_MARGIN);
		} else {
			engine.setToObtainProbabilityOfResolvedQuestions(true);
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(1f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0f, probList.get(1), PROB_ERROR_MARGIN);
			engine.setToObtainProbabilityOfResolvedQuestions(false);
		}
		
		// test that conditional cash matches the values before resolution
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0E);	assumptionIds.add((long)0x0F);
		if (!engine.isToDeleteResolvedNode()) {
			assumptionIds.add((long)0x0D);
		}
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); assumedStates.add(0); 
		if (!engine.isToDeleteResolvedNode()) {
			assumedStates.add(0);
		}
		for (String userName : mapOfConditionalCash.keySet()) {
			if (!engine.isToDeleteResolvedNode()) {
				assumedStates.set(2, 0);	// d1
			}
			for (int i = 0; i < 4; i++) {	// combinations [e1f1,e1f2,e2f1,e2f2]
				assumedStates.set(0, (int)i/2);	// e
				assumedStates.set(1, (int)i%2);	// f
				cash = engine.getCash(userNameToIDMap.get(userName), assumptionIds, assumedStates);
				assertEquals("[" + i + "] user = " + userName + ", e = " + (int)i/2 + ", f = " + (int)i%2, mapOfConditionalCash.get(userName).get(i), cash);
			}
			if (!engine.isToDeleteResolvedNode()) {
				assumedStates.set(2, 1);	// d2
				for (int i = 0; i < 4; i++) {	// combinations [e1f1d2,e1f2d2,e2f1d2,e2f2d2]
					assumedStates.set(0, (int)i/2);	// e
					assumedStates.set(1, (int)i%2);	// f
					try {
						cash = engine.getCash(userNameToIDMap.get(userName), assumptionIds, assumedStates);
						fail("[" + i + "] user = " + userName + ", e = " + (int)i/2 + ", f = " + (int)i%2 + ", cash = " + cash);
					} catch (ZeroAssetsException e) {
						// It is expected to throw this exception, because we tried to calculate asset of impossible state
						assertNotNull(e);
					}
				}
			} 
		}
	}
	
	public final void testResolveAllQuestion() {

		engine.setToDeleteResolvedNode(false);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		float initAsssets = 12050.81f;
		if (engine.getDefaultInferenceAlgorithm().isToUseQValues()) {
			initAsssets = (float) engine.getQValuesFromScore(initAsssets);
		}
		engine.setDefaultInitialAssetTableValue(initAsssets);
		
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// get the expected score per D for each user
		Map<Long, Float> expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		
		long transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 0x0DL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0EL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0FL, 0);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
		assertEquals(3, probLists.size());
		assertTrue(probLists.get(0x0DL).contains(0f));
		assertTrue(probLists.get(0x0EL).contains(0f));
		assertTrue(probLists.get(0x0FL).contains(0f));

		// after all nodes are resolved, cash and expected scores are equal
		Map<String, Float> cashAndScoreMap = new HashMap<String, Float>();
		
		for (String user : userNameToIDMap.keySet()) {
			float cash = engine.getCash(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Cash of " + user + " = " + cash,Float.isInfinite(cash) || Float.isNaN(cash));
			}
			float score = engine.scoreUserEv(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Score of " + user + " = " + score,Float.isInfinite(score) || Float.isNaN(score));
			}
			assertEquals("user="+user+", cash="+cash+", score="+score,cash, score, ASSET_ERROR_MARGIN);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertTrue(cash > 0 && score > 0);
			}
			cashAndScoreMap.put(user, cash);
		}
		
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		
		engine.setToDeleteResolvedNode(true);
		engine.initialize();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// get the expected score per D for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 0x0DL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0EL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0FL, 0);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// assert that if we look for probabilities of all nodes, no node is present
		probLists = engine.getProbLists(null, null, null);
		assertEquals(0, probLists.size());
		
		// check that we can retrieve marginals by explicitly quering them
		assertTrue(engine.getProbList(0x0DL, null, null).contains(0f));
		assertTrue(engine.getProbList(0x0EL, null, null).contains(0f));
		assertTrue(engine.getProbList(0x0FL, null, null).contains(0f));
		
		
		for (String user : userNameToIDMap.keySet()) {
			float cash = engine.getCash(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Cash of " + user + " = " + cash,Float.isInfinite(cash) || Float.isNaN(cash));
			}
			float score = engine.scoreUserEv(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Score of " + user + " = " + score,Float.isInfinite(score) || Float.isNaN(score));
			}
			assertEquals("User=" + user, cash, score, ASSET_ERROR_MARGIN);
			assertEquals("User=" + user, cashAndScoreMap.get(user), cash, ASSET_ERROR_MARGIN);
			assertEquals("User=" + user, cashAndScoreMap.get(user), score, ASSET_ERROR_MARGIN);
		}
		
		// run same test again, but 1 of the nodes will be resolved outside the trade
		engine.initialize();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// get the expected score per D for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}
		
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 0x0DL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0FL, 0);
		engine.commitNetworkActions(transactionKey);
		engine.resolveQuestion(null, new Date(), 0x0EL, 0);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// assert that if we look for probabilities of all nodes, no node is present
		probLists = engine.getProbLists(null, null, null);
		assertEquals(0, probLists.size());
		
		// check that we can retrieve marginals by explicitly quering them
		assertTrue(engine.getProbList(0x0DL, null, null).contains(0f));
		assertTrue(engine.getProbList(0x0EL, null, null).contains(0f));
		assertTrue(engine.getProbList(0x0FL, null, null).contains(0f));
		
		
		for (String user : userNameToIDMap.keySet()) {
			float cash = engine.getCash(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Cash of " + user + " = " + cash,Float.isInfinite(cash) || Float.isNaN(cash));
			}
			float score = engine.scoreUserEv(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Score of " + user + " = " + score,Float.isInfinite(score) || Float.isNaN(score));
			}
			assertEquals("User=" + user, cash, score, ASSET_ERROR_MARGIN);
			assertEquals("User=" + user, cashAndScoreMap.get(user), cash, ASSET_ERROR_MARGIN);
			assertEquals("User=" + user, cashAndScoreMap.get(user), score, ASSET_ERROR_MARGIN);
		}
		
		
		
		// run other configurations
		
		engine.initialize();
		engine.setCurrentCurrencyConstant((float) (1000/(Math.log(10)/Math.log(2))));
		engine.setCurrentLogBase(2);
		engine.setDefaultInitialAssetTableValue(10);
		userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(0));
		}
		
		engine.resolveQuestion(null, new Date(), 0x0EL, 0);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		
		// get the expected score per D for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 0x0DL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0FL, 0);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		Map<String, Float> cashMap2 = new HashMap<String, Float>();
		Map<String, Float> scoreMap2 = new HashMap<String, Float>();
		
		for (String user : userNameToIDMap.keySet()) {
			float cash = engine.getCash(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Cash of " + user + " = " + cash,Float.isInfinite(cash) || Float.isNaN(cash));
			}
			float score = engine.scoreUserEv(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Score of " + user + " = " + score,Float.isInfinite(score) || Float.isNaN(score));
			}
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertTrue(cash > 0 && score > 0);
			}
			assertEquals(cash, score, ASSET_ERROR_MARGIN);
			cashMap2.put(user, cash);
			scoreMap2.put(user, score);
		}
		
		engine.initialize();
		engine.setCurrentCurrencyConstant(1000);
		engine.setCurrentLogBase(2);
		if (engine.getDefaultInferenceAlgorithm().isToUseQValues()) {
			engine.setDefaultInitialAssetTableValue((float) engine.getQValuesFromScore(12050.81f));
		} else {
			engine.setDefaultInitialAssetTableValue(12050.81f);
		}
		userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// get the expected score per D for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(0); assumedStates.add(0);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(0));
		}
		
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 0x0DL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0EL, 0);
		engine.resolveQuestion(transactionKey, new Date(), 0x0FL, 0);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		for (String user : userNameToIDMap.keySet()) {
			float cash = engine.getCash(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Cash of " + user + " = " + cash,Float.isInfinite(cash) || Float.isNaN(cash));
			}
			float score = engine.scoreUserEv(userNameToIDMap.get(user), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertFalse("Score of " + user + " = " + score,Float.isInfinite(score) || Float.isNaN(score));
			}
			assertEquals("User = " + user, cash, score, ASSET_ERROR_MARGIN);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				assertTrue("User = " + user, cash > 0 && score > 0);
			}
			assertFalse("User = " + user, engine.getScoreDetails(userNameToIDMap.get(user), null, null, null).isEmpty());
			assertNotNull("User = " + user, engine.getScoreSummaryObject(userNameToIDMap.get(user), null, null, null));
			assertEquals("User = " + user, engine.getScoreSummaryObject(userNameToIDMap.get(user), null, null, null).getCash(), cash);
			assertEquals("User = " + user, engine.getScoreSummaryObject(userNameToIDMap.get(user), null, null, null).getScoreEV(), score);
		}
		
		if (engine.isToDeleteResolvedNode()) {
			assertTrue(engine.getQuestionAssumptionGroups().isEmpty());
		} else {
			assertTrue(engine.getQuestionAssumptionGroups().isEmpty());
		}
		
		// check new user
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(12050.81f, engine.getCash(Long.MAX_VALUE, null, null), ASSET_ERROR_MARGIN);
			assertEquals(12050.81f, engine.scoreUserEv(Long.MIN_VALUE, null, null), ASSET_ERROR_MARGIN);
			assertEquals(12050.81f, engine.getCash(Long.MIN_VALUE, null, null), ASSET_ERROR_MARGIN);
			assertEquals(12050.81f, engine.scoreUserEv(Long.MAX_VALUE, null, null), ASSET_ERROR_MARGIN);
		}
		assertFalse(engine.getScoreDetails(Long.MAX_VALUE, null, null, null).isEmpty());
		assertFalse(engine.getScoreDetails(Long.MIN_VALUE, null, null, null).isEmpty());
		assertNotNull(engine.getScoreSummaryObject(Long.MAX_VALUE, null, null, null));
		assertNotNull(engine.getScoreSummaryObject(Long.MIN_VALUE, null, null, null));
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			assertEquals(engine.getScoreSummaryObject(Long.MAX_VALUE, null, null, null).getCash(), 12050.81f);
			assertEquals(engine.getScoreSummaryObject(Long.MAX_VALUE, null, null, null).getScoreEV(), 12050.81f);
			assertEquals(engine.getScoreSummaryObject(Long.MIN_VALUE, null, null, null).getCash(), 12050.81f);
			assertEquals(engine.getScoreSummaryObject(Long.MIN_VALUE, null, null, null).getScoreEV(), 12050.81f);
		}
	}

	/**
	 * Runs the following trade sequence:	<br/> 
	 *	Tom1:	P(E=e1|D=d2) = 0.5  to 0.55 and P(E=e1|D=d1) = 0.55 to 0.9	<br/>
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	Eric1:	P(E=e1) = 0.65 to 0.8	<br/> 
	 *	Eric2:	P(D=d1|F=f2) = 0.52 to 0.7 <br/> 
	 *<br/> <br/> 
	 *100 of cash is added to all users before the trades.
	 * @param userNameToIDMap : this is an output argument. This map will be filled with the name
	 * and ID of the users Tom, Joe, Amy, and Eric.
	 * @return : list of actually executed trades.
	 */
	private List<AddTradeNetworkAction> createDEFNetIn1Transaction(Map<String, Long> userNameToIDMap) {
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// Let's use ID = 0 for the user Tom 
//		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Tom"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			} else {
				throw e;
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		
		// Tom bets  P(E=e1) = 0.5  to 0.55 and P(E=e1|D=d1) = .55 -> .9 simultaneously
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		newValues.add(.55f);
		newValues.add(.45f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.55, and P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				null, 
				false
			);
		

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Joe"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			} else {
				throw e;
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			);
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Amy"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			} else {
				throw e;
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			);
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			);
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Eric"), null, null);
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
			}
		} catch (IllegalStateException e) {
			if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
				// OK. This is the expected
				assertNotNull(e);
			} else {
				throw e;
			}
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			);
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
		);
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
//		return userNameToIDMap;
		Set<QuestionEvent> questionHistory = new HashSet<QuestionEvent>(engine.getQuestionHistory((long)0x0D, null, null));
		questionHistory.addAll(engine.getQuestionHistory((long)0x0E, null, null));
		questionHistory.addAll(engine.getQuestionHistory((long)0x0F, null, null));
		List<AddTradeNetworkAction> ret = new ArrayList<MarkovEngineImpl.AddTradeNetworkAction>();
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
			if (questionEvent instanceof AddTradeNetworkAction
					&& !(questionEvent instanceof DummyTradeAction)) {
				// consider only direct trades
				ret.add((AddTradeNetworkAction) questionEvent);
			}
		}
		return ret;
	}

	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#revertTrade(long, java.util.Date, java.lang.Long, java.lang.Long)}.
	 */
	public final void testRevertTrade() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		// nothing to revert yet
		assertFalse(engine.revertTrade(null, new Date(), new Date(0), null));
		
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		List<AddTradeNetworkAction> trades = this.createDEFNetIn1Transaction(userNameToIDMap );
		assertEquals(6, trades.size());
		
		// add a dummy node and dummy trade, just to add trade to a node which does not change probs of other nodes.
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0CL, 2,null);
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(0.55f); newValues.add(0.45f);
		
		// store important info about dummy trade
		Date tradesStartingWhen = new Date();
		Long userWhoMadeTradeOnC = userNameToIDMap.get((Math.random() < .25)?"Tom":(Math.random() < .25)?"Joe":(Math.random() < .25)?"Eric":"Amy");
		assertTrue("User id = " + userWhoMadeTradeOnC, userNameToIDMap.containsValue(userWhoMadeTradeOnC));
		
		// do trade
		engine.addTrade(transactionKey, tradesStartingWhen, "", userWhoMadeTradeOnC, 0x0CL, newValues , null, null, true);
		
		// add edge after trade
		if (Math.random() < .5) {
			// from 0 to some node
			if (Math.random() < .5) {
				engine.addQuestionAssumption(transactionKey, new Date(), 0x0DL, Collections.singletonList(0x0CL), null);
//				System.out.println("C->D");
			}
			if (Math.random() < .5) {
				engine.addQuestionAssumption(transactionKey, new Date(), 0x0EL, Collections.singletonList(0x0CL), null);
//				System.out.println("C->E");
			}
			if (Math.random() < .5) {
				engine.addQuestionAssumption(transactionKey, new Date(), 0x0FL, Collections.singletonList(0x0CL), null);
//				System.out.println("C->F");
			}
		} else {
			// from some node to 0
			List<Long> assumptions = new ArrayList<Long>();
			if (Math.random() < .5) {
				assumptions.add(0x0DL);
//				System.out.println("D->C");
			}
			if (Math.random() < .5) {
				assumptions.add(0x0EL);
//				System.out.println("E->C");
			}
			if (Math.random() < .5) {
				assumptions.add(0x0FL);
//				System.out.println("F->C");
			}
			engine.addQuestionAssumption(transactionKey, new Date(), 0x0CL, assumptions, null);
		}
//		List<Long> assumptions = new ArrayList<Long>();
//		assumptions.add(0x0FL);
//		engine.addQuestionAssumption(transactionKey, new Date(), 0x0CL, assumptions, null);
		engine.commitNetworkActions(transactionKey);
		
		// revert the last trade (actually, the only trade).
		transactionKey = engine.startNetworkActions();
		engine.revertTrade(transactionKey, new Date(), new Date(0), 0x0CL);	// search by question
		engine.commitNetworkActions(transactionKey);
		
		// check that the trade was reverted succesfully.
		
		// check that assets of question C is equal for everyone
		for (String userName : userNameToIDMap.keySet()) {
			List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0CL, null, null);
			assertEquals(userName, 2, assetsIfStates.size());
			assertEquals("User who made edit on C = " + userWhoMadeTradeOnC + ", current = " + userName + "(" + userNameToIDMap.get(userName)+ ") " + assetsIfStates, 
					engine.getQValuesFromScore(assetsIfStates.get(0)), 
					engine.getQValuesFromScore(assetsIfStates.get(1)),
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that final marginal of C is [0.55, 0.45] E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		List<Float> probList = engine.getProbList(0x0C, null, null);
		assertEquals(0.55f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.45f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// this map will store the conditional cashes for posterior comparison. 
		// E.g. Tom -> [Cash(d1,e1,f1),Cash(d1,e1,f2),Cash(d1,e2,f1),Cash(d1,e2,f2),Cash(d2,e1,f1),Cash(d2,e1,f2),Cash(d2,e2,f1),Cash(d2,e2,f2)]
		Map<String, List<Float>> mapOfConditionalCash = new HashMap<String, List<Float>>();
		
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		mapOfConditionalCash.put("Tom", new ArrayList<Float>());
		
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		if (Float.isNaN(cash)) {
			for (Node node : engine.getProbabilisticNetwork().getNodes()) {
				System.out.println(node.getParents() + "->" + node);
			}
			fail();
		}
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Tom").add(cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Tom").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Tom").add(cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Tom").add(cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Tom").add(cash);

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		mapOfConditionalCash.put("Amy", new ArrayList<Float>());
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Amy").add(cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Amy").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Amy").add(cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Amy").add(cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Amy").add(cash);
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		mapOfConditionalCash.put("Joe",new ArrayList<Float>());

		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Joe").add(cash);
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		mapOfConditionalCash.put("Eric",new ArrayList<Float>());

		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		mapOfConditionalCash.get("Eric").add(cash);
		
		// check that assets of question C is equal for everyone
		for (String userName : userNameToIDMap.keySet()) {
			List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0CL, null, null);
			assertEquals(userName, 2, assetsIfStates.size());
			assertFalse(Float.isInfinite(assetsIfStates.get(0)));
			assertFalse(Float.isInfinite(assetsIfStates.get(1)));
			assertEquals("User who made edit on C = " + userWhoMadeTradeOnC + ", current = " + userName + "(" + userNameToIDMap.get(userName)+ ") " + assetsIfStates, 
					engine.getQValuesFromScore(assetsIfStates.get(0)), 
					engine.getQValuesFromScore(assetsIfStates.get(1)),
					ASSET_ERROR_MARGIN
				);
		}
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float> expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}

		// resolve to d1. Resolutions are not reverted (i.e. resolutions are supposedly re-done)
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.resolveQuestion(transactionKey, new Date(), (long)0x0D, 0));
		assertTrue(engine.commitNetworkActions(transactionKey));
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check that assets of question C is equal for everyone
		for (String userName : userNameToIDMap.keySet()) {
			List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0CL, null, null);
			assertEquals(userName, 2, assetsIfStates.size());
			try {
				assertEquals("User who made edit on C = " + userWhoMadeTradeOnC + ", current = " + userName + "(" + userNameToIDMap.get(userName)+ ") " + assetsIfStates, 
						engine.getQValuesFromScore(assetsIfStates.get(0)), 
						engine.getQValuesFromScore(assetsIfStates.get(1)),
						ASSET_ERROR_MARGIN
				);
			} catch (ZeroAssetsException e) {
				e.printStackTrace();
				for (Node node : engine.getProbabilisticNetwork().getNodes()) {
					System.out.println(node.getParents() + " -> " + node);
				}
				fail(userName + " fail.");
			}
		}
		
		
		// store assetIfs in order to check them after next revert
		Map<String, List<Float>> mapOfConditionalAssetsE = new HashMap<String, List<Float>>();
		Map<String, List<Float>> mapOfConditionalAssetsF = new HashMap<String, List<Float>>();
		
		// fill mapOfConditionalAssets for Tom
		mapOfConditionalAssetsE.put("Tom", engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0EL, null, null));
		mapOfConditionalAssetsF.put("Tom", engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0FL, null, null));
		// fill mapOfConditionalAssets for Amy
		mapOfConditionalAssetsE.put("Amy", engine.getAssetsIfStates(userNameToIDMap.get("Amy"), 0x0EL, null, null));
		mapOfConditionalAssetsF.put("Amy", engine.getAssetsIfStates(userNameToIDMap.get("Amy"), 0x0FL, null, null));
		// fill mapOfConditionalAssets for Amy
		mapOfConditionalAssetsE.put("Joe", engine.getAssetsIfStates(userNameToIDMap.get("Joe"), 0x0EL, null, null));
		mapOfConditionalAssetsF.put("Joe", engine.getAssetsIfStates(userNameToIDMap.get("Joe"), 0x0FL, null, null));
		// fill mapOfConditionalAssets for Eric
		mapOfConditionalAssetsE.put("Eric", engine.getAssetsIfStates(userNameToIDMap.get("Eric"), 0x0EL, null, null));
		mapOfConditionalAssetsF.put("Eric", engine.getAssetsIfStates(userNameToIDMap.get("Eric"), 0x0FL, null, null));
		
		
		// revert the last trade of C again (actually, the only trade). This time, only specifying the date
		transactionKey = engine.startNetworkActions();
		engine.revertTrade(transactionKey, new Date(), tradesStartingWhen, null);	// search by date
		engine.commitNetworkActions(transactionKey);
		
		// check that assets of question C is equal for everyone
		for (String userName : userNameToIDMap.keySet()) {
			List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0CL, null, null);
			assertEquals(userName, 2, assetsIfStates.size());
			assertEquals("User who made edit on C = " + userWhoMadeTradeOnC + ", current = " + userName + "(" + userNameToIDMap.get(userName)+ ") " + assetsIfStates, 
					engine.getQValuesFromScore(assetsIfStates.get(0)), 
					engine.getQValuesFromScore(assetsIfStates.get(1)),
					ASSET_ERROR_MARGIN
				);
		}
		
		// make sure assets and probs are the same of the reverted one, and probabilities are the same after resolution.
		
		// check that final marginal of E is [0.9509, 0.0491], F is  [0.2416, 0.7584]
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.9509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.0491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2416f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7584f, probList.get(1), PROB_ERROR_MARGIN);
		if (engine.isToObtainProbabilityOfResolvedQuestions()) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(1f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0f, probList.get(1), PROB_ERROR_MARGIN);
		} else {
			engine.setToObtainProbabilityOfResolvedQuestions(true);
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(1f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0f, probList.get(1), PROB_ERROR_MARGIN);
			engine.setToObtainProbabilityOfResolvedQuestions(false);
		}
		
		// test that conditional cash matches the values before resolution
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0E);	assumptionIds.add((long)0x0F);
		if (!engine.isToDeleteResolvedNode()) {
			assumptionIds.add((long)0x0D);
		}
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); assumedStates.add(0); 
		if (!engine.isToDeleteResolvedNode()) {
			assumedStates.add(0);
		}
		for (int repeat = 0; repeat < 3; repeat++) {
			for (String userName : mapOfConditionalCash.keySet()) {
				if (!engine.isToDeleteResolvedNode()) {
					assumedStates.set(2, 0);	// d1
				}
				for (int i = 0; i < 4; i++) {	// combinations [e1f1,e1f2,e2f1,e2f2]
					assumedStates.set(0, (int)i/2);	// e
					assumedStates.set(1, (int)i%2);	// f
					cash = engine.getCash(userNameToIDMap.get(userName), assumptionIds, assumedStates);
					if (Float.isNaN(cash)) {
						for (Node node : engine.getProbabilisticNetwork().getNodes()) {
							System.out.println(node.getParents() + "->" + node);
						}
						fail();
					}
					assertEquals("[" + repeat + "-" + i + "] user = " + userName + ", e = " + (int)i/2 + ", f = " + (int)i%2, mapOfConditionalCash.get(userName).get(i), cash);
				}
				if (!engine.isToDeleteResolvedNode()) {
					assumedStates.set(2, 1);	// d2
					for (int i = 0; i < 4; i++) {	// combinations [e1f1d2,e1f2d2,e2f1d2,e2f2d2]
						assumedStates.set(0, (int)i/2);	// e
						assumedStates.set(1, (int)i%2);	// f
						try {
							cash = engine.getCash(userNameToIDMap.get(userName), assumptionIds, assumedStates);
							fail("[" + repeat + "-" + i + "] user = " + userName + ", e = " + (int)i/2 + ", f = " + (int)i%2 + ", cash = " + cash);
						} catch (ZeroAssetsException e) {
							// This is the expected behavior
							assertNotNull(e);
						}
					}
				} 
			}
		}
		
		// check that assets of question C is equal for everyone
		for (String userName : userNameToIDMap.keySet()) {
			List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0CL, null, null);
			assertEquals(userName, 2, assetsIfStates.size());
			assertEquals("User who made edit on C = " + userWhoMadeTradeOnC + ", current = " + userName + "(" + userNameToIDMap.get(userName)+ ") " + assetsIfStates, 
					engine.getQValuesFromScore(assetsIfStates.get(0)), 
					engine.getQValuesFromScore(assetsIfStates.get(1)),
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that assetsIfStates matches the ones before resolution
		for (String userName : userNameToIDMap.keySet()) {
			assertEquals(userName ,mapOfConditionalAssetsE.get(userName), engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0EL, null, null));
			assertEquals(userName ,mapOfConditionalAssetsF.get(userName), engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0FL, null, null));
		}
		

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}

	


	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#previewTrade(long, long, java.util.List, java.util.List, java.util.List, java.util.List)}.
	 * It just tests whether {@link MarkovEngineImpl#addTrade(long, Date, String, long, long, List, List, List, boolean)}
	 * and then {@link MarkovEngineImpl#getAssetsIfStates(long, long, List, List)}
	 * is equivalent to {@link MarkovEngineImpl#previewTrade(long, long, List, List, List)}.
	 */
	public final void testPreviewTrade() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		// crate transaction for generating the DEF network
		long transactionKey = engine.startNetworkActions();
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// commit changes
		engine.commitNetworkActions(transactionKey);
		
		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		
		// check whether probability prior to edit is really 0.5
		List<Float> probList = engine.getProbList(0x0E, null, null);
		assertEquals(2 , probList.size());
		assertEquals(0.5f , probList.get(0) , PROB_ERROR_MARGIN);
		assertEquals(0.5f , probList.get(1) , PROB_ERROR_MARGIN);
		
		
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		
		// get preview
		List<Float> preview = engine.previewTrade(userNameToIDMap.get("Tom"), 0x0E, newValues, null, null);
		assertEquals(2, preview.size());
		
		// do edit
		transactionKey = engine.startNetworkActions();
		List<Float> returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		assertEquals(engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0E, null, null), preview);
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		List<Long> assumptionIds = new ArrayList<Long>();		
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		assumedStates.add(0);	// set d1 as assumed state
		
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		
		preview = engine.previewTrade(userNameToIDMap.get("Tom"), 0x0E, newValues, assumptionIds, assumedStates);		
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		List<Float> currentAsssetsIf = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0E, assumptionIds, assumedStates);
		assertNotNull(currentAsssetsIf);
		assertEquals(preview.size(), currentAsssetsIf.size());
		for (int i = 0; i < currentAsssetsIf.size(); i++) {
			assertEquals(currentAsssetsIf.get(i), preview.get(i), ASSET_ERROR_MARGIN);
		}

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.9, .1, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(E=e1|D=d2) should be [0.0055, 0.9955]
		
		// set P(E=e1|D=d2) = 0.4 and P(E=e2|D=d2) = 0.6
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		
		// obtain preview
		preview = engine.previewTrade(userNameToIDMap.get("Joe"), 0x0E, newValues, assumptionIds, assumedStates);		
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		currentAsssetsIf = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), 0x0E, assumptionIds, assumedStates);
		assertNotNull(currentAsssetsIf);
		assertEquals(preview.size(), currentAsssetsIf.size());
		for (int i = 0; i < currentAsssetsIf.size(); i++) {
			assertEquals(currentAsssetsIf.get(i), preview.get(i), ASSET_ERROR_MARGIN);
		}

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.5, .5, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		assumedStates.add(0);	// set d1 as assumed state
		
		
		// set P(F=f1|D=d1) = 0.3 and P(F=f2|D=d1) = 0.7  
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		

		// obtain preview
		preview = engine.previewTrade(userNameToIDMap.get("Amy"), 0x0F, newValues, assumptionIds, assumedStates);		
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		currentAsssetsIf = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), 0x0F, assumptionIds, assumedStates);
		assertNotNull(currentAsssetsIf);
		assertEquals(preview.size(), currentAsssetsIf.size());
		for (int i = 0; i < currentAsssetsIf.size(); i++) {
			assertEquals(currentAsssetsIf.get(i), preview.get(i), ASSET_ERROR_MARGIN);
		}
		
		// Joe bets P(F=f1|D=d2) = .5 -> .1
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.3, .7, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		assumedStates.add(1);	// set d2 as assumed state
		
		
		// set P(F=f1|D=d2) = 0.1 and P(F=f2|D=d2) = 0.9
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		

		// obtain preview
		preview = engine.previewTrade(userNameToIDMap.get("Joe"), 0x0F, newValues, assumptionIds, assumedStates);		
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		currentAsssetsIf = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), 0x0F, assumptionIds, assumedStates);
		assertNotNull(currentAsssetsIf);
		assertEquals(preview.size(), currentAsssetsIf.size());
		for (int i = 0; i < currentAsssetsIf.size(); i++) {
			assertEquals(currentAsssetsIf.get(i), preview.get(i), ASSET_ERROR_MARGIN);
		}

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		transactionKey = engine.startNetworkActions();
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		engine.commitNetworkActions(transactionKey);
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);

		
		// Eric bets P(E=e1) = .65 -> .8
		
		// check whether probability prior to edit is really = [.65, .35]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		
		// set P(E=e1) = 0.8 and P(E=e2) = 0.2
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		

		// obtain preview
		preview = engine.previewTrade(userNameToIDMap.get("Eric"), 0x0E, newValues, assumptionIds, assumedStates);		
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		currentAsssetsIf = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), 0x0E, assumptionIds, assumedStates);
		assertNotNull(currentAsssetsIf);
		assertEquals(preview.size(), currentAsssetsIf.size());
		for (int i = 0; i < currentAsssetsIf.size(); i++) {
			assertEquals(currentAsssetsIf.get(i), preview.get(i), ASSET_ERROR_MARGIN);
		}
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		
		// check whether probability prior to edit is really [d1f2, d2f2] = [.52, .48]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		
		
		// set P(D=d1|F=f2) = 0.7 and P(D=d2|F=f2) = 0.3
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		

		// obtain preview
		preview = engine.previewTrade(userNameToIDMap.get("Eric"), 0x0D, newValues, assumptionIds, assumedStates);		
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
		);
		engine.commitNetworkActions(transactionKey);
		
		// check if preview and value returned from trade matches
		assertEquals(returnFromTrade.size(), preview.size());
		assertEquals(returnFromTrade, preview);
		
		// check if preview matches current getAssetsIf
		currentAsssetsIf = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), 0x0D, assumptionIds, assumedStates);
		assertNotNull(currentAsssetsIf);
		assertEquals(preview.size(), currentAsssetsIf.size());
		for (int i = 0; i < currentAsssetsIf.size(); i++) {
			assertEquals(currentAsssetsIf.get(i), preview.get(i), ASSET_ERROR_MARGIN);
		}

		// Eric makes a bet which makes his assets-q to go below 1, but the algorithm does not allow it
		// this is a case in which preview != actual (because the actual trade will not be executed)
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		List<Float> editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		

		// obtain preview
		preview = engine.previewTrade(userNameToIDMap.get("Eric"), 0x0D, newValues, assumptionIds, assumedStates);
		// check that some of the preview has 0 or negative assets
		try {
			boolean found = false;
			for (Float previewedAsset : preview) {
				if (previewedAsset <= 0) {
					found = true;
					break;
				}
			}
			assertTrue("Previewed asset is " + preview, found);
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		List<Float> assetsIfBeforeNegativeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), 0x0D, assumptionIds, assumedStates);
		
		transactionKey = engine.startNetworkActions();
		returnFromTrade = engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false	// do not allow negative assets
			);
		
		// engine.addTrade must return nothing when previewed value is negative and it is not allowed to use negative assets
		assertNull(returnFromTrade);
		
		// by committing an empty transaction, we can remove transaction from memory
		engine.commitNetworkActions(transactionKey);
		
		// check if preview does not match current getAssetsIf (which is )
		List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), 0x0D, assumptionIds, assumedStates);
		assertEquals(assetsIfBeforeNegativeTrade, assetsIfStates);
		assertFalse("Preview = " + preview + ", returned = " + assetsIfStates, assetsIfStates.equals(preview));


		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}


	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#scoreUserEV(java.util.List, java.util.List, java.util.List)}.
	 */
	public final void testScoreUserEV() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		
		// generate DEF net
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		engine.setDefaultInitialAssetTableValue(1000);
		// most basic assertion
		assertEquals(10.31615, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		List<Float> scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(10L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(2, scoreUserQuestionEvStates.size());
		assertEquals(1000f, scoreUserQuestionEvStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1000f, scoreUserQuestionEvStates.get(1), ASSET_ERROR_MARGIN);
		
		for (String user : userNameToIDMap.keySet()) {
			boolean hasAtLeastOneCombinationWithDifferentValues = false;
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0DL, null, null);
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
				|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
				|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
				
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0EL, null, null);
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0FL, null, null);
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
			assertEquals(2, scoreUserQuestionEvStates.size());
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
			assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
			hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
			|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
			|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			
			
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			for (int i = 0; i < 4; i++) {
				List<Integer> assumedStates = new ArrayList<Integer>();
				assumedStates.add(i%2); assumedStates.add((int) ((i/2.0)%2.0));
				scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0DL, assumptionIds, assumedStates);
				assertEquals(2, scoreUserQuestionEvStates.size());
				assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
				assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
				hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
					|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
					|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			}

			assumptionIds.set(0,0x0DL); assumptionIds.set(1,0x0FL);
			for (int i = 0; i < 4; i++) {
				List<Integer> assumedStates = new ArrayList<Integer>();
				assumedStates.add(i%2); assumedStates.add((int) ((i/2.0)%2.0));
				scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0EL, assumptionIds, assumedStates);
				assertEquals(2, scoreUserQuestionEvStates.size());
				assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > 0);
				assertTrue(user + "," + scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(1) > 0);
				hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
				|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
				|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			}
			
			assumptionIds.set(0,0x0DL); assumptionIds.set(1,0x0EL);
			for (int i = 0; i < 4; i++) {
				List<Integer> assumedStates = new ArrayList<Integer>();
				assumedStates.add(i%2); assumedStates.add((int) ((i/2.0)%2.0));
				scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(userNameToIDMap.get(user), 0x0FL, assumptionIds, assumedStates);
				assertEquals(2, scoreUserQuestionEvStates.size());
				hasAtLeastOneCombinationWithDifferentValues = hasAtLeastOneCombinationWithDifferentValues
				|| scoreUserQuestionEvStates.get(0) - ASSET_ERROR_MARGIN > scoreUserQuestionEvStates.get(1) 
				|| scoreUserQuestionEvStates.get(0) < scoreUserQuestionEvStates.get(1) - ASSET_ERROR_MARGIN;
			}
			assertTrue(user, hasAtLeastOneCombinationWithDifferentValues);
		}
		
		// TODO implement more test cases
		
		engine.initialize();
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		if (engine.getDefaultInferenceAlgorithm().isToUseQValues()) {
			engine.setDefaultInitialAssetTableValue((float) engine.getQValuesFromScore(1000));
		} else {
			engine.setDefaultInitialAssetTableValue(1000);
		}
		
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 1L, 2, null);
		engine.commitNetworkActions(transactionKey);

		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 2L, 2, null);
		engine.addQuestionAssumption(transactionKey, new Date(), 2L, Collections.singletonList(1L), null);
		engine.commitNetworkActions(transactionKey);
		
		assertEquals(1000f, engine.getCash(1L, null, null), ASSET_ERROR_MARGIN);
		assertEquals(1000f, engine.scoreUserEv(1L, null, null), ASSET_ERROR_MARGIN);
		scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(2L, 2L, Collections.singletonList(1L), Collections.singletonList(1));
		assertEquals(2, scoreUserQuestionEvStates.size());
		assertEquals(1000f, scoreUserQuestionEvStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1000f, scoreUserQuestionEvStates.get(1), ASSET_ERROR_MARGIN);
		
		
		transactionKey = engine.startNetworkActions();
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.8f); newValues.add(.2f);
		engine.addTrade(transactionKey, new Date(), "", 1L, 1L, newValues , null, null, false);
		engine.commitNetworkActions(transactionKey);
		
		scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(1L, 1L, Collections.singletonList(2L), Collections.singletonList(0));
		assertEquals(2, scoreUserQuestionEvStates.size());
		assertTrue(scoreUserQuestionEvStates.toString(), scoreUserQuestionEvStates.get(0) > scoreUserQuestionEvStates.get(1));
		assertEquals(1067.8073f, scoreUserQuestionEvStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(867.8072f, scoreUserQuestionEvStates.get(1), ASSET_ERROR_MARGIN);
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 1L, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 1L, null, null).get(0));
		}
		
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 1L, 0);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		assertFalse(Float.isNaN(engine.scoreUserEv(1L, null, null)));
		assertEquals(1067.8073, engine.scoreUserEv(1L, null, null), ASSET_ERROR_MARGIN);

		scoreUserQuestionEvStates = engine.scoreUserQuestionEvStates(1L, 2L, null, null);
		assertEquals(2, scoreUserQuestionEvStates.size());
		assertEquals(1067.8073f, scoreUserQuestionEvStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1067.8073f, scoreUserQuestionEvStates.get(1), ASSET_ERROR_MARGIN);
		
		assertEquals(0f, engine.scoreUserQuestionEvStates(1L, 2L, Collections.singletonList(2L), Collections.singletonList(0)).get(1), PROB_ERROR_MARGIN);
		assertEquals(0f, engine.scoreUserQuestionEvStates(1L, 2L, Collections.singletonList(2L), Collections.singletonList(1)).get(0), PROB_ERROR_MARGIN);
		assertEquals(engine.scoreUserEv(1L, Collections.singletonList(2L), Collections.singletonList(0)), 
				engine.scoreUserQuestionEvStates(1L, 2L, Collections.singletonList(2L), Collections.singletonList(0)).get(0), ASSET_ERROR_MARGIN);
		assertEquals(engine.scoreUserEv(1L, Collections.singletonList(2L), Collections.singletonList(1)), 
				engine.scoreUserQuestionEvStates(1L, 2L, Collections.singletonList(2L), Collections.singletonList(1)).get(1), ASSET_ERROR_MARGIN);
		
		
		// simple disconnected network cases
		engine.initialize();
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		if (engine.getDefaultInferenceAlgorithm().isToUseQValues()) {
			engine.setDefaultInitialAssetTableValue((float) engine.getQValuesFromScore(1000));
		} else {
			engine.setDefaultInitialAssetTableValue(1000);
		}
		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 1L, 2, null);
		engine.addQuestion(transactionKey, new Date(), 2L, 2, null);
		engine.commitNetworkActions(transactionKey);
		
		assertEquals(1000f, engine.scoreUserEv(1L, null, null), ASSET_ERROR_MARGIN);
		
		
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 1L, null, null).get(1));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 1L, null, null).get(1));
		}
		
		transactionKey = engine.startNetworkActions();
		newValues = new ArrayList<Float>();
		newValues.add(.2f); newValues.add(.8f);
		engine.addTrade(transactionKey, new Date(), "", 1L, 1L, newValues, null, null, false);
		engine.resolveQuestion(transactionKey, new Date(), 1L, 1);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		assertEquals(1638.4f, engine.getQValuesFromScore(engine.scoreUserEv(1L, null, null)), ASSET_ERROR_MARGIN);
		assertEquals(engine.getScoreFromQValues(1638.4f), engine.scoreUserEv(1L, null, null), ASSET_ERROR_MARGIN);
		
		
		engine.initialize();
		
		engine.setDefaultInitialAssetTableValue(1000);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		
		engine.addQuestion(null, new Date(), 0x0DL, 2, null);
		engine.addQuestion(null, new Date(), 0x0EL, 2, null);
		engine.addQuestion(null, new Date(), 0x0FL, 2, null);
		engine.addQuestionAssumption(null, new Date(), 0x0EL, Collections.singletonList(0x0DL), null);
		engine.addQuestionAssumption(null, new Date(), 0x0FL, Collections.singletonList(0x0DL), null);
		
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		engine.addTrade(
				null, 
				new Date(), 
				"User 2 trades P(F) = " + newValues, 
				2L, 
				0x0FL, 
				newValues, 
				null, 
				null, 
				false
		);
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(
				null, 
				new Date(), 
				"User 1 trades P(F) = " + newValues, 
				1L, 
				0x0FL, 
				newValues, 
				null, 
				null, 
				false
			);
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		newValues.add(.9f);
		newValues.add(.1f);
		engine.addTrade(
				null, 
				new Date(), 
				"User 2 trades P(F|D) = " + newValues, 
				2L, 
				0x0FL, 
				newValues, 
				Collections.singletonList(0x0DL), 
				null, 
				false
		);
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		newValues.add(.9f);
		newValues.add(.1f);
		engine.addTrade(
				null, 
				new Date(), 
				"User 2 trades P(D|E) = "+newValues, 
				2L, 
				0x0DL, 
				newValues, 
				Collections.singletonList(0x0EL), 
				null, 
				false
		);
		List<Float> evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null);
		assertFalse(evStates.toString(), Math.abs(evStates.get(0)-evStates.get(1))<ASSET_ERROR_MARGIN);
		

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#getScoreSummary(long, List, List)}
	 */
	public final void testGetScoreSummary() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		engine.setToReturnEVComponentsAsScoreSummary(true);
		
		// generate DEF net
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		// extract summary
		ScoreSummary summary = engine.getScoreSummaryObject(userNameToIDMap.get("Eric"), null, null, null);
		
		// extract summary in a property format
		List<Properties> summaryProperty = engine.getScoreSummary(userNameToIDMap.get("Eric"), null, null, null);
		
		// most basic assertions
		assertEquals(engine.getCash(userNameToIDMap.get("Eric"), null, null), summary.getCash(), ASSET_ERROR_MARGIN);
		assertEquals(engine.getCash(userNameToIDMap.get("Eric"), null, null), Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.CASH_PROPERTY)), ASSET_ERROR_MARGIN);
		assertEquals(10.31615, summary.getScoreEV(), PROB_ERROR_MARGIN);
		assertEquals(10.31615, Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY)), PROB_ERROR_MARGIN);
		assertEquals(8,summary.getScoreComponents().size());
		assertEquals(8,Integer.parseInt(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCORE_COMPONENT_SIZE_PROPERTY)));
		assertEquals(2,summary.getIntersectionScoreComponents().size());
		assertEquals(	
				2,							// the size of intersection component is...
				 summaryProperty.size()		// ...total size...
				- 1							// ...minus the root property (which contains the cash, score, and the size of score component)
				- Integer.parseInt(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCORE_COMPONENT_SIZE_PROPERTY))	// minus the (positive) score components
			);
		
		
		// assert that the aggregation of contributions will result in the total expected score
		float sum = 0f;
		for (SummaryContribution positiveContribution : summary.getScoreComponents()) {
			sum += positiveContribution.getContributionToScoreEV();
		}
		for (SummaryContribution negativeContribution : summary.getIntersectionScoreComponents()) {
			sum += negativeContribution.getContributionToScoreEV();
		}
		assertEquals(summary.getScoreEV(), sum, PROB_ERROR_MARGIN);
		
		sum = 0f;
		for (int i = 1; i < summaryProperty.size(); i++) {
			sum += Float.parseFloat(summaryProperty.get(i).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY));
		}
		assertEquals(summary.getScoreEV(), sum, PROB_ERROR_MARGIN);
		
		// the separator D must be present at all the components
		for (SummaryContribution contribution : summary.getIntersectionScoreComponents()) {
			assertTrue(
					"Questions = " + contribution.getQuestions()
					+ ", states = " + contribution.getStates()
					+ ", value = " + contribution.getContributionToScoreEV(), 
					summary.getIntersectionScoreComponents().get(0).getQuestions().contains(0x0DL)
				);
		}
		for (SummaryContribution contribution : summary.getScoreComponents()) {
			assertTrue(
					"Questions = " + contribution.getQuestions()
					+ ", states = " + contribution.getStates()
					+ ", value = " + contribution.getContributionToScoreEV(), 
					summary.getIntersectionScoreComponents().get(0).getQuestions().contains(0x0DL)
				);
		}
		for (int i = 1; i < summaryProperty.size(); i++) {
			assertTrue(
					"Questions = " + summaryProperty.get(i).getProperty(MarkovEngineInterface.QUESTIONS_PROPERTY)
					+ ", states = " + summaryProperty.get(i).getProperty(MarkovEngineInterface.STATES_PROPERTY)
					+ ", value = " + summaryProperty.get(i).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY), 
					summaryProperty.get(i).getProperty(MarkovEngineInterface.QUESTIONS_PROPERTY).contains("13")
			);
		}
		
		assertNotNull(engine.getScoreSummaryObject(userNameToIDMap.get("Tom"), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1)));
		assertNotNull(engine.getScoreSummary(userNameToIDMap.get("Tom"), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1)));
		
		// test the case in which the score summary contains expected score given states
		engine.setToReturnEVComponentsAsScoreSummary(false);
		
		// basic test: value of eric's score summary is unchanged
		assertEquals(10.31615, engine.getScoreSummaryObject(userNameToIDMap.get("Eric"), null, null, null).getScoreEV(), PROB_ERROR_MARGIN);
		assertEquals(10.31615, Float.parseFloat(engine.getScoreSummary(userNameToIDMap.get("Eric"), null, null, null).get(0).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY)), PROB_ERROR_MARGIN);
		
		// extract marginal probability of each question so that we can use them later for consistency check
		Map<Long, List<Float>> marginals = engine.getProbLists(null, null, null);
		assertEquals(marginals.toString(), 3, marginals.keySet().size());	// must be marginals of 3 questions
		for (Long key : marginals.keySet()) {
			assertEquals(marginals.toString(), 2, marginals.get(key).size());	// must be nodes with 2 states
		}
		
		// add user who did not do any trade in userNameToIDMap in order to test boundary condition (users with no trades at all)
		userNameToIDMap.put("User with no trade " + Long.MIN_VALUE, Long.MIN_VALUE);
		
		for (String user : userNameToIDMap.keySet()) {
			// extract new summary
			summary = engine.getScoreSummaryObject(userNameToIDMap.get(user), null, null, null);
			
			// most basic assertions
			assertEquals(user, engine.getCash(userNameToIDMap.get(user), null, null), summary.getCash(), ASSET_ERROR_MARGIN);
			assertEquals(user, engine.scoreUserEv(userNameToIDMap.get(user), null, null), summary.getScoreEV(), ASSET_ERROR_MARGIN);
			
			
			// check that getQuestions of summary.getScoreComponents retains the same ordering of engine.getTradedQuestions
			List<Long> tradedQuestions = new ArrayList<Long>(engine.getTradedQuestions(userNameToIDMap.get(user)));
//			assertFalse(user, tradedQuestions.isEmpty());	// users did actually trade in the system, so its not empty
			assertEquals(user, tradedQuestions.size(), summary.getScoreComponents().size()/2);	// Note: I'm assuming each question has 2 states
			for (int questionIndex = 0; questionIndex < tradedQuestions.size(); questionIndex++) {
				
				sum = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
				
				for (int stateIndex = 0; stateIndex < marginals.get(tradedQuestions.get(questionIndex)).size(); stateIndex++) {
					
					// Note: I'm assuming that all nodes have 2 states
					int scoreComponentIndex = questionIndex*2 + stateIndex;	
					
					// assert that getScoreComponents is related to current question
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							1, summary.getScoreComponents().get(scoreComponentIndex).getQuestions().size());
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							tradedQuestions.get(questionIndex),
							summary.getScoreComponents().get(scoreComponentIndex).getQuestions().get(0)
					);
					
					// assert that getScoreComponents is related to current state
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							1, summary.getScoreComponents().get(scoreComponentIndex).getStates().size() );
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							stateIndex,
							summary.getScoreComponents().get(scoreComponentIndex).getStates().get(0).intValue()
					);
					
					// multiply marginal (of this state of this question) and expected score of this state of this question
					sum += marginals.get(tradedQuestions.get(questionIndex)).get(stateIndex) // marginal
						* summary.getScoreComponents().get(scoreComponentIndex).getContributionToScoreEV();	 // expected
				}
				
				// assert that, for each question, the sum of expected score per state multiplied by its marginal will result in the total expected score
				// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
				assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex), summary.getScoreEV(), sum, PROB_ERROR_MARGIN);
			}
		}
		
		// dispose summary
		summary = null;
		
		// add user who did not do any trade in userNameToIDMap in order to test boundary condition (users with no trades at all)
		userNameToIDMap.put("User with no trade " + Long.MIN_VALUE+1, Long.MIN_VALUE+1);
		
		for (String user : userNameToIDMap.keySet()) {
			// extract new summary
			summaryProperty = engine.getScoreSummary(userNameToIDMap.get(user), null, null, null);
			
			// most basic assertions
			assertEquals(user, engine.getCash(userNameToIDMap.get(user), null, null), Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.CASH_PROPERTY)), ASSET_ERROR_MARGIN);
			assertEquals(user, engine.scoreUserEv(userNameToIDMap.get(user), null, null), Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY)), ASSET_ERROR_MARGIN);
			
			
			// check that getQuestions of summary.getScoreComponents retains the same ordering of engine.getTradedQuestions
			List<Long> tradedQuestions = new ArrayList<Long>(engine.getTradedQuestions(userNameToIDMap.get(user)));
			
			assertEquals(user, tradedQuestions.size(), Integer.parseInt(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCORE_COMPONENT_SIZE_PROPERTY))/2);	// Note: I'm assuming each question has 2 states
			
			for (int questionIndex = 0; questionIndex < tradedQuestions.size(); questionIndex++) {
				
				sum = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
				
				for (int stateIndex = 0; stateIndex < marginals.get(tradedQuestions.get(questionIndex)).size(); stateIndex++) {
					
					// Note: I'm assuming that all nodes have 2 states
					int scoreComponentIndex = (questionIndex*2 + stateIndex) + 1;	// +1 because the root contains cash, score, and size of components	
					
					String question = summaryProperty.get(scoreComponentIndex).getProperty(MarkovEngineInterface.QUESTIONS_PROPERTY);
					// assert that getScoreComponents is related to current question
					assertFalse("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							question.contains(","));
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							tradedQuestions.get(questionIndex).longValue(),
							Long.parseLong(question)
					);
					
					// assert that getScoreComponents is related to current state
					String state = summaryProperty.get(scoreComponentIndex).getProperty(MarkovEngineInterface.STATES_PROPERTY);
					assertFalse("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							state.contains(",") );
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
							stateIndex,
							Integer.parseInt(state)
					);
					
					// multiply marginal (of this state of this question) and expected score of this state of this question
					sum += marginals.get(tradedQuestions.get(questionIndex)).get(stateIndex) // marginal
					* Float.parseFloat(summaryProperty.get(scoreComponentIndex).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY));	 // expected
				}
				
				// assert that, for each question, the sum of expected score per state multiplied by its marginal will result in the total expected score
				// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
				assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex), 
						Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY)), sum, PROB_ERROR_MARGIN);
			}
		}
		
		// make the same test, but for a random single node
		Long selectedNode = (Math.random()<.3?0x0Fl:(Math.random()<.3?0x0El:0x0Dl));
		// extract marginal probability of each question so that we can use them later for consistency check
		marginals = engine.getProbLists(null, null, null);
		assertEquals(marginals.toString(), 3, marginals.keySet().size());	// must be marginals of 1 question (the selected one)
		for (Long key : marginals.keySet()) {
			assertEquals(marginals.toString(), 2, marginals.get(key).size());	// must be nods with 2 states
		}
		
		// add user who did not do any trade in userNameToIDMap in order to test boundary condition (users with no trades at all)
		userNameToIDMap.put("User with no trade " + Long.MAX_VALUE, Long.MAX_VALUE);
		
		for (String user : userNameToIDMap.keySet()) {
			// extract new summary
			summary = engine.getScoreSummaryObject(userNameToIDMap.get(user), selectedNode, null, null);
			summaryProperty = engine.getScoreSummary(userNameToIDMap.get(user), selectedNode, null, null);
			
			// most basic assertions
			assertEquals(user, engine.getCash(userNameToIDMap.get(user), null, null), summary.getCash(), ASSET_ERROR_MARGIN);
			assertEquals(user, engine.scoreUserEv(userNameToIDMap.get(user), null, null), summary.getScoreEV(), ASSET_ERROR_MARGIN);
			assertEquals(user, engine.getCash(userNameToIDMap.get(user), null, null), Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.CASH_PROPERTY)), ASSET_ERROR_MARGIN);
			assertEquals(user, engine.scoreUserEv(userNameToIDMap.get(user), null, null),  Float.parseFloat(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCOREEV_PROPERTY)), ASSET_ERROR_MARGIN);
			
			
			// check that getQuestions of summary.getScoreComponents retains the same ordering of engine.getTradedQuestions
//			List<Long> tradedQuestions = engine.getTradedQuestions(userNameToIDMap.get(user));
//			assertFalse(user, tradedQuestions.isEmpty());	// users did actually trade in the system, so its not empty
			assertEquals(user, 1, summary.getScoreComponents().size()/2);	// This time I'm considering only 1 question. Note: again, I'm assuming each question has 2 states
			assertEquals(user, 1, Integer.parseInt(summaryProperty.get(0).getProperty(MarkovEngineInterface.SCORE_COMPONENT_SIZE_PROPERTY))/2);	// This time I'm considering only 1 question. Note: again, I'm assuming each question has 2 states
			
			sum = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
			
			for (int stateIndex = 0; stateIndex < marginals.get(selectedNode).size(); stateIndex++) {
				
				// assert that getScoreComponents is related to current question
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex, 
						1, summary.getScoreComponents().get(stateIndex).getQuestions().size());
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex, 
						selectedNode, summary.getScoreComponents().get(stateIndex).getQuestions().get(0) );
				
				// assert that getScoreComponents is related to current state
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex, 
						1, summary.getScoreComponents().get(stateIndex).getStates().size() );
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex, 
						stateIndex, summary.getScoreComponents().get(stateIndex).getStates().get(0).intValue() );
				
				// multiply marginal (of this state of this question) and expected score of this state of this question
				sum += marginals.get(selectedNode).get(stateIndex) // marginal
				* summary.getScoreComponents().get(stateIndex).getContributionToScoreEV();	 // expected
			}
			
			// assert that, for each question, the sum of expected score per state multiplied by its marginal will result in the total expected score
			// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
			assertEquals("user = " + user + ", question = " + selectedNode, summary.getScoreEV(), sum, PROB_ERROR_MARGIN);
		}
		
		// repeat the same test, but now using assumptions
		List<Long> assumptionIds = new ArrayList<Long>();
		List<Integer> assumedStates = new ArrayList<Integer>();
		if (Math.random() < .25) {
			assumptionIds.add(0x0Dl);
			assumedStates.add((Math.random()<.5)?0:1);
		}
		if (Math.random() < .25) {
			assumptionIds.add(0x0El);
			assumedStates.add((Math.random()<.5)?0:1);
		}
		if (Math.random() < .25) {
			assumptionIds.add(0x0Fl);
			assumedStates.add((Math.random()<.5)?0:1);
		}
		
		// extract marginal probability of each question so that we can use them later for consistency check
		marginals = engine.getProbLists(null, assumptionIds, assumedStates);
		assertEquals(marginals.toString()+ ", assumptions = " + assumptionIds + assumedStates, 3, marginals.keySet().size());	// must be marginals of 3 questions
		for (Long key : marginals.keySet()) {
			assertEquals(marginals.toString() + ", assumptions = " + assumptionIds + assumedStates, 2, marginals.get(key).size());	// must be nods with 2 states
		}
		
		// add user who did not do any trade in userNameToIDMap in order to test boundary condition (users with no trades at all)
		userNameToIDMap.put("User with no trade " + (Long.MAX_VALUE-1), Long.MAX_VALUE-1);
		
		for (String user : userNameToIDMap.keySet()) {
			// extract new summary
			try {
				summary = engine.getScoreSummaryObject(userNameToIDMap.get(user), null, assumptionIds, assumedStates);
			} catch (IllegalStateException e) {
				e.printStackTrace();
				fail("["+user+"]"+selectedNode+" : "+assumptionIds+"="+assumedStates);
			}
			
			// most basic assertions
			assertEquals(user+ ", assumptions = " + assumptionIds + assumedStates, engine.getCash(userNameToIDMap.get(user), assumptionIds, assumedStates), summary.getCash(), ASSET_ERROR_MARGIN);
			assertEquals(user+ ", assumptions = " + assumptionIds + assumedStates, engine.scoreUserEv(userNameToIDMap.get(user), assumptionIds, assumedStates), summary.getScoreEV(), ASSET_ERROR_MARGIN);
			
			
			// check that getQuestions of summary.getScoreComponents retains the same ordering of engine.getTradedQuestions
			List<Long> tradedQuestions = new ArrayList<Long>(engine.getTradedQuestions(userNameToIDMap.get(user)));
//			assertFalse(user+ ", assumptions = " + assumptionIds + assumedStates, tradedQuestions.isEmpty());	// users did actually trade in the system, so its not empty
			assertEquals(user+ ", assumptions = " + assumptionIds + assumedStates, tradedQuestions.size(), summary.getScoreComponents().size()/2);	// Note: I'm assuming each question has 2 states
			for (int questionIndex = 0; questionIndex < tradedQuestions.size(); questionIndex++) {
				
				sum = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
				
				for (int stateIndex = 0; stateIndex < marginals.get(tradedQuestions.get(questionIndex)).size(); stateIndex++) {
					
					// Note: I'm assuming that all nodes have 2 states
					int scoreComponentIndex = questionIndex*2 + stateIndex;	
					
					// assert that getScoreComponents is related to current question
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex
							+ ", assumptions = " + assumptionIds + assumedStates, 
							1, summary.getScoreComponents().get(scoreComponentIndex).getQuestions().size());
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) 
							+ ", state = " + stateIndex+ ", assumptions = " + assumptionIds + assumedStates, 
							tradedQuestions.get(questionIndex),
							summary.getScoreComponents().get(scoreComponentIndex).getQuestions().get(0)
					);
					
					// assert that getScoreComponents is related to current state
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) 
							+ ", state = " + stateIndex+ ", assumptions = " + assumptionIds + assumedStates, 
							1, summary.getScoreComponents().get(scoreComponentIndex).getStates().size() );
					assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex) 
							+ ", state = " + stateIndex+ ", assumptions = " + assumptionIds + assumedStates, 
							stateIndex,
							summary.getScoreComponents().get(scoreComponentIndex).getStates().get(0).intValue()
					);
					
					// multiply marginal (of this state of this question) and expected score of this state of this question
					sum += marginals.get(tradedQuestions.get(questionIndex)).get(stateIndex) // marginal
						* summary.getScoreComponents().get(scoreComponentIndex).getContributionToScoreEV();	 // expected
				}
				
				// assert that, for each question, the sum of expected score per state multiplied by its marginal will result in the total expected score
				// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
				assertEquals("user = " + user + ", question = " + tradedQuestions.get(questionIndex)
						+ ", assumptions = " + assumptionIds + assumedStates, 
						summary.getScoreEV(), sum, PROB_ERROR_MARGIN);
			}
			
		}
		
		// make the same test, but for a random single node and assumptions
		selectedNode = (Math.random()<.3?0x0Fl:(Math.random()<.3?0x0El:0x0Dl));
		
		// extract marginal probability of each question so that we can use them later for consistency check
		marginals = engine.getProbLists(null, assumptionIds, assumedStates);
		assertEquals(marginals.toString()+ ", assumptions = " + assumptionIds + assumedStates, 3, marginals.keySet().size());	// must be marginals of 1 question (the selected one)
		for (Long key : marginals.keySet()) {
			assertEquals(marginals.toString()+ ", assumptions = " + assumptionIds + assumedStates, 2, marginals.get(key).size());	// must be nods with 2 states
		}
		
		// add user who did not do any trade in userNameToIDMap in order to test boundary condition (users with no trades at all)
		userNameToIDMap.put("User with no trade " + (Long.MIN_VALUE+1), Long.MIN_VALUE + 1);
		
		for (String user : userNameToIDMap.keySet()) {
			// extract new summary
			summary = engine.getScoreSummaryObject(userNameToIDMap.get(user), selectedNode, assumptionIds, assumedStates);
			
			// most basic assertions
			assertEquals(user+ ", assumptions = " + assumptionIds + assumedStates, engine.getCash(userNameToIDMap.get(user), assumptionIds, assumedStates), summary.getCash(), ASSET_ERROR_MARGIN);
			assertEquals(user+ ", assumptions = " + assumptionIds + assumedStates, engine.scoreUserEv(userNameToIDMap.get(user), assumptionIds, assumedStates), summary.getScoreEV(), ASSET_ERROR_MARGIN);
			
			
			// check that getQuestions of summary.getScoreComponents retains the same ordering of engine.getTradedQuestions
//			List<Long> tradedQuestions = engine.getTradedQuestions(userNameToIDMap.get(user));
//			assertFalse(user+ ", assumptions = " + assumptionIds + assumedStates, tradedQuestions.isEmpty());	// users did actually trade in the system, so its not empty
			assertEquals(user+ ", assumptions = " + assumptionIds + assumedStates, 1, summary.getScoreComponents().size()/2);	// This time I'm considering only 1 question. Note: again, I'm assuming each question has 2 states
			
			sum = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
			
			for (int stateIndex = 0; stateIndex < marginals.get(selectedNode).size(); stateIndex++) {
				
				// assert that getScoreComponents is related to current question
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex
						+ ", assumptions = " + assumptionIds + assumedStates, 
						1, summary.getScoreComponents().get(stateIndex).getQuestions().size());
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex
						+ ", assumptions = " + assumptionIds + assumedStates, 
						selectedNode, summary.getScoreComponents().get(stateIndex).getQuestions().get(0) );
				
				// assert that getScoreComponents is related to current state
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex
						+ ", assumptions = " + assumptionIds + assumedStates, 
						1, summary.getScoreComponents().get(stateIndex).getStates().size() );
				assertEquals("user = " + user + ", question = " + selectedNode + ", state = " + stateIndex
						+ ", assumptions = " + assumptionIds + assumedStates, 
						stateIndex, summary.getScoreComponents().get(stateIndex).getStates().get(0).intValue() );
				
				// multiply marginal (of this state of this question) and expected score of this state of this question
				sum += marginals.get(selectedNode).get(stateIndex) // marginal
				* summary.getScoreComponents().get(stateIndex).getContributionToScoreEV();	 // expected
			}
			
			// assert that, for each question, the sum of expected score per state multiplied by its marginal will result in the total expected score
			// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
			assertEquals("user = " + user + ", question = " + selectedNode
					+ ", assumptions = " + assumptionIds + assumedStates, 
					summary.getScoreEV(), sum, PROB_ERROR_MARGIN);
		}
		
		
		// TODO implement more test cases

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Test method for {@link edu.gmu.ace.daggre.MarkovEngineImpl#getQuestionHistory(java.lang.Long, java.util.List, java.util.List)}.
	 */
	public final void testGetQuestionHistory() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// temporary disable storage of cliques in the history
		engine.setMaxConditionalProbHistorySize(0);
		
		// test inconditional history on DEF network first
		assertEquals(0, engine.getQuestionHistory(null, null, null).size());
		
		// the engine will retrieve any action related to a question
		engine.setToRetriveOnlyTradeHistory(false);
		
		// generate DEF net
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		// check history of actions not related to any question
		int sum = engine.getQuestionHistory(null, null, null).size();
		// there were 4 addCash
		assertEquals(4, engine.getQuestionHistory(null, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(null, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !( (questionEvent instanceof VirtualTradeAction) && (((VirtualTradeAction)questionEvent).getParentAction() instanceof ResolveQuestionNetworkAction))) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		// check history of actions related each question
		sum += engine.getQuestionHistory(0x0DL, null, null).size();
		sum -= 1;	// do not count the indirect trad in the sum
		// create node, 1 direct trade (trade on D), and 1 indirect trade (Eric bets P(E=e1) = 0.8) 
		assertEquals(3, engine.getQuestionHistory(0x0DL, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0DL, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		sum += engine.getQuestionHistory(0x0EL, null, null).size();
		sum -= 1;	// do not count the indirect trad in the sum
		// create node, create edge, 3 direct trades, and 1 indirect trade (Eric bets P(D=d1|F=f2) = 0.7)
		assertEquals(6, engine.getQuestionHistory(0x0EL, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0EL,null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		sum += engine.getQuestionHistory(0x0FL, null, null).size();
		sum -= 1;	// do not count the indirect trad in the sum
		// create node, create arc, 2 direct trades, and 1 indirect trade (Eric bets P(E=e1) = 0.8)
		assertEquals(5, engine.getQuestionHistory(0x0FL, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0FL, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		assertEquals(engine.getExecutedActions().size(), sum);
		
		// check that no history of conditional probability is included (because the size of history for conditional probability was set to 0)
		
		// D has history of node creation (but node creation has no assumptions), and no history of conditional probabilities 
		// (because the size of history of conditional probability was set to 0)
		List<QuestionEvent> history = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(0, history.size());
		history = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(0, history.size());
		history = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(0, history.size());
		history = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(0, history.size());
		
		// E has the following history: create edge
//		history = engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
//		assertEquals(1, history.size());
//		assertTrue(history.get(0) instanceof AddQuestionAssumptionNetworkAction);
//		history = engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
//		assertEquals(1, history.size());
//		assertTrue(history.get(0) instanceof AddQuestionAssumptionNetworkAction);
//		
//		// F has the following history: create edge
//		history = engine.getQuestionHistory(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0));
//		assertEquals(1, history.size());
//		assertTrue(history.get(0) instanceof AddQuestionAssumptionNetworkAction);
//		history = engine.getQuestionHistory(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1));
//		assertEquals(1, history.size());
//		assertTrue(history.get(0) instanceof AddQuestionAssumptionNetworkAction);
		
		
		// now, set the engine to retrive only the history of trades		
		engine.setToRetriveOnlyTradeHistory(true);
		
		// check history of actions not related to any question
		sum = engine.getQuestionHistory(null, null, null).size();
		// there were no trades with question ID = null
		assertEquals(0, engine.getQuestionHistory(null, null, null).size());
		
		// check history of actions related each question
		sum += engine.getQuestionHistory(0x0DL, null, null).size();
		sum -= 1;	// do not count the indirect trad in the sum
		// 1 direct trade (trade on D), and 1 indirect trade (Eric bets P(E=e1) = 0.8) 
		assertEquals(2, engine.getQuestionHistory(0x0DL, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0DL, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		sum += engine.getQuestionHistory(0x0EL, null, null).size();
		sum -= 1;	// do not count the indirect trad in the sum
		// 3 direct trades, and 1 indirect trade (Eric bets P(D=d1|F=f2) = 0.7)
		assertEquals(4, engine.getQuestionHistory(0x0EL, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0EL, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		sum += engine.getQuestionHistory(0x0FL, null, null).size();
		sum -= 1;	// do not count the indirect trad in the sum
		// 2 direct trades, and 1 indirect trade (Eric bets P(E=e1) = 0.8)
		assertEquals(3, engine.getQuestionHistory(0x0FL, null, null).size());
		for (QuestionEvent questionEvent : engine.getQuestionHistory(0x0FL, null, null)) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		// 4*addCash, 3*addQuestion, and 2*addQuestionAssumption were ignored (9 actions were ignored)
		assertEquals(engine.getExecutedActions().size()-9, sum);
		
		// check that no history of conditional probability is included (because the size of history for conditional probability was set to 0)
		assertTrue(engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1)).isEmpty());
		
		
		// test a more controlled network

		/*
		 * The following network structure is used:
		 * <br/><br/>
		 * E<-D->F  C
		 * <br/><br/>
		 * D have 3 states, and others have 2 states.
		 * All cpt are uniform, except for E<-D, which has the following cpt:
		 * <br/><br/>
		 * P(E=e1|D=d1)=.1
		 * P(E=e2|D=d1)=.9
		 * P(E=e1|D=d2)=.2
		 * P(E=e2|D=d2)=.8
		 * P(E=e1|D=d3)=.3
		 * P(E=e2|D=d3)=.7
		 */
		engine.setMaxConditionalProbHistorySize(10);	// now, we store the history of conditional probabilities
		engine.setDefaultInitialAssetTableValue(100f);
		engine.initialize();
		
		// create the structure
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0C, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0D, 3, null);
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long)0x0D), null);
		List<Float> probDist = new ArrayList<Float>();
		probDist.add(.1f); probDist.add(.9f); // P(E|D=d1)
		probDist.add(.2f); probDist.add(.8f); // P(E|D=d2)
		probDist.add(.3f); probDist.add(.7f); // P(E|D=d3)
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long)0x0D), probDist );
		engine.commitNetworkActions(transactionKey);
		
		// obtain marginals
		Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
		// assert size (quantity of states)
		assertEquals(probLists.toString(), 2, probLists.get(0x0Cl).size());
		assertEquals(probLists.toString(), 3, probLists.get(0x0Dl).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0El).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0Fl).size());
		// check marginal prob
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 1/3f, probLists.get(0x0Dl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 1/3f, probLists.get(0x0Dl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 1/3f, probLists.get(0x0Dl).get(2), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .2f, probLists.get(0x0El).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .8f, probLists.get(0x0El).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(1), PROB_ERROR_MARGIN);
		
		// check prob conditioned on D = d1
		probLists = engine.getProbLists(null, Collections.singletonList(0x0Dl), Collections.singletonList(0));
		// assert size (quantity of states)
		assertEquals(probLists.toString(), 2, probLists.get(0x0Cl).size());
		assertEquals(probLists.toString(), 3, probLists.get(0x0Dl).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0El).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0Fl).size());
		// check marginal prob
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 1f, probLists.get(0x0Dl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0f, probLists.get(0x0Dl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0f, probLists.get(0x0Dl).get(2), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .1f, probLists.get(0x0El).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .9f, probLists.get(0x0El).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(1), PROB_ERROR_MARGIN);
		
		// check prob conditioned on D = d2
		probLists = engine.getProbLists(null, Collections.singletonList(0x0Dl), Collections.singletonList(1));
		// assert size (quantity of states)
		assertEquals(probLists.toString(), 2, probLists.get(0x0Cl).size());
		assertEquals(probLists.toString(), 3, probLists.get(0x0Dl).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0El).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0Fl).size());
		// check marginal prob
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0f, probLists.get(0x0Dl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 1f, probLists.get(0x0Dl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0f, probLists.get(0x0Dl).get(2), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .2f, probLists.get(0x0El).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .8f, probLists.get(0x0El).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(1), PROB_ERROR_MARGIN);
		
		// check prob conditioned on D = d3
		probLists = engine.getProbLists(null, Collections.singletonList(0x0Dl), Collections.singletonList(2));
		// assert size (quantity of states)
		assertEquals(probLists.toString(), 2, probLists.get(0x0Cl).size());
		assertEquals(probLists.toString(), 3, probLists.get(0x0Dl).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0El).size());
		assertEquals(probLists.toString(), 2, probLists.get(0x0Fl).size());
		// check marginal prob
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Cl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0f, probLists.get(0x0Dl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0f, probLists.get(0x0Dl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 1f, probLists.get(0x0Dl).get(2), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .3f, probLists.get(0x0El).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .7f, probLists.get(0x0El).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .5f, probLists.get(0x0Fl).get(1), PROB_ERROR_MARGIN);
		
		// user 0 adds trades on each questions
		transactionKey = engine.startNetworkActions();
		probDist = new ArrayList<Float>();
		probDist.add(.5f); probDist.add(.3f); probDist.add(.2f);
		engine.addTrade(transactionKey, new Date(), "User 0 trades D = [.5,.3,.2]", 0, 0x0Dl, probDist, null, null, false);
		probDist = new ArrayList<Float>();
		probDist.add(.7f); probDist.add(.3f);
		engine.addTrade(transactionKey, new Date(), "User 0 trades C = [.7,.3]", 0, 0x0Cl, probDist, null, null, false);
		engine.addTrade(transactionKey, new Date(), "User 0 trades E = [.7,.3]", 0, 0x0El, probDist, null, null, false);
		engine.addTrade(transactionKey, new Date(), "User 0 trades F = [.7,.3]", 0, 0x0Fl, probDist, null, null, false);
		engine.commitNetworkActions(transactionKey);

		// check new marginal prob
		probLists = engine.getProbLists(null, null, null);
		assertEquals(probLists.toString(), .7f, probLists.get(0x0Cl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .3f, probLists.get(0x0Cl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0.3685f, probLists.get(0x0Dl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0.3338f, probLists.get(0x0Dl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0.2977f, probLists.get(0x0Dl).get(2), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .7f, probLists.get(0x0El).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .3f, probLists.get(0x0El).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .7f, probLists.get(0x0Fl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .3f, probLists.get(0x0Fl).get(1), PROB_ERROR_MARGIN);
		
		// user 1 adds trades on each questions
		probDist = new ArrayList<Float>();
		probDist.add(.6f); probDist.add(.2f); probDist.add(.2f);
		// conditional trade should not change marginal of E
		engine.addTrade(null, new Date(), "User 1 trades D = [.6,.2,.2] given E=e1", 1, 0x0Dl, probDist, Collections.singletonList(0x0El), Collections.singletonList(1), false);
		probDist = new ArrayList<Float>();
		probDist.add(.4f); probDist.add(.6f);
		engine.addTrade(null, new Date(), "User 1 trades C = [.4,.6]", 1, 0x0Cl, probDist, null, null, false);
		engine.addTrade(null, new Date(), "User 1 trades E = [.4,.6]", 1, 0x0El, probDist, null, null, false);
		engine.addTrade(null, new Date(), "User 1 trades F = [.4,.6]", 1, 0x0Fl, probDist, null, null, false);
		
		// check new marginal prob
		probLists = engine.getProbLists(null, null, null);
		assertEquals(probLists.toString(), .4f, probLists.get(0x0Cl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .6f, probLists.get(0x0Cl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0.4776f, probLists.get(0x0Dl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0.2612f, probLists.get(0x0Dl).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), 0.2612f, probLists.get(0x0Dl).get(2), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .4f, probLists.get(0x0El).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .6f, probLists.get(0x0El).get(1), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .4f, probLists.get(0x0Fl).get(0), PROB_ERROR_MARGIN);
		assertEquals(probLists.toString(), .6f, probLists.get(0x0Fl).get(1), PROB_ERROR_MARGIN);
		
		// check content of history of each question
		history = engine.getQuestionHistory(0x0Cl, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0CL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 2, history.size());
		assertEquals("User 0 trades C = [.7,.3]", history.get(0).getTradeId());
		assertEquals(2, history.get(0).getOldValues().size());
		assertEquals(.5f, history.get(0).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(0).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(0).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(0).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades C = [.4,.6]", history.get(1).getTradeId());
		assertEquals(2, history.get(1).getOldValues().size());
		assertEquals(.7f, history.get(1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0CL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			assertEquals(2, questionEvent.getOldValues().size());
		}
		
		// F is a question which has arc, but is independent because the cpt is uniform
		history = engine.getQuestionHistory(0x0Fl, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 2, history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(0).getTradeId());
		assertEquals(2, history.get(0).getOldValues().size());
		assertEquals(.5f, history.get(0).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(0).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(0).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(0).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(1).getTradeId());
		assertEquals(2, history.get(1).getOldValues().size());
		assertEquals(.7f, history.get(1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			assertEquals(2, questionEvent.getOldValues().size());
		}
		
		// special case: indirect trade may change prob
		history = engine.getQuestionHistory(0x0Dl, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 4, history.size());	// 2 direct and 2 indirect trades from E
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0DL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(3, questionEvent.getNewValues().size());
			assertEquals(3, questionEvent.getOldValues().size());
		}
		
		// special case: indirect trade may change prob
		history = engine.getQuestionHistory(0x0El, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 3, history.size());	// 2 direct trad, and 1 indirect (User 0 trades D = [.5,.3,.2])
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0EL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			assertEquals(2, questionEvent.getOldValues().size());
		}
		
		
		// check conditional question history
		
		// check invalid assumptions returns empty history
		
		// C have no possible assumptions
		assertTrue(engine.getQuestionHistory(0x0CL, 
				Collections.singletonList((Math.random() < .25)?0x0DL:((Math.random() < .33)?0x0EL:((Math.random() < .5)?0x0EL:0x0CL))), 
				Collections.singletonList((Math.random() < .5)?0:1) ).isEmpty());
		// no node can have C as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have itself as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0DL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have assumptions outside the clique in the current implementation
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		
		
		// check content of history of conditional probabilities
		
		// although F is independent because the cpt is uniform, changes in marginals usually changes conditional prob
		// check P(F|D = d1)
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 2 <= history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(history.size()-2).getTradeId());
		assertEquals(2, history.get(history.size()-2).getOldValues().size());
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(history.size()-2).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-2).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(history.size()-1).getTradeId());
		assertEquals(2, history.get(history.size()-1).getOldValues().size());
		assertEquals(.7f, history.get(history.size()-1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(2, questionEvent.getOldValues().size());
			}
		}
		List<Float> probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		// check P(F|D = d2), which should be equals to  P(F|D = d1) due to independency. 
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue(history.toString(), 2 <= history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(history.size()-2).getTradeId());
		assertEquals(2, history.get(history.size()-2).getOldValues().size());
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(history.size()-2).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-2).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(history.size()-1).getTradeId());
		assertEquals(2, history.get(history.size()-1).getOldValues().size());
		assertEquals(.7f, history.get(history.size()-1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(2, questionEvent.getOldValues().size());
			}
		}
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 1 <= history.size());	// the conditional probability given E is only changing 1 time
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 2 <= history.size());	// the conditional probability given E2 was only changing twice
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 4 <= history.size());	// at least 2 direct and 2 indirect trades from E
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(1));
		
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 4 <= history.size());	// at least 2 direct and 2 indirect trades from E
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 3 <= history.size());	// at least 2 direct trade, and 1 indirect (User 0 trades D = [.5,.3,.2])
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 3 <= history.size());	// at least 2 direct trade, and 1 indirect (User 0 trades D = [.5,.3,.2])
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		
		/*
		 * Convert the structure to:
		 * B->E<-D->F  C
		 * 
		 * The new node is B, and it has 3 states
		 * Note: now, the clique ED (2 nodes) was converted to BED (3 nodes)
		 * 
		 * The new cpt of E is:
		 * P(E=e1|D=d1, B=b1)=.1
		 * P(E=e2|D=d1, B=b1)=.9
		 * P(E=e1|D=d2, B=b1)=.2
		 * P(E=e2|D=d2, B=b1)=.8
		 * P(E=e1|D=d3, B=b1)=.3
		 * P(E=e2|D=d3, B=b1)=.7
		 * P(E=e1|D=d1, B=b2)=.4
		 * P(E=e2|D=d1, B=b2)=.9
		 * P(E=e1|D=d2, B=b2)=.2
		 * P(E=e2|D=d2, B=b2)=.8
		 * P(E=e1|D=d3, B=b2)=.3
		 * P(E=e2|D=d3, B=b2)=.7
		 * P(E=e1|D=d1, B=b3)=.1
		 * P(E=e2|D=d1, B=b3)=.9
		 * P(E=e1|D=d2, B=b3)=.2
		 * P(E=e2|D=d2, B=b3)=.8
		 * P(E=e1|D=d3, B=b3)=.3
		 * P(E=e2|D=d3, B=b3)=.7
		 */
		
		transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0BL, 3, null);	// add the node B
		List<Long> parents = new ArrayList<Long>();
		parents.add(0x0DL); parents.add(0x0BL);
		List<Float> cpt = new ArrayList<Float>();
		cpt.add(.1f); cpt.add(.9f); cpt.add(.2f); cpt.add(.8f); cpt.add(.3f); cpt.add(.7f);
		cpt.add(.1f); cpt.add(.9f); cpt.add(.2f); cpt.add(.8f); cpt.add(.3f); cpt.add(.7f);
		cpt.add(.1f); cpt.add(.9f); cpt.add(.2f); cpt.add(.8f); cpt.add(.3f); cpt.add(.7f);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0EL, parents , cpt); // add the arc B->E
		engine.commitNetworkActions(transactionKey);	// commit and rebuild network from history
		
		
		// check content of history of each question again (they should be equal)
		history = engine.getQuestionHistory(0x0Cl, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0CL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 2, history.size());
		assertEquals("User 0 trades C = [.7,.3]", history.get(0).getTradeId());
		assertEquals(2, history.get(0).getOldValues().size());
		assertEquals(.5f, history.get(0).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(0).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(0).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(0).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades C = [.4,.6]", history.get(1).getTradeId());
		assertEquals(2, history.get(1).getOldValues().size());
		assertEquals(.7f, history.get(1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0CL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			assertEquals(2, questionEvent.getOldValues().size());
		}
		
		// F is a question which has arc, but is independent because the cpt is uniform
		history = engine.getQuestionHistory(0x0Fl, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 2, history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(0).getTradeId());
		assertEquals(2, history.get(0).getOldValues().size());
		assertEquals(.5f, history.get(0).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(0).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(0).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(0).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(1).getTradeId());
		assertEquals(2, history.get(1).getOldValues().size());
		assertEquals(.7f, history.get(1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			assertEquals(2, questionEvent.getOldValues().size());
		}
		
		// special case: indirect trade may change prob
		history = engine.getQuestionHistory(0x0Dl, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 4, history.size());	// 2 direct and 2 indirect trades from E
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0DL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(3, questionEvent.getNewValues().size());
			assertEquals(3, questionEvent.getOldValues().size());
		}
		
		// special case: indirect trade may change prob
		history = engine.getQuestionHistory(0x0El, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(history.toString(), 3, history.size());	// 2 direct trad, and 1 indirect (User 0 trades D = [.5,.3,.2])
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0EL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			assertEquals(2, questionEvent.getOldValues().size());
		}
		
		
		// check conditional question history
		
		// check invalid assumptions returns empty history
		
		// C have no possible assumptions
		assertTrue(engine.getQuestionHistory(0x0CL, 
				Collections.singletonList((Math.random() < .25)?0x0DL:((Math.random() < .33)?0x0EL:((Math.random() < .5)?0x0EL:0x0CL))), 
				Collections.singletonList((Math.random() < .5)?0:1) ).isEmpty());
		// no node can have C as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have itself as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0DL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have assumptions outside the clique in the current implementation
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		
		
		// check content of history of conditional probabilities
		
		// although F is independent because the cpt is uniform, changes in marginals usually changes conditional prob
		// check P(F|D = d1)
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 2 <= history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(history.size()-2).getTradeId());
		assertEquals(2, history.get(history.size()-2).getOldValues().size());
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(history.size()-2).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-2).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(history.size()-1).getTradeId());
		assertEquals(2, history.get(history.size()-1).getOldValues().size());
		assertEquals(.7f, history.get(history.size()-1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(2, questionEvent.getOldValues().size());
			}
		}
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		// check P(F|D = d2), which should be equals to  P(F|D = d1) due to independency. 
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue(history.toString(), 2 <= history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(history.size()-2).getTradeId());
		assertEquals(2, history.get(history.size()-2).getOldValues().size());
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(history.size()-2).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-2).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(history.size()-1).getTradeId());
		assertEquals(2, history.get(history.size()-1).getOldValues().size());
		assertEquals(.7f, history.get(history.size()-1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(2, questionEvent.getOldValues().size());
			}
		}
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertTrue("Obtained size = " + history.size(), 1 <= history.size());	// the conditional probability given E is only changing 1 time
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 2 <= history.size());	// the conditional probability given E2 was only changing twice
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 4 <= history.size());	// at least 2 direct and 2 indirect trades from E
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 4 <= history.size());	// at least 2 direct and 2 indirect trades from E
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 3 <= history.size());	// at least 2 direct trade, and 1 indirect (User 0 trades D = [.5,.3,.2])
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 3 <= history.size());	// at least 2 direct trade, and 1 indirect (User 0 trades D = [.5,.3,.2])
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		// store history before resolution for comparison
		List<QuestionEvent> marginalHistoryBeforeResolution = engine.getQuestionHistory(0x0EL, null, null);
		for (QuestionEvent questionEvent : marginalHistoryBeforeResolution) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		// resolve a question and test again, but before that, add dependency between B and E
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.5f); newValues.add(.5f);
		int settledState = 1;
		engine.addTrade(null, new Date(), "User 1 sets P(E|B=1) = [.5,.5]", 1L, 
				0x0EL, newValues , Collections.singletonList(0x0BL), Collections.singletonList(settledState), false);
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0BL, null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0BL, null, null).get(settledState));
		}

		engine.resolveQuestion(null, new Date(), 0x0BL, settledState);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		List<QuestionEvent> marginalHistoryAfterResolution = engine.getQuestionHistory(0x0EL, null, null);
		for (QuestionEvent questionEvent : marginalHistoryBeforeResolution) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(marginalHistoryBeforeResolution.size() + 2, marginalHistoryAfterResolution.size());	// +2 because of the last addTrade and resolveQuestion
		assertTrue(((DummyTradeAction)marginalHistoryAfterResolution.get(marginalHistoryAfterResolution.size() - 1)).getParentAction() instanceof ResolveQuestionNetworkAction);
		assertEquals(0x0BL, marginalHistoryAfterResolution.get(marginalHistoryAfterResolution.size() - 1).getQuestionId().longValue());
		assertEquals(settledState, marginalHistoryAfterResolution.get(marginalHistoryAfterResolution.size() - 1).getSettledState().intValue());
		
		// check invalid assumptions returns empty history
		
		// C have no possible assumptions
		assertTrue(engine.getQuestionHistory(0x0CL, 
				Collections.singletonList((Math.random() < .25)?0x0DL:((Math.random() < .33)?0x0EL:((Math.random() < .5)?0x0EL:0x0CL))), 
				Collections.singletonList((Math.random() < .5)?0:1) ).isEmpty());
		// no node can have C as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have itself as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0DL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have assumptions outside the clique in the current implementation
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		
		
		// check content of history of conditional probabilities
		
		// although F is independent because the cpt is uniform, changes in marginals usually changes conditional prob
		// check P(F|D = d1)
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 2 <= history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(history.size()-2).getTradeId());
		assertEquals(2, history.get(history.size()-2).getOldValues().size());
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(history.size()-2).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-2).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(history.size()-1).getTradeId());
		assertEquals(2, history.get(history.size()-1).getOldValues().size());
		assertEquals(.7f, history.get(history.size()-1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(2, questionEvent.getOldValues().size());
			}
		}
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		// check P(F|D = d2), which should be equals to  P(F|D = d1) due to independency. 
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue(history.toString(), 2 <= history.size());
		assertEquals("User 0 trades F = [.7,.3]", history.get(history.size()-2).getTradeId());
		assertEquals(2, history.get(history.size()-2).getOldValues().size());
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, history.get(history.size()-2).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.7f, history.get(history.size()-2).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-2).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals("User 1 trades F = [.4,.6]", history.get(history.size()-1).getTradeId());
		assertEquals(2, history.get(history.size()-1).getOldValues().size());
		assertEquals(.7f, history.get(history.size()-1).getOldValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.3f, history.get(history.size()-1).getOldValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(.4f, history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(.6f, history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		for (QuestionEvent questionEvent : history) {
			assertEquals(0x0FL, ((AddTradeNetworkAction)questionEvent).getQuestionId().longValue());
			assertEquals(2, questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(2, questionEvent.getOldValues().size());
			}
		}
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 1 <= history.size());	// the conditional probability given E is only changing 1 time
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 2 <= history.size());	// the conditional probability given E2 was only changing twice
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 4 <= history.size());	// at least 2 direct and 2 indirect trades from E
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		assertTrue(((DummyTradeAction)history.get(history.size()-1)).getParentAction() instanceof ResolveQuestionNetworkAction);
		assertEquals(0x0BL, history.get(history.size() - 1).getQuestionId().longValue());
		assertEquals(settledState, history.get(history.size() - 1).getSettledState().intValue());
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 4 <= history.size());	// at least 2 direct and 2 indirect trades from E
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		assertTrue(((DummyTradeAction)history.get(history.size()-1)).getParentAction() instanceof ResolveQuestionNetworkAction);
		assertEquals(0x0BL, history.get(history.size() - 1).getQuestionId().longValue());
		assertEquals(settledState, history.get(history.size() - 1).getSettledState().intValue());
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(0));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 3 <= history.size());	// at least 2 direct trade, and 1 indirect (User 0 trades D = [.5,.3,.2])
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(1));
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue("Obtained size = " + history.size(), 3 <= history.size());	// at least 2 direct trade, and 1 indirect (User 0 trades D = [.5,.3,.2])
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.size(), history.get(history.size()-1).getNewValues().size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.toString() + " != " + history.get(history.size()-1).getNewValues(), probList.get(i), history.get(history.size()-1).getNewValues().get(i), PROB_ERROR_MARGIN);
		}
		assertTrue(((DummyTradeAction)history.get(history.size()-1)).getParentAction() instanceof ResolveQuestionNetworkAction);
		
		// resolve all questions and test again
		settledState = (Math.random() < .5)?0:1;
		
		// get the expected score per D for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(settledState); assumedStates.add(settledState);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			List<Long> assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add(settledState); assumedStates.add(settledState);
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, assumptionIds, assumedStates).get(settledState));
		}
		
		transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), 0x0DL, settledState);
		engine.resolveQuestion(transactionKey, new Date(), 0x0EL, settledState);
		engine.resolveQuestion(transactionKey, new Date(), 0x0FL, settledState);
		engine.commitNetworkActions(transactionKey);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check invalid assumptions returns empty history
		
		// C have no possible assumptions
		assertTrue(engine.getQuestionHistory(0x0CL, 
				Collections.singletonList((Math.random() < .25)?0x0DL:((Math.random() < .33)?0x0EL:((Math.random() < .5)?0x0EL:0x0CL))), 
				Collections.singletonList((Math.random() < .5)?0:1) ).isEmpty());
		// no node can have C as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0CL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have itself as assumption
		assertTrue(engine.getQuestionHistory(0x0DL, 
				Collections.singletonList(0x0DL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		// no node can have assumptions outside the clique in the current implementation
		assertTrue(engine.getQuestionHistory(0x0EL, 
				Collections.singletonList(0x0FL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		assertTrue(engine.getQuestionHistory(0x0FL, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList((Math.random() < .5)?0:1)).isEmpty());
		
		
		// check content of history of conditional probabilities
		
		// although F is independent because the cpt is uniform, changes in marginals usually changes conditional prob
		// check P(F|D = d1), but D was resolved already
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// assumption was already resolved
		// check P(F|D = d2),  but D was resolved already
		history = engine.getQuestionHistory(0x0Fl, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(history.toString(), 0 , history.size());
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// D is not present anymore
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// D is not present anymore
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// D is not present anymore
		history = engine.getQuestionHistory(0x0Dl, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// D is not present anymore
		
		// special case: indirect trade may change conditional prob
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// D is not present anymore
		history = engine.getQuestionHistory(0x0El, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals("Obtained size = " + history.size(), 0 , history.size());	// D is not present anymore
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Test method for {@link MarkovEngineImpl#getJointProbability(List, List)}
	 */
	public final void testGetJointProbability() {
		// initialize network
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		List<Float> jointProbabilityNoOptimization = new ArrayList<Float>();	// joint prob calculation w/o optimization
		List<Float> jointProbabilityDelegated = new ArrayList<Float>();			// joint prob calculation delegated to class unbbayes.prs.bn.JunctionTree
		List<Float> jointProbabilityLocalOptimization = new ArrayList<Float>(); // joint prob calculation will not propagate evidences if all nodes are in same clique
		List<Float> jointProbabilityManual = new ArrayList<Float>(); 		// joint prob obtained from manually calculating values returned by getProbList 
		
		// check null or empty arguments
		for (int i = 0; i < 100; i++) {
			// random config
			((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(Math.random() < .5);
			((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(Math.random() < .5);
			try {
				// tested cases of questionIds := null, empty, 1 element, 2 elements, 3 elements
				List<Long> questionIds = null;
				if (Math.random() < .2) {
					// questionIds = null;
				} else if (Math.random() < .25) {
					questionIds = Collections.emptyList();
				} else if (Math.random() < .33334) {
					questionIds = Collections.singletonList((Math.random() < .34)?0x0DL:((Math.random() < .5)?0x0EL:0x0FL));
				} else if (Math.random() < .5) {
					questionIds = new ArrayList<Long>();
					questionIds.add(0x0DL);
					questionIds.add((Math.random() < .5)?0x0EL:0x0FL);
				} else {
					questionIds = new ArrayList<Long>();
					questionIds.add(0x0DL);
					questionIds.add(0x0EL);
					questionIds.add(0x0FL);
				}
				// tested cases of states := null, empty, out of range
				List<Integer> states = null;
				if (Math.random() < .34) {
					// states = null;
				} else if (Math.random() < .5) {
					states = Collections.emptyList();
				} else {
					// add at least 1 invalid
					states = new ArrayList<Integer>();
					if (Math.random() < .5) {
						states.add((int) (((Math.random()<.5)?-1:1) * Math.random()*5));
					}
					if (Math.random() < .5) {
						states.add((int) (((Math.random()<.5)?-1:1) * Math.random()*5));
					}
					if (Math.random() < .5) {
						states.add((int) (((Math.random()<.5)?-1:1) * Math.random()*5));
					}
					if (states.isEmpty()) {
						states.add((int) (((Math.random()<.5)?-1:1) * 5));
					} else if (questionIds != null) {
						// if all states are within interval [-3,2], we must force add an invalid state
						boolean hasInvalid = false;
						for (int j = 0; j < Math.min(questionIds.size(),states.size()) ; j++) {
							int state = states.get(j);
							if (state < 0) {
								state = Math.abs(state + 1);
							}
							if (state > 2) {
								hasInvalid = true;
								break;
							}
						}
						if (!hasInvalid) {
							// random generator did not add invalid state. Force to add
							states.set(0, (int) (((Math.random()<.5)?-1:1) * 5));
						}
					}
				}
				float ret = engine.getJointProbability(questionIds, states);
				fail("[" + i + "] should fail on invalid args: questions = " + questionIds + ", states = " + states + ", returned " + ret);
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		// check marginals equals to the ones returned by engine.getProbList(). Tested sequence: {d1, d2, e1, e2 , f1, f2}
		assertEquals(engine.getProbList(0x0DL, null, null).get(0), engine.getJointProbability(Collections.singletonList(0x0DL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(engine.getProbList(0x0DL, null, null).get(1), engine.getJointProbability(Collections.singletonList(0x0DL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(engine.getProbList(0x0EL, null, null).get(0), engine.getJointProbability(Collections.singletonList(0x0EL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(engine.getProbList(0x0EL, null, null).get(1), engine.getJointProbability(Collections.singletonList(0x0EL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(engine.getProbList(0x0FL, null, null).get(0), engine.getJointProbability(Collections.singletonList(0x0FL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(engine.getProbList(0x0FL, null, null).get(1), engine.getJointProbability(Collections.singletonList(0x0FL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(((ProbabilisticNode)engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getNode(Long.toString(0x0DL))).getMarginalAt(0), 
				engine.getJointProbability(Collections.singletonList(0x0DL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(((ProbabilisticNode)engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getNode(Long.toString(0x0DL))).getMarginalAt(1), 
				engine.getJointProbability(Collections.singletonList(0x0DL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(((ProbabilisticNode)engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getNode(Long.toString(0x0EL))).getMarginalAt(0), 
				engine.getJointProbability(Collections.singletonList(0x0EL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(((ProbabilisticNode)engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getNode(Long.toString(0x0EL))).getMarginalAt(1), 
				engine.getJointProbability(Collections.singletonList(0x0EL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(((ProbabilisticNode)engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getNode(Long.toString(0x0FL))).getMarginalAt(0), 
				engine.getJointProbability(Collections.singletonList(0x0FL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(((ProbabilisticNode)engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getNode(Long.toString(0x0FL))).getMarginalAt(1), 
				engine.getJointProbability(Collections.singletonList(0x0FL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		
		// test combinations of different combinations of configuration of algorithm, questions, and states
		
		// combo: d1e1
		List<Long> questionIds = new ArrayList<Long>(); List<Integer> states = new ArrayList<Integer>();
		questionIds.add(0x0DL);	states.add(0);  questionIds.add(0x0EL); states.add(0);
		
		// force internal algorithm not to use optimization at all
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(false);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityNoOptimization.add(engine.getJointProbability(questionIds, states));
		
		// Force internal algorithm to delegate calculation of joint probability to JunctionTree class
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityDelegated.add(engine.getJointProbability(questionIds, states));

		// Force internal algorithm to optimize calculation if all nodes are in same clique
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(true);
		jointProbabilityLocalOptimization.add(engine.getJointProbability(questionIds, states));
		
		// man calc := P(e1) * P(d1|e1)
		float manuallyCalculatedValue = engine.getProbList(0x0EL, null, null).get(0);
		manuallyCalculatedValue *= engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0)).get(0);
		jointProbabilityManual.add(manuallyCalculatedValue);
		
		// combo: d2f2
		questionIds = new ArrayList<Long>(); states = new ArrayList<Integer>();
		questionIds.add(0x0DL);	states.add(1);  questionIds.add(0x0FL); states.add(1);
		
		// force internal algorithm not to use optimization at all
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(false);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityNoOptimization.add(engine.getJointProbability(questionIds, states));
		
		// Force internal algorithm to delegate calculation of joint probability to JunctionTree class
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityDelegated.add(engine.getJointProbability(questionIds, states));

		// Force internal algorithm to optimize calculation if all nodes are in same clique
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(true);
		jointProbabilityLocalOptimization.add(engine.getJointProbability(questionIds, states));
		
		// man calc := P(f2) * P(d2|f2)
		manuallyCalculatedValue = engine.getProbList(0x0FL, null, null).get(1);
		manuallyCalculatedValue *= engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1)).get(1);
		jointProbabilityManual.add(manuallyCalculatedValue);
		
		// combo: d1e2f1
		questionIds = new ArrayList<Long>(); states = new ArrayList<Integer>();
		questionIds.add(0x0DL);	states.add(0);  questionIds.add(0x0EL); states.add(1);  questionIds.add(0x0FL); states.add(0);
		
		// force internal algorithm not to use optimization at all
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(false);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityNoOptimization.add(engine.getJointProbability(questionIds, states));
		
		// Force internal algorithm to delegate calculation of joint probability to JunctionTree class
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityDelegated.add(engine.getJointProbability(questionIds, states));

		// Force internal algorithm to optimize calculation if all nodes are in same clique
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(true);
		jointProbabilityLocalOptimization.add(engine.getJointProbability(questionIds, states));

		// man calc := P(f1)*P(d1|f1)*P(e2|f1,d1)
		manuallyCalculatedValue = engine.getProbList(0x0FL, null, null).get(0);
		manuallyCalculatedValue *= engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0)).get(0);
		List<Long> manualAssumptions = new ArrayList<Long>(); 
		List<Integer> manualAssumptionStates = new ArrayList<Integer>();
		manualAssumptions.add(0x0FL); manualAssumptionStates.add(0);
		manualAssumptions.add(0x0DL); manualAssumptionStates.add(0);
		manuallyCalculatedValue *= engine.getProbList(0x0EL, manualAssumptions, manualAssumptionStates).get(1);
		jointProbabilityManual.add(manuallyCalculatedValue);
		
		// combo: f2d2e2
		questionIds = new ArrayList<Long>(); states = new ArrayList<Integer>();
		questionIds.add(0x0FL);	states.add(1);  questionIds.add(0x0DL); states.add(1);  questionIds.add(0x0EL); states.add(1);
		
		// force internal algorithm not to use optimization at all
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(false);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityNoOptimization.add(engine.getJointProbability(questionIds, states));
		
		// Force internal algorithm to delegate calculation of joint probability to JunctionTree class
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(false);
		jointProbabilityDelegated.add(engine.getJointProbability(questionIds, states));

		// Force internal algorithm to optimize calculation if all nodes are in same clique
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToUseEstimatedTotalProbability(true);
		((JunctionTreeAlgorithm)engine.getDefaultInferenceAlgorithm().getProbabilityPropagationDelegator()).setToCalculateJointProbabilityLocally(true);
		jointProbabilityLocalOptimization.add(engine.getJointProbability(questionIds, states));

		// man calc := Prod(clique potential) / Prod (separator potential)
		Clique cliqueDE = (Clique) ((ProbabilisticNode)engine.getProbabilisticNetwork().getNode(Long.toString(0x0EL))).getAssociatedClique();
		Clique cliqueDF = (Clique) ((ProbabilisticNode)engine.getProbabilisticNetwork().getNode(Long.toString(0x0FL))).getAssociatedClique();
		Separator sepD = (Separator) ((ProbabilisticNode)engine.getProbabilisticNetwork().getNode(Long.toString(0x0DL))).getAssociatedClique();
		int coordinate[] = {1,1};
		jointProbabilityManual.add(
				cliqueDE.getProbabilityFunction().getValue(coordinate) 
				* cliqueDF.getProbabilityFunction().getValue(coordinate)
				/ sepD.getProbabilityFunction().getValue(1)
			);
		
		// check that all probabilities are the same
		assertEquals(jointProbabilityDelegated.size(), jointProbabilityLocalOptimization.size());
		assertEquals(jointProbabilityDelegated.size(), jointProbabilityNoOptimization.size());
		for (int i = 0; i < jointProbabilityDelegated.size(); i++) {
			assertEquals("["+i+"]",jointProbabilityManual.get(i), jointProbabilityLocalOptimization.get(i), PROB_ERROR_MARGIN);
			assertEquals("["+i+"]",jointProbabilityManual.get(i), jointProbabilityNoOptimization.get(i), PROB_ERROR_MARGIN);
			assertEquals("["+i+"]",jointProbabilityManual.get(i), jointProbabilityDelegated.get(i), PROB_ERROR_MARGIN);
		}
		
		
		// test joint probability of disconnected network
		// D = [.5,.5]; E = [.8,.2]; F = [.1,.9].
		engine.initialize();
		long transactionKey = engine.startNetworkActions();
		List<Float> initProbs = new ArrayList<Float>();
		initProbs.add(.5f); initProbs.add(.5f);
		engine.addQuestion(transactionKey, new Date(), 0x0DL, 2, initProbs );
		initProbs = new ArrayList<Float>();
		initProbs.add(.8f); initProbs.add(.2f);
		engine.addQuestion(transactionKey, new Date(), 0x0EL, 2, initProbs );
		initProbs = new ArrayList<Float>();
		initProbs.add(.1f); initProbs.add(.9f);
		engine.addQuestion(transactionKey, new Date(), 0x0FL, 2, initProbs );
		engine.commitNetworkActions(transactionKey);
		
		// test marginal probs
		assertEquals(.5f, engine.getJointProbability(Collections.singletonList(0x0DL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(.5f, engine.getJointProbability(Collections.singletonList(0x0DL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(.8f, engine.getJointProbability(Collections.singletonList(0x0EL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(.2f, engine.getJointProbability(Collections.singletonList(0x0EL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		assertEquals(.1f, engine.getJointProbability(Collections.singletonList(0x0FL), Collections.singletonList(0)), PROB_ERROR_MARGIN);
		assertEquals(.9f, engine.getJointProbability(Collections.singletonList(0x0FL), Collections.singletonList(1)), PROB_ERROR_MARGIN);
		
		// test 2-by-2
		
		// D and E
		questionIds = new ArrayList<Long>();
		questionIds.add(0x0DL);	questionIds.add(0x0EL);
		manualAssumptionStates = new ArrayList<Integer>();
		manualAssumptionStates.add(0); manualAssumptionStates.add(0);
		assertEquals(.4f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,0); manualAssumptionStates.set(1,1);
		assertEquals(.1f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,1); manualAssumptionStates.set(1,0);
		assertEquals(.4f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,1); manualAssumptionStates.set(1,1);
		assertEquals(.1f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);

		// D and F
		questionIds = new ArrayList<Long>();
		questionIds.add(0x0DL);	questionIds.add(0x0FL);
		manualAssumptionStates = new ArrayList<Integer>();
		manualAssumptionStates.add(0); manualAssumptionStates.add(0);
		assertEquals(.05f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,0); manualAssumptionStates.set(1,1);
		assertEquals(.45f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,1); manualAssumptionStates.set(1,0);
		assertEquals(.05f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,1); manualAssumptionStates.set(1,1);
		assertEquals(.45f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		
		// E and F
		questionIds = new ArrayList<Long>();
		questionIds.add(0x0EL);	questionIds.add(0x0FL);
		manualAssumptionStates = new ArrayList<Integer>();
		manualAssumptionStates.add(0); manualAssumptionStates.add(0);
		assertEquals(.08f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,0); manualAssumptionStates.set(1,1);
		assertEquals(.72f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,1); manualAssumptionStates.set(1,0);
		assertEquals(.02f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.set(0,1); manualAssumptionStates.set(1,1);
		assertEquals(.18f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		
		// P (D,E,F)
		questionIds = new ArrayList<Long>();
		questionIds.add(0x0DL); questionIds.add(0x0EL);	questionIds.add(0x0FL);
		manualAssumptionStates = new ArrayList<Integer>();
		manualAssumptionStates.add(0); manualAssumptionStates.add(0); manualAssumptionStates.add(0);
		assertEquals(.04f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,0); manualAssumptionStates.add(1,0); manualAssumptionStates.set(2,1);
		assertEquals(.36f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,0); manualAssumptionStates.add(1,1); manualAssumptionStates.set(2,0);
		assertEquals(.01f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,0); manualAssumptionStates.add(1,1); manualAssumptionStates.set(2,1);
		assertEquals(.09f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,1); manualAssumptionStates.add(1,0); manualAssumptionStates.set(2,0);
		assertEquals(.04f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,1); manualAssumptionStates.add(1,0); manualAssumptionStates.set(2,1);
		assertEquals(.36f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,1); manualAssumptionStates.add(1,1); manualAssumptionStates.set(2,0);
		assertEquals(.01f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
		manualAssumptionStates.add(0,1); manualAssumptionStates.add(1,1); manualAssumptionStates.set(2,1);
		assertEquals(.09f, engine.getJointProbability(questionIds, manualAssumptionStates), PROB_ERROR_MARGIN);
	}
	
	/**
	 * Test method for {@link MarkovEngineImpl#getMaximumValidAssumptionsSublists(long, List, int)}
	 */
	public final void testGetMaximumValidAssumptionsSublists() {
		this.createDEFNetIn1Transaction(new HashMap<String, Long>());
		
		// check assumptions of D in collection {E,F}
		List<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0EL); assumptionIds.add(0x0FL);
		List<List<Long>> validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , Integer.MAX_VALUE);
		assertEquals(2, validAssumptions.size());
		for (List<Long> assumption : validAssumptions) {
			assertEquals(1, assumption.size());
			assertTrue("Assumption = " + assumption, assumption.contains(0x0EL) || assumption.contains(0x0FL));
		}
		// search for 0 or negative sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , (int)(Math.random()*Integer.MIN_VALUE));
		assertEquals(0, validAssumptions.size());
		// search for 1 sublist
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , 1);
		assertEquals(1, validAssumptions.size());
		for (List<Long> assumption : validAssumptions) {
			assertEquals(1, assumption.size());
			assertTrue("Assumption = " + assumption, assumption.contains(0x0EL) || assumption.contains(0x0FL));
		}
		// search for 2 sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , 2);
		assertEquals(2, validAssumptions.size());
		for (List<Long> assumption : validAssumptions) {
			assertEquals(1, assumption.size());
			assertTrue("Assumption = " + assumption, assumption.contains(0x0EL) || assumption.contains(0x0FL));
		}
		// search for 3 or more sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , (int)(3 + (Math.random() * (Integer.MAX_VALUE - 3))));
		assertEquals(2, validAssumptions.size());
		for (List<Long> assumption : validAssumptions) {
			assertEquals(1, assumption.size());
			assertTrue("Assumption = " + assumption, assumption.contains(0x0EL) || assumption.contains(0x0FL));
		}
		
		// check assumptions of D in collection {E}
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0EL);
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , Integer.MAX_VALUE);
		assertEquals(1, validAssumptions.size());
		assertEquals(1, validAssumptions.get(0).size());
		assertTrue("Assumption = " + validAssumptions, validAssumptions.get(0).contains(0x0EL));
		// search for 0 or negative sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , (int)(Math.random()*Integer.MIN_VALUE));
		assertEquals(0, validAssumptions.size());
		// search for 1 sublist
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , 1);
		assertEquals(1, validAssumptions.size());
		assertEquals(1, validAssumptions.get(0).size());
		assertTrue("Assumption = " + validAssumptions, validAssumptions.get(0).contains(0x0EL));
		// search for 2 or more sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0DL, assumptionIds , (int)(2 + (Math.random() * (Integer.MAX_VALUE - 2))));
		assertEquals(1, validAssumptions.size());
		assertEquals(1, validAssumptions.get(0).size());
		assertTrue("Assumption = " + validAssumptions, validAssumptions.get(0).contains(0x0EL));
		
		// check assumptions of F in collection {D, E}
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0DL); assumptionIds.add(0x0EL);
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , Integer.MAX_VALUE);
		assertEquals(1, validAssumptions.size());
		assertEquals(1, validAssumptions.get(0).size());
		assertTrue("Assumption = " + validAssumptions, validAssumptions.get(0).contains(0x0DL));
		// search for 0 or negative sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , (int)(Math.random()*Integer.MIN_VALUE));
		assertEquals(0, validAssumptions.size());
		// search for 1 sublist
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , 1);
		assertEquals(1, validAssumptions.size());
		assertEquals(1, validAssumptions.get(0).size());
		assertTrue("Assumption = " + validAssumptions, validAssumptions.get(0).contains(0x0DL));
		// search for 2 or more sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , (int)(2 + (Math.random() * (Integer.MAX_VALUE - 2))));
		assertEquals(1, validAssumptions.size());
		assertEquals(1, validAssumptions.get(0).size());
		assertTrue("Assumption = " + validAssumptions, validAssumptions.get(0).contains(0x0DL));
		

		// check assumptions of E in collection {F}
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0FL);
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0EL, assumptionIds , Integer.MAX_VALUE);
		assertEquals(1, validAssumptions.size());
		assertEquals(0, validAssumptions.get(0).size());
		// search for 0 or negative sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0EL, assumptionIds , (int)(Math.random()*Integer.MIN_VALUE));
		assertEquals(0, validAssumptions.size());
		// search for 1 sublist
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0EL, assumptionIds , 1);
		assertEquals(1, validAssumptions.size());
		assertEquals(0, validAssumptions.get(0).size());
		// search for 2 or more sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0EL, assumptionIds , (int)(2 + (Math.random() * (Integer.MAX_VALUE - 2))));
		assertEquals(1, validAssumptions.size());
		assertEquals(0, validAssumptions.get(0).size());
		
		// disconnected net case
		engine.initialize();
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0DL, 3, null);
		engine.addQuestion(transactionKey, new Date(), 0x0EL, 3, null);
		engine.addQuestion(transactionKey, new Date(), 0x0FL, 3, null);
		engine.commitNetworkActions(transactionKey);
		
		// check assumptions of F in collection {D, E}
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0DL); assumptionIds.add(0x0EL);
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , Integer.MAX_VALUE);
		assertEquals(1, validAssumptions.size());
		assertEquals(0, validAssumptions.get(0).size());
		// search for 0 or negative sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , (int)(Math.random()*Integer.MIN_VALUE));
		assertEquals(0, validAssumptions.size());
		// search for 1 sublist
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , 1);
		assertEquals(1, validAssumptions.size());
		assertEquals(0, validAssumptions.get(0).size());
		// search for 2 or more sublists
		validAssumptions = engine.getMaximumValidAssumptionsSublists(0x0FL, assumptionIds , (int)(2 + (Math.random() * (Integer.MAX_VALUE - 2))));
		assertEquals(1, validAssumptions.size());
		assertEquals(0, validAssumptions.get(0).size());
	}
	
//	/**
//	 * Check that if Gain(X) = Prob(X=true) * ExpectedGain(X=true) + Prob(X=false) * ExpectedGain(X=false),
//	 * then Sum(Gain(Xi)) for all nodes will result in global expected gain.
//	 * This will test the DEF net after the trades of {@link #testAddTrade()}.
//	 */
//	public final void testQuestionLevelScoreGain() {
//		// crate transaction
//		long transactionKey = engine.startNetworkActions();
//		// create nodes D, E, F
//		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
//		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
//		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
//		// create edge D->E 
//		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
//		// create edge D->F
//		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
//		engine.addCash(transactionKey, new Date(), Long.MAX_VALUE, engine.getScoreFromQValues(100), "adding 100 q");
//		engine.commitNetworkActions(transactionKey);
//		
//		// extract the marginal probabilities of all nodes
//		Map<Long, List<Float>> marginals = engine.getProbLists(null, null, null);
//		assertEquals(10.0,engine.scoreUserEv(Long.MAX_VALUE, null, null),ASSET_ERROR_MARGIN);
//		assertEquals(10.0,engine.getCash(Long.MAX_VALUE, null, null),ASSET_ERROR_MARGIN);
//		
//		// multiply with expected scores conditioned to states and compare the sum with engine.scoreUserEv
//		// extract base so that we can obtain the score = base + gain -> gain = score - base.
////			float base = engine.getCash(userNameToIDMap.get(name), null, null);
//		float base = engine.getScoreFromQValues(100f);
//		try {
//			engine.getAlgorithmAndAssetNetFromUserID(Long.MAX_VALUE).setExpectedAssetPivot(base);
//			base = 0;
//		} catch (Exception e) {
//			e.printStackTrace();
//			fail(Long.MAX_VALUE+"");
//		} 
//		double sum = 0;
//		double sumWithoutProb = 0;
//		for (Long questionId : marginals.keySet()) {
//			List<Float> scorePerState = engine.scoreUserQuestionEvStates(Long.MAX_VALUE, questionId, null, null);
//			// the quantity of states must match
//			assertEquals("user = " + Long.MAX_VALUE + ", question = " + questionId, marginals.get(questionId).size(), scorePerState.size());
//			for (int i = 0; i < scorePerState.size(); i++) {
//				// Prob(X=i) * ExpectedGain(X=i). Note: ExpectedGain(X=i) = scoreUserQuestionEvStates[i] - cash.
//				sum += marginals.get(questionId).get(i) * (scorePerState.get(i) - base);
//				sumWithoutProb += (scorePerState.get(i) - base);
//			}
//		}
//		assertEquals(Long.MAX_VALUE+"", engine.scoreUserEv(Long.MAX_VALUE, null, null)- base, sum, PROB_ERROR_MARGIN);
//		
//		engine.initialize();
//		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
//		this.createDEFNetIn1Transaction(userNameToIDMap );
//		
//		// extract the marginal probabilities of all nodes
//		marginals = engine.getProbLists(null, null, null);
//		
//		// multiply with expected scores conditioned to states and compare the sum with engine.scoreUserEv
//		for (String name : userNameToIDMap.keySet()) {
//			// extract base so that we can obtain the score = base + gain -> gain = score - base.
////			base = engine.getCash(userNameToIDMap.get(name), null, null);
//			base = engine.getScoreFromQValues(100f);
//			try {
////				engine.getAlgorithmAndAssetNetFromUserID(userNameToIDMap.get(name)).setExpectedAssetPivot(base);
//				base = 0;
//			} catch (Exception e) {
//				e.printStackTrace();
//				fail(name);
//			} 
//			sum = 0;
//			sumWithoutProb = 0;
//			for (Long questionId : marginals.keySet()) {
//				List<Float> scorePerState = engine.scoreUserQuestionEvStates(userNameToIDMap.get(name), questionId, null, null);
//				// the quantity of states must match
//				assertEquals("user = " + name + ", question = " + questionId, marginals.get(questionId).size(), scorePerState.size());
//				for (int i = 0; i < scorePerState.size(); i++) {
//					// Prob(X=i) * ExpectedGain(X=i). Note: ExpectedGain(X=i) = scoreUserQuestionEvStates[i] - cash.
//					sum += marginals.get(questionId).get(i) * (scorePerState.get(i) - base);
//					sumWithoutProb += (scorePerState.get(i) - base);
//				}
//			}
//			float globalGain = engine.scoreUserEv(userNameToIDMap.get(name), null, null)- base;
//			if (Math.abs(globalGain - sum) < Math.abs(globalGain - sumWithoutProb)) {
//				assertEquals(name, globalGain, sum, 0.01);
//			} else {
//				assertEquals(name, globalGain, sumWithoutProb, 0.01);
//			}
//		}
//	}

	/**
	 * @param isToUseQValues the isToUseQValues to set
	 */
	public void setToUseQValues(boolean isToUseQValues) {
		this.isToUseQValues = isToUseQValues;
	}

	/**
	 * @return the isToUseQValues
	 */
	public boolean isToUseQValues() {
		return isToUseQValues;
	}
	
	/**
	 * Performs the same of {@link #testAddTrade()}, but all transactions
	 * will use transactionKey == null
	 */
	public final void testAddTradeNullTransactionKey() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		// create nodes D, E, F
		engine.addQuestion(null, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(null, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(null, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(null, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(null, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// commit changes
		
		
		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, engine.getCash(userNameToIDMap.get("Tom"), null, null), ASSET_ERROR_MARGIN);
		assertEquals(1, engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(null, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		// check that user's min-q value was changed to the correct value
		assertEquals(100, engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		
		// check whether probability prior to edit is really 0.5
		List<Float> probList = engine.getProbList(0x0E, null, null);
		assertEquals(2 , probList.size());
		assertEquals(0.5f , probList.get(0) , PROB_ERROR_MARGIN);
		assertEquals(0.5f , probList.get(1) , PROB_ERROR_MARGIN);
		
		// edit interval of P(E=e1) should be [0.005, 0.995]
		List<Float> editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, null, null);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.005f, editInterval.get(0), PROB_ERROR_MARGIN );
		assertEquals(0.995f, editInterval.get(1), PROB_ERROR_MARGIN );
		
		// obtain conditional probabilities and assets of the edited clique, prior to edit, so that we can use it to check assets after edit
		List<Float> cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		List<Float> cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// do edit
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			).size());
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		List<Float> cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		List<Float> cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		
		// check that new marginal of E is [0.55 0.45], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.55f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.45f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that Tom's min-q is 90 (and the cash is supposedly the log value of 90)
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);	 // null means unconditional cash, which is supposedly the global minimum
		assertEquals((engine.getScoreFromQValues(90f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(90f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE contains e2 and any values for D and F, by asserting that cash conditioned to such states are equals to the min
		// d, e, f are always going to be the assumption nodes in this test
		List<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check minimal condition of LPE: e2
		cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(1));
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(0));
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.55, .45, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.55f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
		assertEquals(0.45f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
		assertEquals(0.55f , probList.get(2),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
		assertEquals(0.45f , probList.get(3),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(E=e1|D=d1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, assumptionIds, assumedStates);	// (node == 0x0E && state == 0) == e1
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, prior to edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());

		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Tom"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that new marginal of E is [0.725 0.275] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.725f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.275f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE contains d1, e2 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check minimal condition of LPE: d1, e2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// TODO assert getAssetsIf

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(null, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.9, .1, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.9f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
		assertEquals(0.1f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
		assertEquals(0.55f , probList.get(2),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
		assertEquals(0.45f , probList.get(3),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(E=e1|D=d2) should be [0.0055, 0.9955]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0E, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0055f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9955f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(E=e1|D=d2) = 0.4 and P(E=e2|D=d2) = 0.6
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that new marginal of E is [0.65 0.35] (this is expected value), and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 72.727272...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(72.727272f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(72.727272f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE contains d2, e1 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check minimal condition of LPE: d2, e1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1);
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// TODO assert getAssetsIf
		
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(null, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.5, .5, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		probList = engine.getProbList(0x0F, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(F=f1|D=d1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0F, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(F=f1|D=d1) = 0.3 and P(F=f2|D=d1) = 0.7  
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.4 .6], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.4f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.6f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE contains d1, f1 and any value E
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check minimal condition of LPE: d1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0F);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(0);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		assumptionIds.clear();
		assumptionIds.add((long)0x0F);
		assumedStates.clear();
		assumedStates.add(1);
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// TODO assert getAssetsIf
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.3, .7, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		probList = engine.getProbList(0x0F, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.3f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.7f , probList.get(1),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(F=f1|D=d2) should be [0.006875, 0.993125]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0F, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.006875f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.993125, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(F=f1|D=d2) = 0.1 and P(F=f2|D=d2) = 0.9
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Joe"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.2 .8], and the others have not changed (remains 50%)
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.8f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check probabilities given assumptions outside the same clique
		probList = engine.getProbList(0x0E, Collections.singletonList((long)0x0F), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0.775f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.225f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, Collections.singletonList((long)0x0F), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0.6188f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.3813f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, Collections.singletonList((long)0x0E), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0.2385f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7615f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, Collections.singletonList((long)0x0E), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0.1286f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.8714f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE contains d2, e1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// TODO assert getAssetsIf
		
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		assertEquals(0, (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
		assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(null, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		// check that user's min-q value was changed to the correct value
		assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);

		
		// Eric bets P(E=e1) = .65 -> .8
		
		// check whether probability prior to edit is really = [.65, .35]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		probList = engine.getProbList(0x0E, assumptionIds, null);
		assertEquals(2, probList.size());
		assertEquals(0.65f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.35f , probList.get(1),PROB_ERROR_MARGIN );
		
		
		// edit interval of P(E=e1) should be [0.0065, 0.9965]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0E, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0065f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9965f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(E=e1) = 0.8 and P(E=e2) = 0.2
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
			).size());
		
		
		assertEquals(10.1177, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0E, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0E, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that new marginal of E is [0.8 0.2] (this is expected value), F is [0.2165, 0.7835], and D is [0.5824, 0.4176]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.5824f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.4176f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 57.142857...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(57.142857f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(57.142857f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE contains e2 and any D or F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		
		// check whether probability prior to edit is really [d1f2, d2f2] = [.52, .48]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		probList = engine.getProbList(0x0D, assumptionIds, null);
		assertEquals(4, probList.size());
		assertEquals(0.52f , probList.get(2),PROB_ERROR_MARGIN );
		assertEquals(0.48f , probList.get(3),PROB_ERROR_MARGIN );
		
		assumedStates.add(1);	// set f2 as assumed state
		
		// edit interval of P(D=d1|F=f2) should be [0.0091059, 0.9916058]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(D=d1|F=f2) = 0.7 and P(D=d2|F=f2) = 0.3
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				false
		).size());
		

		assertEquals(10.31615, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that new marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// check that min-q is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE is d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		

		// Eric makes a bet which makes his assets-q to go below 1, but the algorithm does not allow it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// get history before transaction, so that we can make sure new transaction is not added into history
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		try {
			assertNull(engine.addTrade(
					null, 
					new Date(), 
					"Eric bets P(D=d1|F=f2) = 0.7", 
					userNameToIDMap.get("Eric"), 
					0x0D, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false	// do not allow negative assets
			));
			fail("It should throw an exception indicating that the assets whent to zero or negative");
		} catch (ZeroAssetsException e) {
			assertNotNull(e);
		}
		// this is supposedly going to commit empty transaction
		// make sure history was not changed
		assertEquals(questionHistory, engine.getQuestionHistory(0x0DL, null, null));

		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		// check that assets and conditional probs did not change
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals( "Index = " + i, cliqueAssetsBeforeTrade.get(i), cliqueAssetsAfterTrade.get(i), ASSET_ERROR_MARGIN );
			assertEquals( "Index = " + i, cliqueProbsBeforeTrade.get(i), cliqueProbsAfterTrade.get(i), PROB_ERROR_MARGIN );
		}
		
		
		// check that marginals have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// check that min-q has not changed
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE has not changed - still d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		

		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// add question disconnected question C
		engine.addQuestion(null, new Date(), (long)0x0C, 2, null);
		

		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		
		// check that probabilities and assets related to old node did not change
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		
		
		// Amy bets P(C=c1) = .5 -> .05
		
		// check whether probability of C prior to edit is really [.5, .5] no matter what combination of other nodes
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds = new ArrayList<Long>(3);	assumedStates = new ArrayList<Integer>(3);
		assumptionIds.add((long)0x0D);	assumptionIds.add((long)0x0E);
		assumedStates.add((Math.random() < .5)?1:0); assumedStates.add((Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds.set(0, (long)0x0D);	assumptionIds.set(1, (long)0x0F);
		assumedStates.set(0, (Math.random() < .5)?1:0); assumedStates.set(1, (Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds.set(0, (long)0x0E);	assumptionIds.set(1, (long)0x0F);
		assumedStates.set(0, (Math.random() < .5)?1:0); assumedStates.set(1, (Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		assumptionIds.set(0, (long)0x0E);	assumptionIds.set(1, (long)0x0F); assumptionIds.add((long)0x0D); 
		assumedStates.set(0, (Math.random() < .5)?1:0); assumedStates.set(1, (Math.random() < .5)?1:0); assumedStates.add((Math.random() < .5)?1:0);
		probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
		assertEquals(2, probList.size());
		assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
		assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		
		// edit interval of P(C=c1) should be [0.005, 0.995]
		editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0C, 0, null, null);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0083f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916667f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// set P(C=c1) = 0.05 and   P(C=c1) = 0.95
		newValues = new ArrayList<Float>();
		newValues.add(.05f);
		newValues.add(.95f);
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Amy bets P(C=c1) = 0.05", 
				userNameToIDMap.get("Amy"), 
				0x0C, 
				newValues, 
				null, 
				null, 
				false
			).size());
		
		
		// check assets
		List<Float> assetsIfStates = engine.getAssetsIfStates(userNameToIDMap.get("Amy"), (long)0x0C, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals( 10,  engine.getQValuesFromScore(assetsIfStates.get(0)), ASSET_ERROR_MARGIN );
		assertEquals( 190,  engine.getQValuesFromScore(assetsIfStates.get(1)), ASSET_ERROR_MARGIN );
		
		// check that marginals of C is [.05,.95], and others have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		probList = engine.getProbList(0x0C, null, null);
		assertEquals(0.05f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.95f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that min-q is 6...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(6f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(6f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that new LPE of Amy is independent of E
		assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(0)), ASSET_ERROR_MARGIN);
		assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(1)), ASSET_ERROR_MARGIN);
		
		// check that LPE is d1 c1 f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0C);		// 2nd node is C; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, c1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// c1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, c1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, c2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, c2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, c1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check incomplete condition of LPE: c1
		cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(0));
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(1));
		assertTrue("Obtained cash = " + cash, minCash < cash);
		

		// Eric makes a bet which makes his assets-q to go below 1, and the algorithm allows it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
		assertNotNull(editInterval);
		assertEquals(2, editInterval.size());
		assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
		assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		
		// obtain conditional probabilities and assets of the edited clique, before the edit, so that we can use it to check assets
		cliqueProbsBeforeTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsBeforeTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsBeforeTrade.size());
		assertEquals(4, cliqueAssetsBeforeTrade.size());
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		assertEquals(2, engine.addTrade(
				null, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				assumptionIds, 
				assumedStates, 
				true	// allow negative assets
			).size());
		
		
		// obtain conditional probabilities and assets of the edited clique, after the edit, so that we can use it to check assets
		cliqueProbsAfterTrade = engine.getProbList((long)0x0F, Collections.singletonList((long)0x0D), null, false);
		cliqueAssetsAfterTrade = engine.getAssetsIfStates(userNameToIDMap.get("Eric"), (long)0x0F, Collections.singletonList((long)0x0D), null);
		assertEquals(4, cliqueProbsAfterTrade.size());
		assertEquals(4, cliqueAssetsAfterTrade.size());
		for (int i = 0; i < cliqueAssetsAfterTrade.size(); i++) {
			assertEquals(
					"Index = " + i, 
					cliqueProbsAfterTrade.get(i)/cliqueProbsBeforeTrade.get(i) * engine.getQValuesFromScore(cliqueAssetsBeforeTrade.get(i)), 
					engine.getQValuesFromScore(cliqueAssetsAfterTrade.get(i)), 
					ASSET_ERROR_MARGIN
				);
		}
		
		// check that cash is smaller or equal to 0
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertTrue("Obtained unexpected cash = " + minCash, minCash <= 0);
	
		Map<Long, List<Float>> probListsBeforeTrade = engine.getProbLists(null, null, null);
		
		// test the case in which the trade will make the assets to go negative, but it cannot be previewed (it will throw exception only on commit)
		
		// add a new question in the same transaction, so that we guarantee that trade cannot be previewed
		List<Float> initProbs = new ArrayList<Float>();
		initProbs.add(.9f); initProbs.add(.0999f); initProbs.add(.0001f);
		engine.addQuestion(null, new Date(), 0x0AL, 3, initProbs);
		
		// add a trade which will make user asset to go below zero and cannot be previewed
		newValues = new ArrayList<Float>();
		newValues.add(.0001f); newValues.add(.0999f);  newValues.add(.9f); 
		try {
			assertTrue( engine.addTrade(
					null, 
					new Date(), 
					"Amy bets P(A = [.0001, .0999, .9])", 
					userNameToIDMap.get("Amy"), 
					0x0AL, 
					newValues, 
					null, 
					null, 
					false
			).isEmpty());
			fail("This is expected to throw ZeroAssetsException");
		} catch (ZeroAssetsException e) {
			assertNotNull(e);
		}
		
		// probability of nodes present before this transaction must remain unchanged
		Map<Long, List<Float>> probListsAfterTrade = engine.getProbLists(null, null, null);
		for (Long id : probListsBeforeTrade.keySet()) {
			assertEquals("question = " + id , probListsBeforeTrade.get(id).size(), probListsAfterTrade.get(id).size());
			for (int i = 0; i < probListsBeforeTrade.get(id).size(); i++) {
				assertEquals("Question = " + id , probListsBeforeTrade.get(id).get(i), probListsAfterTrade.get(id).get(i), PROB_ERROR_MARGIN);
			}
		}
		
		// check that final min-q of Tom is 20
		minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Tom contains d1, e2 and any value F
		assumedStates = new ArrayList<Integer>();
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(0x0DL); assumptionIds.add(0x0EL); assumptionIds.add(0x0FL); 
		
		// check combination d1, e1, f1 (not min)
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		
		// test invalid assumptions
		
		// add a in which the assumptions will be ignored
		newValues = new ArrayList<Float>();
		newValues.add(.5f); newValues.add(.5f); 
		assertFalse( engine.addTrade(
				null, 
				new Date(), 
				"Tom bets P(F|E = e2) = [.5,.5]", 
				userNameToIDMap.get("Tom"), 
				0x0FL, 
				newValues, 
				Collections.singletonList(0x0EL), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		// check that marginal of F is [.5,.5] (i.e. condition E was ignored)
		probList = engine.getProbList(0x0FL, null, null);
		assertEquals(2, probList.size());
		assertEquals(.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that in the history, the assumption E was ignored
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertNotNull(questionHistory);
		assertFalse(questionHistory.isEmpty());
		AddTradeNetworkAction action = (AddTradeNetworkAction) questionHistory.get(questionHistory.size()-1);
		assertEquals((long)0x0F, (long)action.getQuestionId());
		assertTrue("Assumptions = " + action.getTradeId(), action.getAssumptionIds().isEmpty());
		
		List<Float> editLimits = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0DL, 0, null, null);
		assertEquals(2, editLimits.size());
		assertTrue(editLimits.toString() , editLimits.get(0) > 0);
		assertTrue(editLimits.toString() , editLimits.get(0) < 1);
		assertTrue(editLimits.toString() , editLimits.get(1) > 0);
		assertTrue(editLimits.toString() , editLimits.get(1) < 1);
		assertTrue(editLimits.toString() , editLimits.get(0) < 0.5 && 0.5 < editLimits.get(1));
	
		// test disconnected assumptions
		
		// add a in which the assumptions will be ignored
		newValues = new ArrayList<Float>();
		newValues.add(.5f); newValues.add(.5f); 
		assertFalse( engine.addTrade(
				null, 
				new Date(), 
				"Tom bets P(D|A = a1) = [.5,.5]", 
				userNameToIDMap.get("Tom"), 
				0x0DL, 
				newValues, 
				Collections.singletonList(0x0AL), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		
		// check that marginal of D is [.5,.5] (i.e. condition A was ignored)
		probList = engine.getProbList(0x0DL, null, null);
		assertEquals(2, probList.size());
		assertEquals(.5f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.5f, probList.get(1), PROB_ERROR_MARGIN);
		
		// check that in the history, the assumption A was ignored
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertNotNull(questionHistory);
		assertFalse(questionHistory.isEmpty());
		action = (AddTradeNetworkAction) questionHistory.get(questionHistory.size()-1);
		assertEquals((long)0x0D, (long)action.getQuestionId());
		assertTrue("Assumptions = " + action.getTradeId(), action.getAssumptionIds().isEmpty());
		
		// check history of questions
		boolean bkp = engine.isToRetriveOnlyTradeHistory();
		engine.setToRetriveOnlyTradeHistory(false);
		assertFalse(engine.getQuestionHistory(null, null, null).isEmpty());
		engine.setToRetriveOnlyTradeHistory(true);
		assertTrue(engine.getQuestionHistory(null, null, null).isEmpty());
		engine.setToRetriveOnlyTradeHistory(bkp);
		
		assertNotNull(engine.getScoreSummaryObject(userNameToIDMap.get("Tom"), null, null, null));
		assertFalse(engine.previewBalancingTrade(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(Float.isNaN(engine.getCash(userNameToIDMap.get("Tom"), null, null)));
		assertNotNull(engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0AL, 2, null, null));
		assertEquals(0,engine.getMaximumValidAssumptionsSublists(0x0AL, null, 1).get(0).size());
		assertTrue(engine.getPossibleQuestionAssumptions(0x0A, null).isEmpty());
		assertNotNull(engine.getScoreDetails(userNameToIDMap.get("Tom"), 0x0AL, null, null));
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		
		
		
		// test condition in which min is below 0 even though no entry in asset table is below 0
		
		// backup values before edit
		probListsBeforeTrade = engine.getProbLists(null, null, null);
		
		// assert that the min is positive
		assertTrue("Cash = " + engine.getCash(userNameToIDMap.get("Amy"), null, null), engine.getCash(userNameToIDMap.get("Amy"), null, null) > 0f);
		
		float emptySeparatorsDefaultContent = Float.NaN;
		try {
			emptySeparatorsDefaultContent = engine.getAlgorithmAndAssetNetFromUserID(userNameToIDMap.get("Amy")).getEmptySeparatorsDefaultContent();
			engine.getAlgorithmAndAssetNetFromUserID(userNameToIDMap.get("Amy")).setEmptySeparatorsDefaultContent(20);
		} catch (IllegalStateException e) {
			e.printStackTrace();
			fail();
		} catch (InvalidParentException e) {
			e.printStackTrace();
			fail();
		}
		
		// now the min should be negative
		assertFalse("Cash = " + engine.getCash(userNameToIDMap.get("Amy"), null, null), engine.getCash(userNameToIDMap.get("Amy"), null, null) > 0f);
		
		// do trade 
		newValues = new ArrayList<Float>();
		newValues.add(.3f); newValues.add(.3f); newValues.add(.4f);
		try {
			engine.addTrade(
					null, 
					new Date(), 
					"Amy makes a trade P(A) = [.3,.3,.4].", 
					userNameToIDMap.get("Amy"), 
					0X0AL, 
					newValues, 
					null, 
					null, 
					false
			);
			fail("Should throw exception indicating 0 or negative min");
		} catch (ZeroAssetsException e) {
			assertNotNull(e);
		}
		
		// probability of nodes present before this transaction must remain unchanged
		probListsAfterTrade = engine.getProbLists(null, null, null);
		for (Long id : probListsBeforeTrade.keySet()) {
			assertEquals("question = " + id , probListsBeforeTrade.get(id).size(), probListsAfterTrade.get(id).size());
			for (int i = 0; i < probListsBeforeTrade.get(id).size(); i++) {
				assertEquals("Question = " + id , probListsBeforeTrade.get(id).get(i), probListsAfterTrade.get(id).get(i), PROB_ERROR_MARGIN);
			}
		}
		
		
		try {
			engine.getAlgorithmAndAssetNetFromUserID(userNameToIDMap.get("Amy")).setEmptySeparatorsDefaultContent(emptySeparatorsDefaultContent);
		} catch (IllegalStateException e) {
			e.printStackTrace();
			fail();
		} catch (InvalidParentException e) {
			e.printStackTrace();
			fail();
		}
		
		// check that final min-q of Amy remains 6...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(6f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(6f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that new LPE of Amy is independent of E
		assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(0)), ASSET_ERROR_MARGIN);
		assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(1)), ASSET_ERROR_MARGIN);
		
		// check that LPE is d1 c1 f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0C);		// 2nd node is C; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, c1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// c1
		assumedStates.add(0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, c1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, c2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, c2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, c1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, c2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check incomplete condition of LPE: c1
		cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(0));
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(1));
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		
		// check history of questions
		bkp = engine.isToRetriveOnlyTradeHistory();
		engine.setToRetriveOnlyTradeHistory(false);
		assertFalse(engine.getQuestionHistory(null, null, null).isEmpty());
		engine.setToRetriveOnlyTradeHistory(true);
		assertTrue(engine.getQuestionHistory(null, null, null).isEmpty());
		engine.setToRetriveOnlyTradeHistory(bkp);
		
		assertNotNull(engine.getScoreSummaryObject(userNameToIDMap.get("Tom"), null, null, null));
		assertFalse(engine.previewBalancingTrade(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(Float.isNaN(engine.getCash(userNameToIDMap.get("Tom"), null, null)));
		assertNotNull(engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0AL, 2, null, null));
		assertEquals(0,engine.getMaximumValidAssumptionsSublists(0x0AL, null, 1).get(0).size());
		assertTrue(engine.getPossibleQuestionAssumptions(0x0A, null).isEmpty());
		assertNotNull(engine.getScoreDetails(userNameToIDMap.get("Tom"), 0x0AL, null, null));
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());
		
		// now, the trade should be OK to do this trade, because the empty separators were fixed
		engine.addTrade(
				null, 
				new Date(), 
				"Amy makes a trade P(A) = [.3,.3,.4].", 
				userNameToIDMap.get("Amy"), 
				0X0AL, 
				newValues, 
				null, 
				null, 
				false
		);
		
		// marginal is [.3,.3,.4]
		probList = engine.getProbList(0x0AL, null, null);
		assertEquals(3, probList.size());
		assertEquals(probList.get(0), .3f, PROB_ERROR_MARGIN);
		assertEquals(probList.get(1), .3f, PROB_ERROR_MARGIN);
		assertEquals(probList.get(2), .4f, PROB_ERROR_MARGIN);
		
		// assert that the min is positive
		assertTrue("Cash = " + engine.getCash(userNameToIDMap.get("Amy"), null, null), engine.getCash(userNameToIDMap.get("Amy"), null, null) > 0f);
		
		// check history of questions
		bkp = engine.isToRetriveOnlyTradeHistory();
		engine.setToRetriveOnlyTradeHistory(false);
		assertFalse(engine.getQuestionHistory(null, null, null).isEmpty());
		engine.setToRetriveOnlyTradeHistory(true);
		assertTrue(engine.getQuestionHistory(null, null, null).isEmpty());
		engine.setToRetriveOnlyTradeHistory(bkp);
		
		assertNotNull(engine.getScoreSummaryObject(userNameToIDMap.get("Tom"), null, null, null));
		assertFalse(engine.previewBalancingTrade(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(engine.getAssetsIfStates(userNameToIDMap.get("Tom"), 0x0AL, null, null).isEmpty());
		assertFalse(Float.isNaN(engine.getCash(userNameToIDMap.get("Tom"), null, null)));
		assertNotNull(engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0AL, 2, null, null));
		assertEquals(0,engine.getMaximumValidAssumptionsSublists(0x0AL, null, 1).get(0).size());
		assertTrue(engine.getPossibleQuestionAssumptions(0x0A, null).isEmpty());
		assertNotNull(engine.getScoreDetails(userNameToIDMap.get("Tom"), 0x0AL, null, null));
		assertFalse(engine.getQuestionAssumptionGroups().isEmpty());

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	
	/**
	 * Performs {@link #testAddTradeInOneTransaction()}, but with duplicated arcs (i.e. duplicate insertion of arcs)
	 */
	public final void testAddTradeInOneTransactionWithDuplicateArcs () {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		
		List<Long> duplicateParents = new ArrayList<Long>();
		duplicateParents.add(0x0DL);
		duplicateParents.add(0x0DL);
		
		// create edge [D,D]->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, duplicateParents , null);	// cpd == null -> linear distro
		// create edge [D,D]->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, duplicateParents, null);	// cpd == null -> linear distro
		// create edge D->E again
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F again
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Tom"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1) = 0.5  to 0.55", 
				userNameToIDMap.get("Tom"), 
				0x0E, 	// question E
				newValues,
				null, 	// no assumptions
				null, 	// no states of the assumptions
				false	// do not allow negative
			).isEmpty());
		
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Tom bets P(E=e1|D=d1) = 0.9", 
				userNameToIDMap.get("Tom"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		

		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Joe"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = 0.4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		

		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Amy"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Amy bets P(F=f1|D=d1) = 0.3", 
				userNameToIDMap.get("Amy"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = 0.1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		

		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		
		try {
			// Cannot obtain cash from user before network was initialized (Note: we did not commit the transaction yet, so the network is empty now)
			engine.getCash(userNameToIDMap.get("Eric"), null, null);
			fail("Engine should not allow us to access any data without initializing Bayesian network properly.");
		} catch (IllegalStateException e) {
			// OK. This is the expected
			assertNotNull(e);
		}
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Eric bets P(E=e1) = .65 -> .8
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = 0.8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			).isEmpty());
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		// cannot reuse same transaction key
		try {
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f);	newValues.add(.1f);
			engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
			fail("Should not allow to use commited transaction");
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
		}
		
		// check that the DEF network has a correct structure
		assertEquals(1,engine.getProbabilisticNetwork().getNode(""+0x0EL).getParents().size());
		assertEquals(1,engine.getProbabilisticNetwork().getNode(""+0x0FL).getParents().size());
		assertEquals(2,engine.getProbabilisticNetwork().getJunctionTree().getCliques().size());
		assertEquals(1,engine.getProbabilisticNetwork().getJunctionTree().getSeparators().size());
		assertEquals(2,engine.getProbabilisticNetwork().getEdges().size());
		
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		List<Float> probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		float minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
		assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		
		// check that min-q of Amy is 60...
		minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
		assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		
		// check that min-q of Joe is 14.5454545...
		minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * This method is used as a regression test of a bug which causes the
	 * {@link ProbabilisticNode#clone()}, called from {@link MarkovEngineImpl#scoreUserEv(long, List, List)} 
	 * not to copy empty cliques, causing inconsistency between probabilistic network and asset network.
	 */
	public final void testConditionalExpectedScoreWithEmptyCliques() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		engine.setDefaultInitialAssetTableValue(100);
		engine.setToDeleteResolvedNode(true);
		engine.addQuestion(null, new Date(), 1L, 3, null);
		engine.addQuestion(null, new Date(), 2L, 3, null);
		engine.addQuestion(null, new Date(), 3L, 3, null);
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 1L, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 1L, null, null).get(0));
		}

		engine.resolveQuestion(null, new Date(), 1, 0);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 2L, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 2L, null, null).get(0));
		}
		
		engine.resolveQuestion(null, new Date(), 2, 0);
		
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		assertEquals(1f, engine.getProbList(1, null, null).get(0));
		assertEquals(1f, engine.getProbList(2, null, null).get(0));
		try {
			float scoreUserEv = engine.scoreUserEv(Long.MAX_VALUE, Collections.singletonList(3L), Collections.singletonList(0));
			assertTrue("score = " + scoreUserEv, scoreUserEv > 0);
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Tests conditional min assets when user has 0 or negative assets.
	 * This was created because the min propagation was failing to
	 * set findings when there were non positive values
	 * in the asset table.
	 */
	public final void testConditional0OrNegativeAssets() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		List<Long> assumptionIds = new ArrayList<Long>();
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumptionIds.add(0x0DL); assumedStates.add(1);
		assumptionIds.add(0x0FL); assumedStates.add(0);
		assertEquals(0f,engine.getCash(Long.MAX_VALUE, assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
		assertNotNull(engine.getScoreSummaryObject(Long.MIN_VALUE, null, assumptionIds, assumedStates));

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Tests the following sequence of actions in a DEF network: <br/>
	 * 1 - Balance some question X<br/>
	 * 2 - Resolve question X<br/>
	 * 3 - Perform any action which rebuilds the DEF network (e.g. {@link MarkovEngineImpl#addQuestion(Long, Date, long, int, List)})<br/>
	 * <br/><br/>
	 * Case 2: <br/>
	 * 1 - Balance some question X assuming Y<br/>
	 * 2 - Resolve question Y<br/>
	 * 3 - Perform any action which rebuilds the DEF network (e.g. {@link MarkovEngineImpl#addQuestion(Long, Date, long, int, List)})<br/>
	 * <br/>
	 * This was created because engine was failing to redo trades when resolved questions are present.
	 */
	public final void testBalanceResolveRebuild() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// test with an engine which does not delete resolved nodes
		engine.setToDeleteResolvedNode(false);
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		// choose a random user
		String user = new ArrayList<String>(userNameToIDMap.keySet()).get((int) (Math.random()*userNameToIDMap.keySet().size()));
		
		// choose a random question from question which user has traded at least once
		List<Long> tradedQuestions = new ArrayList<Long>(engine.getTradedQuestions(userNameToIDMap.get(user)));
		Long questionId = tradedQuestions.get((int) (Math.random()*tradedQuestions.size()));
		
		// 0 - Resolve some question which is not the selected question
		Map<Long, List<Float>> probMap = engine.getProbLists(null, null, null);
		assertNotNull(probMap.remove(questionId));
		
		int settledState = (Math.random()<.5)?0:1;
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, probMap.keySet().iterator().next(), null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, probMap.keySet().iterator().next(), null, null).get(settledState));
		}

		engine.resolveQuestion(null, new Date(), probMap.keySet().iterator().next(), settledState );
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// 1 - Balance question
		assertTrue(engine.doBalanceTrade(null, new Date(), user + " balances question " + questionId, userNameToIDMap.get(user), questionId, null, null));
		
		// 2 - Resolve question
		settledState = (Math.random()<.5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, questionId, null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, questionId, null, null).get(settledState));
		}
		assertTrue(engine.resolveQuestion(null, new Date(), questionId, settledState));
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// 3 - Perform any action which rebuilds the DEF network (e.g. {@link MarkovEngineImpl#addQuestion(Long, Date, long, int, List)})
		assertTrue(engine.addQuestion(null, new Date(), Long.MIN_VALUE, 2, null));
		
		// case 2
		engine.initialize();
		userNameToIDMap.clear();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		List<Long> assumptionIds = Collections.singletonList(engine.getPossibleQuestionAssumptions(questionId, null).get(0));
		
		// 0 - Resolve some question which is not the selected questions
		probMap = engine.getProbLists(null, null, null);
		probMap.remove(questionId);
		probMap.remove(assumptionIds.get(0));
		assertFalse(probMap.isEmpty());
		
		settledState = (Math.random()<.5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, probMap.keySet().iterator().next(), null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, probMap.keySet().iterator().next(), null, null).get(settledState));
		}
		engine.resolveQuestion(null, new Date(), probMap.keySet().iterator().next(), settledState);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// 1 - Balance question given assumptions
		assertTrue(engine.doBalanceTrade(null, new Date(), user + " balances question " + questionId, 
				userNameToIDMap.get(user), questionId, assumptionIds, Collections.singletonList((Math.random()<.5)?0:1)));
		
		// 2 - Resolve assumed question
		settledState = (Math.random()<.5)?0:1;
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, assumptionIds.get(0), null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, assumptionIds.get(0), null, null).get(settledState));
		}
		
		assertTrue(engine.resolveQuestion(null, new Date(), assumptionIds.get(0), settledState));
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// 3 - Perform any action which rebuilds the DEF network (e.g. {@link MarkovEngineImpl#addQuestion(Long, Date, long, int, List)})
		assertTrue(engine.addQuestion(null, new Date(), Long.MAX_VALUE, 2, null));
		
		// test with an engine which deletes resolved nodes
		engine.setToDeleteResolvedNode(true);
		engine.initialize();
		userNameToIDMap.clear();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		// 1 - Balance question
		assertTrue(engine.doBalanceTrade(null, new Date(), user + " balances question " + questionId, userNameToIDMap.get(user), questionId, null, null));
		
		// 2 - Resolve question
		settledState = (Math.random()<.5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, questionId, null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, questionId, null, null).get(settledState));
		}
		assertTrue(engine.resolveQuestion(null, new Date(), questionId, settledState));
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// 3 - Perform any action which rebuilds the DEF network (e.g. {@link MarkovEngineImpl#addQuestion(Long, Date, long, int, List)})
		assertTrue(engine.addQuestion(null, new Date(), Long.MIN_VALUE, 2, null));
		
		// case 2
		engine.initialize();
		userNameToIDMap.clear();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		assumptionIds = Collections.singletonList(engine.getPossibleQuestionAssumptions(questionId, null).get(0));
		
		// 1 - Balance question given assumptions
		assertTrue(engine.doBalanceTrade(null, new Date(), user + " balances question " + questionId, 
				userNameToIDMap.get(user), questionId, assumptionIds, Collections.singletonList((Math.random()<.5)?0:1)));
		
		// 2 - Resolve assumed question
		settledState = (Math.random()<.5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, assumptionIds.get(0), null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, assumptionIds.get(0), null, null).get(settledState));
		}
		assertTrue(engine.resolveQuestion(null, new Date(), assumptionIds.get(0), settledState));
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// 3 - Perform any action which rebuilds the DEF network (e.g. {@link MarkovEngineImpl#addQuestion(Long, Date, long, int, List)})
		assertTrue(engine.addQuestion(null, new Date(), Long.MAX_VALUE, 2, null));
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Verify what happens when we revert a trade after resolving it
	 */
	public final void testResolveAndRevert() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		Set<Long> resolved = new HashSet<Long>();
		
		if (Math.random() < .5) {
			int settledState = (Math.random()<.5)?0:1;
			// get the expected score per node to be resolved for each user
			Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
			for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
				// store the expected score of the state to be resolved
				expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(settledState));
			}
			for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
				// store the expected score of the state to be resolved
				expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(settledState));
			}
			assertTrue(engine.resolveQuestion(null, new Date(), 0x0DL, settledState ));
			// check that the expected before resolve question is the current score
			for (Long userId : expectedScorePerUsers.keySet()) {
				assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
			}
			resolved.add(0x0DL);
		}
		if (Math.random() < .5) {
			int settledState = (Math.random()<.5)?0:1;
			// get the expected score per node to be resolved for each user
			Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
			for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
				// store the expected score of the state to be resolved
				expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(settledState));
			}
			for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
				// store the expected score of the state to be resolved
				expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(settledState));
			}
			assertTrue(engine.resolveQuestion(null, new Date(), 0x0EL, settledState ));
			// check that the expected before resolve question is the current score
			for (Long userId : expectedScorePerUsers.keySet()) {
				assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
			}
			resolved.add(0x0EL);
		}
		if (Math.random() < .5) {
			int settledState = (Math.random()<.5)?0:1;
			// get the expected score per node to be resolved for each user
			Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
			for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
				// store the expected score of the state to be resolved
				expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0FL, null, null).get(settledState));
			}
			for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
				// store the expected score of the state to be resolved
				expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0FL, null, null).get(settledState));
			}
			assertTrue(engine.resolveQuestion(null, new Date(), 0x0FL, settledState ));
			// check that the expected before resolve question is the current score
			for (Long userId : expectedScorePerUsers.keySet()) {
				assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
			}
			resolved.add(0x0FL);
		}
		
		assertTrue(engine.revertTrade(null, new Date(), new Date(0), (Math.random()<.5)?null:((Math.random()<.5)?0x0DL:((Math.random()<.5)?0x0EL:0X0F))));
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/** Yet another test case for regression test */
	public final void test5678Net() {
		// TODO make engine to work with this example when engine.isToAddArcsWithoutReboot() == true
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		engine.setToAddArcsWithoutReboot(false);
		
		engine.setDefaultInitialAssetTableValue(100f);
		engine.setCurrentCurrencyConstant(100f);
		engine.setCurrentLogBase(2f);
		
		engine.initialize();
		
		engine.addQuestion(null, new Date(), 8L	, 2, null);
		engine.addQuestion(null, new Date(), 5L	, 3, null);
		engine.addQuestion(null, new Date(), 7L	, 2, null);
		List<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add(8L); assumptionIds.add(5L);
		engine.addQuestionAssumption(null, new Date(), 7L, assumptionIds , null);
		engine.addQuestion(null, new Date(), 6L	, 2, null);
		engine.addQuestionAssumption(null, new Date(), 5L, Collections.singletonList(6L) , null);
		engine.addQuestionAssumption(null, new Date(), 8L, Collections.singletonList(6L) , null);
		
		// add nodes not related to the edit
		Long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey , new Date(), 0L, 2, null);
		engine.addQuestion(transactionKey , new Date(), 1L, 2, null);
		engine.addQuestion(transactionKey , new Date(), 2L, 2, null);
		engine.addQuestion(transactionKey , new Date(), 3L, 2, null);
		engine.addQuestion(transactionKey , new Date(), 4L, 2, null);
		engine.addQuestion(transactionKey , new Date(), 9L, 2, null);
		engine.addQuestionAssumption(transactionKey, new Date(), 1L, Collections.singletonList(0L), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 3L, Collections.singletonList(2L), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 3L, Collections.singletonList(4L), null);
		engine.commitNetworkActions(transactionKey);
		
		// assert that everything are uniform before trade
		for (Entry<Long, List<Float>> entry : engine.getProbLists(null, null, null).entrySet()) {
			for (Float prob : entry.getValue()) {
				assertEquals(1f/entry.getValue().size(), prob,PROB_ERROR_MARGIN);
			}
		}
		
		assertEquals(1,engine.getProbabilisticNetwork().getNode("1").getParents().size());
		assertTrue(engine.getProbabilisticNetwork().getNode("1").getParents().contains(engine.getProbabilisticNetwork().getNode("0")));
		assertEquals(2,engine.getProbabilisticNetwork().getNode("3").getParents().size());
		assertTrue(engine.getProbabilisticNetwork().getNode("3").getParents().contains(engine.getProbabilisticNetwork().getNode("2")));
		assertTrue(engine.getProbabilisticNetwork().getNode("3").getParents().contains(engine.getProbabilisticNetwork().getNode("4")));
		
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add(5L); assumptionIds.add(6L);
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(1); assumedStates.add(0);
		List<Float> editLimits = engine.getEditLimits(6, 8L, 1, assumptionIds, assumedStates);
		
		assertEquals(2,editLimits.size());
		assertEquals(.25f,editLimits.get(0), PROB_ERROR_MARGIN);
		assertEquals(.75f,editLimits.get(1), PROB_ERROR_MARGIN);
		
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(0.5510288f); newValues.add(0.4489712f);
		engine.addTrade(null, new Date(), "User 6 bets P(8|5=1,6=0) = [0.5510288, 0.4489712]", 6L, 8L, newValues , assumptionIds, assumedStates, false);
		
		Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
		assertTrue(4 <= probLists.size());
		float precision = PROB_ERROR_MARGIN;
		if (engine.isToAddArcsWithoutReboot()) {
			precision = 0.01f;
		}
		assertEquals(0.5085031f, probLists.get(8L).get(0),precision);
		assertEquals(0.49149314f, probLists.get(8L).get(1),precision);
		assertEquals(0.5f, probLists.get(6L).get(0),precision);
		assertEquals(0.5f, probLists.get(6L).get(1),precision);
		assertEquals(0.5f, probLists.get(7L).get(0),precision);
		assertEquals(0.5f, probLists.get(7L).get(1),precision);
		assertEquals(0.3333f, probLists.get(5L).get(0),precision);
		assertEquals(0.3333f, probLists.get(5L).get(1),precision);
		assertEquals(0.3333f, probLists.get(5L).get(2),precision);
		
		assertEquals(84.4694808988f, engine.getCash(6L, null, null), PROB_ERROR_MARGIN);
		assertEquals(100.1254412613f, engine.scoreUserEv(6L, null, null), PROB_ERROR_MARGIN);
	
		
		// restore backup
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
	}
	
	
	/** 
	 * Test method for {@link MarkovEngineImpl#exportNetwork(java.io.File)}
	 * and {@link MarkovEngineImpl#importNetwork(File)} 
	 */
	public final void testImportExportNetwork()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		engine.setToExportOnlyCurrentSharedProbabilisticNet(false);
		
		
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		// make sure the export works with resolved questions
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0X0DL, null, null).get(1));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0X0DL, null, null).get(1));
		}

		engine.resolveQuestion(null, new Date(), 0X0DL, 1);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		try {
			engine.setIO(new NetIO());
			engine.exportNetwork(new File("ExportedNetwork.net"));
		} catch (IOException e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		// assert that the exported file exists
		File fileToLoad = new File("ExportedNetwork.net");
		assertNotNull(fileToLoad);
		assertTrue(fileToLoad.exists());
		assertTrue(fileToLoad.isFile());
		
		// assert that the exported file is a net file 
		ProbabilisticNetwork loadedNet = null;
		try {
			loadedNet = (ProbabilisticNetwork) new NetIO().load(fileToLoad);
		} catch (IOException e) {
			e.printStackTrace();
			fileToLoad.delete();
			fail(e.getMessage());
		}
		assertNotNull(loadedNet);
		
		// assert that the exported file contains D (resolved), E, and F 
		assertEquals(3, loadedNet.getNodeCount());
		assertNotNull(loadedNet.getNode(engine.getExportedNodePrefix()+"13"));
		assertNotNull(loadedNet.getNode(engine.getExportedNodePrefix()+"14"));
		assertNotNull(loadedNet.getNode(engine.getExportedNodePrefix()+"15"));
		
		// assert that all cpts have uniform distributions
		for (Node node : loadedNet.getNodes()) {
			PotentialTable table = ((ProbabilisticNode)node).getProbabilityFunction();
			float expectedValue = (float) (1.0/node.getStatesSize());
			for (int i = 0; i < table.tableSize(); i++) {
				assertEquals(node.toString() + ", position " + i, expectedValue, table.getValue(i), PROB_ERROR_MARGIN);
			}
		}
		
		// edit the network and save again
		
		// add new node 10 (0x0A) with 3 states
		ProbabilisticNode nodeA = new ProbabilisticNode();
		nodeA.appendState("0");
		nodeA.appendState("1");
		nodeA.appendState("2");
		nodeA.setName(engine.getExportedNodePrefix()+"10");
		if (nodeA.getProbabilityFunction().getVariableIndex(nodeA) < 0) {
			nodeA.getProbabilityFunction().addVariable(nodeA);
		}
		loadedNet.addNode(nodeA);
		
		// add edge A -> E
		try {
			loadedNet.addEdge(new Edge(nodeA, loadedNet.getNode(engine.getExportedNodePrefix()+"14")));
		} catch (InvalidParentException e1) {
			e1.printStackTrace();
			fail(e1.getMessage());
		}
		
		// change prior probability of A
		PotentialTable tableOfA = nodeA.getProbabilityFunction();
		tableOfA.setValue(0, .1f);
		tableOfA.setValue(1, .2f);
		tableOfA.setValue(2, .7f);
		
		// change the conditional probability of E given D and A
		PotentialTable tableOfE = ((ProbabilisticNode)loadedNet.getNode(engine.getExportedNodePrefix()+"14")).getProbabilityFunction();
		tableOfE.setValue(0, .1f); tableOfE.setValue(1, .9f);	// d1 a1
		tableOfE.setValue(2, .2f); tableOfE.setValue(3, .8f);	// d2 a1
		tableOfE.setValue(4, .3f); tableOfE.setValue(5, .7f);	// d1 a2
		tableOfE.setValue(6, .4f); tableOfE.setValue(7, .6f);	// d2 a2
		tableOfE.setValue(8, .5f); tableOfE.setValue(9, .5f);	// d1 a3
		tableOfE.setValue(10, .6f); tableOfE.setValue(11, .4f);	// d2 a3
		
		
		// save again
		try {
			new NetIO().save(fileToLoad, loadedNet);
		} catch (IOException e) {
			e.printStackTrace();
			fileToLoad.delete();
			fail(e.getMessage());
		}
		
		// store marginals before the import for comparison
		Map<Long, List<Float>> probBeforeImport = engine.getProbLists(null, null, null);
		
		// store cash before the import for comparison
		Map<Long, Float> cashBeforeImport = new HashMap<Long, Float>();
		// fill cash
		for (Long userId : userNameToIDMap.values()) {
			cashBeforeImport.put(userId, engine.getCash(userId, null, null));
		}
		
		
		// now, test the import feature starting from a DEF net
		try {
			engine.importNetwork(fileToLoad);
		} catch (IOException e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		Map<Long, List<Float>> probAfterImport = engine.getProbLists(null, null, null);
		
		// make sure engine contains A
		assertTrue(engine.getProbLists(null, null, null).containsKey(0x0AL));
		
		// make sure history is retrieving some important changes in history
		List<QuestionEvent> history = engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(2));
		assertFalse(history.isEmpty());
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof VirtualTradeAction
					&& ( ((VirtualTradeAction)questionEvent).getParentAction() instanceof StructureChangeNetworkAction
						|| ((VirtualTradeAction)questionEvent).getParentAction() instanceof ResolveQuestionNetworkAction  ) ) ) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		// last probability in the history should match the current in history
		List<Float> probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(2));
		assertEquals(2, probList.size());
		assertEquals(2, history.get(history.size()-1).getNewValues().size());
		assertEquals(probList.toString(), probList.get(0), history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), probList.get(1), history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		
		// make sure history is retrieving changes in history
		history = engine.getQuestionHistory(0x0AL, null, null);
		assertFalse(history.isEmpty());
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof VirtualTradeAction
					&& ( ((VirtualTradeAction)questionEvent).getParentAction() instanceof StructureChangeNetworkAction
						|| ((VirtualTradeAction)questionEvent).getParentAction() instanceof ResolveQuestionNetworkAction  ) ) ) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		// last probability in the history should match the current in history
		probList = probAfterImport.get(0x0AL);
		assertEquals(3, probList.size());
		assertEquals(3, history.get(history.size()-1).getNewValues().size());
		assertEquals(probList.toString(), probList.get(0), history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), probList.get(1), history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), probList.get(2), history.get(history.size()-1).getNewValues().get(2), PROB_ERROR_MARGIN);
		// prob of A should also be equals to the specified in external edit
		assertEquals(probList.toString(), .1f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .2f, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .7f, probList.get(2), PROB_ERROR_MARGIN);
		
		
		// compare probability of E given A, assuming that D resolved at d2
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(0));
		assertEquals(probList.toString(), .2f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .8f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(1));
		assertEquals(probList.toString(), .4f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .6f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(2));
		assertEquals(probList.toString(), .6f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .4f, probList.get(1), PROB_ERROR_MARGIN);
		
		// probability of F should be equal
		assertEquals(probBeforeImport.toString() + "!=" + probAfterImport.toString(), probBeforeImport.get(0x0FL).size(), probAfterImport.get(0x0FL).size());
		for (int i = 0; i <  probBeforeImport.get(0x0FL).size(); i++) {
			assertEquals(
					probBeforeImport.toString() + "!=" + probAfterImport.toString(), 
					probBeforeImport.get(0x0FL).get(i), 
					probAfterImport.get(0x0FL).get(i),
					PROB_ERROR_MARGIN
				);
		}
		
		// cash should not have changed
		Map<Long, Float> cashAfterImport = new HashMap<Long, Float>();
		for (Long userId : userNameToIDMap.values()) {
			cashAfterImport.put(userId, engine.getCash(userId, null, null));
		}
		assertEquals(cashBeforeImport.toString() + " != " + cashAfterImport.toString(), cashBeforeImport.size(), cashAfterImport.size());
		for (Long userId : cashAfterImport.keySet()) {
			assertEquals(
					"User = " + userId + ", " + cashBeforeImport.toString() + " != " + cashAfterImport.toString(), 
					cashBeforeImport.get(userId), 
					cashAfterImport.get(userId), 
					ASSET_ERROR_MARGIN
				);
		}
		
		
		// add disconnected node 7 and trade and see if it's still OK
		assertTrue(engine.addQuestion(null, new Date(), 7L, 3, null));
		assertTrue(engine.addCash(null, new Date(), -7L, 1000, "Added cash to user -7"));
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.6f); newValues.add(.2f); newValues.add(.2f);
		assertFalse(engine.addTrade(null, new Date(), "User -7 trades on P(7)=[.6,.2,.2]", -7L, 7L, newValues, null, null, false).isEmpty());
		
		Map<Long, List<Float>> probAfterImport2 = engine.getProbLists(null, null, null);
		
		// new net have 1 additional node compared to previous
		assertEquals(probAfterImport.toString() + "->" + probAfterImport2.toString(), probAfterImport.size()+1, probAfterImport2.size());
		
		// the marginals for nodes in previous network should match with new network
		for (Long questionId : probAfterImport.keySet()) {
			assertEquals(probAfterImport.toString() + "->" + probAfterImport2.toString(), probAfterImport.get(questionId).size(), probAfterImport2.get(questionId).size());
			for (int i = 0; i < probAfterImport.get(questionId).size(); i++) {
				assertEquals(
						probAfterImport.toString() + "->" + probAfterImport2.toString(), 
						probAfterImport.get(questionId).get(i), 
						probAfterImport2.get(questionId).get(i), 
						PROB_ERROR_MARGIN
				);
			}
		}
		
		// marginal of node 7 should be [.6,.2,.2]
		assertEquals(probAfterImport2.toString(), 3, probAfterImport2.get(7L).size());
		assertEquals(probAfterImport2.toString(), .6f, probAfterImport2.get(7L).get(0), PROB_ERROR_MARGIN);
		assertEquals(probAfterImport2.toString(), .2f, probAfterImport2.get(7L).get(1), PROB_ERROR_MARGIN);
		assertEquals(probAfterImport2.toString(), .2f, probAfterImport2.get(7L).get(2), PROB_ERROR_MARGIN);
		
		
		// make sure engine still contains A
		assertTrue(engine.getProbLists(null, null, null).containsKey(0x0AL));
		
		// make sure history is still retrieving some important changes in history
		history = engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(2));
		assertFalse(history.isEmpty());
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof VirtualTradeAction
					&& ( ((VirtualTradeAction)questionEvent).getParentAction() instanceof StructureChangeNetworkAction
						|| ((VirtualTradeAction)questionEvent).getParentAction() instanceof ResolveQuestionNetworkAction  ) ) ) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		// last probability in the history should match the current in history
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(2));
		assertEquals(2, probList.size());
		assertEquals(2, history.get(history.size()-1).getNewValues().size());
		assertEquals(probList.toString(), probList.get(0), history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), probList.get(1), history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		
		// make sure history is still retrieving previous changes in history
		history = engine.getQuestionHistory(0x0AL, null, null);
		assertFalse(history.isEmpty());
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof VirtualTradeAction
					&& ( ((VirtualTradeAction)questionEvent).getParentAction() instanceof StructureChangeNetworkAction
						|| ((VirtualTradeAction)questionEvent).getParentAction() instanceof ResolveQuestionNetworkAction  ) ) ) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		// last probability in the history should match the current in history
		probList = probAfterImport.get(0x0AL);
		assertEquals(3, probList.size());
		assertEquals(3, history.get(history.size()-1).getNewValues().size());
		assertEquals(probList.toString(), probList.get(0), history.get(history.size()-1).getNewValues().get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), probList.get(1), history.get(history.size()-1).getNewValues().get(1), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), probList.get(2), history.get(history.size()-1).getNewValues().get(2), PROB_ERROR_MARGIN);
		
		
		// compare probability of E given A, assuming that D resolved at d2
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(0));
		assertEquals(probList.toString(), .2f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .8f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(1));
		assertEquals(probList.toString(), .4f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .6f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0AL), Collections.singletonList(2));
		assertEquals(probList.toString(), .6f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(probList.toString(), .4f, probList.get(1), PROB_ERROR_MARGIN);
		
		
		// cash should not have changed
		cashAfterImport = new HashMap<Long, Float>();
		for (Long userId : userNameToIDMap.values()) {
			cashAfterImport.put(userId, engine.getCash(userId, null, null));
		}
		assertEquals(cashBeforeImport.toString() + " != " + cashAfterImport.toString(), cashBeforeImport.size(), cashAfterImport.size());
		for (Long userId : cashAfterImport.keySet()) {
			assertEquals(
					"User = " + userId + ", " + cashBeforeImport.toString() + " != " + cashAfterImport.toString(), 
					cashBeforeImport.get(userId), 
					cashAfterImport.get(userId), 
					ASSET_ERROR_MARGIN
			);
		}
		
		
		// deleted tested file
		fileToLoad.delete();
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * This is just another regression test for verifying
	 * a discrepancy between {@link MarkovEngineImpl}
	 * and the matlab implementation. 
	 * The following steps will be performed, and the expected score of the user 9 is expected to be around 102.35:
	 * <br/><br/>
	 * addQuestion(questionId=8,numberStates=2)<br/>
	 * addQuestion(questionId=5,numberStates=3)<br/>
	 * addQuestion(questionId=7,numberStates=2)<br/>
	 * addQuestionAssumption(childQuestionId=7,parentQuestionIds=[8, 5])<br/>
	 * addQuestion(questionId=6,numberStates=2)<br/>
	 * addQuestionAssumption(childQuestionId=5,parentQuestionIds=[6])<br/>
	 * addQuestionAssumption(childQuestionId=8,parentQuestionIds=[6])<br/>
	 * getEditLimits(userId=6,questionId=8,questionState=1,assumptionIds=[5, 6],assumedStates=[1, 0])=[0.25, 0.75]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.5, 0.5], 4=[0.5, 0.5], 5=[0.3333333, 0.3333333, 0.3333333], 6=[0.49999997, 0.49999997], 7=[0.49999997, 0.49999997], 8=[0.49999997, 0.49999997], 9=[0.5, 0.5]}<br/>
	 * getCash(userId=6,assumptionIds=null,assumedStates=null)=100.0<br/>
	 * getCash(userId=6,assumptionIds=[5, 6],assumedStates=[1, 0])=100.0<br/>
	 * addTrade(occurredWhen=Wed Sep 05 07:16:47 BOT 2012,userId=6,questionId=8,newValues=[0.5510288, 0.4489712],assumptionIds=[5, 6],assumedStates=[1, 0])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.4999979, 0.4999979], 1=[0.4999979, 0.4999979], 2=[0.4999979, 0.4999979], 3=[0.4999979, 0.4999979], 4=[0.4999979, 0.4999979], 5=[0.3333328, 0.33333367, 0.3333328], 6=[0.4999989, 0.49999693], 7=[0.4999979, 0.4999979], 8=[0.5085031, 0.49149314], 9=[0.49999782, 0.49999782]}<br/>
	 * getCash(userId=6,assumptionIds=null,assumedStates=null)=84.4695<br/>
	 * getCash(userId=6,assumptionIds=[5, 6],assumedStates=[1, 0])=84.4695<br/>
	 * scoreUserEv(userId=6,assumptionIds=null,assumedStates=null)=100.12542<br/>
	 * getCash(userId=4,assumptionIds=null,assumedStates=null)=100.0<br/>
	 * getCash(userId=4,assumptionIds=[6, 8],assumedStates=[1, 1])=100.0<br/>
	 * addCash(userId=4,assets=55.029358)<br/>
	 * getEditLimits(userId=4,questionId=5,questionState=2,assumptionIds=[6, 8],assumedStates=[1, 1])=[0.113813534, 0.77237296]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.5, 0.5], 4=[0.5, 0.5], 5=[0.33333334, 0.33333334, 0.33333334], 6=[0.5, 0.5], 7=[0.5, 0.5], 8=[0.5085048, 0.49149522], 9=[0.5, 0.5]}<br/>
	 * getCash(userId=4,assumptionIds=null,assumedStates=null)=155.02936<br/>
	 * getCash(userId=4,assumptionIds=[6, 8],assumedStates=[1, 1])=155.02936<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:16:48 BOT 2012,userId=4,questionId=5,newValues=[0.1977148, 0.1977148, 0.60457015],assumptionIds=[6, 8],assumedStates=[1, 1])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999744, 0.49999744], 1=[0.49999744, 0.49999744], 2=[0.49999744, 0.49999744], 3=[0.49999744, 0.49999744], 4=[0.49999744, 0.49999744], 5=[0.2994283, 0.29942888, 0.40114138], 6=[0.4999989, 0.499996], 7=[0.49999744, 0.49999744], 8=[0.5085031, 0.4914929], 9=[0.49999782, 0.49999782]}<br/>
	 * getCash(userId=4,assumptionIds=null,assumedStates=null)=79.67487<br/>
	 * getCash(userId=4,assumptionIds=[6, 8],assumedStates=[1, 1])=79.67487<br/>
	 * scoreUserEV(userId=4,assumptionIds=null,assumedStates=null)=160.56232<br/>
	 * addQuestion(questionId=4,numberStates=2)<br/>
	 * addQuestion(questionId=3,numberStates=2)<br/>
	 * addQuestionAssumption(childQuestionId=3,parentQuestionIds=[4])<br/>
	 * getEditLimits(userId=0,questionId=4,questionState=0,assumptionIds=[3],assumedStates=[0])=[0.25, 0.75]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.5, 0.5], 4=[0.5, 0.5], 5=[0.2994287, 0.2994287, 0.40114254], 6=[0.5, 0.49999994], 7=[0.5, 0.5], 8=[0.5085048, 0.49149516], 9=[0.5, 0.5]}<br/>
	 * getCash(userId=0,assumptionIds=null,assumedStates=null)=100.0<br/>
	 * getCash(userId=0,assumptionIds=[3],assumedStates=[0])=100.0<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:18:00 BOT 2012,userId=0,questionId=4,newValues=[0.7248325, 0.2751689],assumptionIds=[3],assumedStates=[0])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.4999977, 0.4999977], 1=[0.4999977, 0.4999977], 2=[0.4999977, 0.4999977], 3=[0.49999797, 0.49999744], 4=[0.6124153, 0.3875832], 5=[0.29942897, 0.29942918, 0.4011416], 6=[0.49999803, 0.49999732], 7=[0.49999765, 0.49999765], 8=[0.50850254, 0.4914935], 9=[0.4999984, 0.4999984]}<br/>
	 * getCash(userId=0,assumptionIds=null,assumedStates=null)=13.838821<br/>
	 * getCash(userId=0,assumptionIds=[3],assumedStates=[0])=13.838821<br/>
	 * scoreUserEV(userId=0,assumptionIds=null,assumedStates=null)=107.56082<br/>
	 * getCash(userId=2,assumptionIds=null,assumedStates=null)=100.0<br/>
	 * getCash(userId=2,assumptionIds=[4],assumedStates=[0])=100.0<br/>
	 * addCash(userId=2,assets=53.335693)<br/>
	 * getEditLimits(userId=2,questionId=3,questionState=0,assumptionIds=[4],assumedStates=[0])=[0.20444407, 0.8589715]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.50000036, 0.4999997], 4=[0.61241585, 0.3875842], 5=[0.2994287, 0.2994287, 0.40114254], 6=[0.5, 0.49999994], 7=[0.5, 0.5], 8=[0.5085048, 0.49149516], 9=[0.5, 0.5]}<br/>
	 * getCash(userId=2,assumptionIds=null,assumedStates=null)=153.3357<br/>
	 * getCash(userId=2,assumptionIds=[4],assumedStates=[0])=153.3357<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:18:02 BOT 2012,userId=2,questionId=3,newValues=[0.78871393, 0.21128666],assumptionIds=[4],assumedStates=[0])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999982, 0.49999982], 1=[0.49999982, 0.49999982], 2=[0.49999982, 0.49999982], 3=[0.6206021, 0.3793949], 4=[0.61241585, 0.38758308], 5=[0.29942888, 0.2994291, 0.40114206], 6=[0.49999994, 0.49999967], 7=[0.4999998, 0.4999998], 8=[0.5085046, 0.491495], 9=[0.49999958, 0.49999958]}<br/>
	 * getCash(userId=2,assumptionIds=null,assumedStates=null)=58.321434<br/>
	 * getCash(userId=2,assumptionIds=[4],assumedStates=[0])=58.321434<br/>
	 * scoreUserEV(userId=2,assumptionIds=null,assumedStates=null)=161.05951<br/>
	 * getEditLimits(userId=9,questionId=6,questionState=0,assumptionIds=[5, 8],assumedStates=[0, 0])=[0.25, 0.75]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.2994287, 0.2994287, 0.40114254], 6=[0.5, 0.49999994], 7=[0.5, 0.5], 8=[0.5085048, 0.49149516], 9=[0.5, 0.5]}<br/>
	 * getCash(userId=9,assumptionIds=null,assumedStates=null)=100.0<br/>
	 * getCash(userId=9,assumptionIds=[5, 8],assumedStates=[0, 0])=100.0<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:18:03 BOT 2012,userId=9,questionId=6,newValues=[0.2824612, 0.71753895],assumptionIds=[5, 8],assumedStates=[0, 0])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5000001, 0.5000001], 1=[0.5000001, 0.5000001], 2=[0.5000001, 0.5000001], 3=[0.62060255, 0.379395], 4=[0.61241543, 0.38758317], 5=[0.29942867, 0.2994291, 0.40114206], 6=[0.46374366, 0.53625685], 7=[0.5000001, 0.5000001], 8=[0.50850505, 0.491495], 9=[0.49999952, 0.49999952]}<br/>
	 * getCash(userId=9,assumptionIds=null,assumedStates=null)=17.612444<br/>
	 * getCash(userId=9,assumptionIds=[5, 8],assumedStates=[0, 0])=17.612444<br/>
	 * scoreUserEV(userId=9,assumptionIds=null,assumedStates=null)=102.353615<br/>
	 * addQuestion(questionId=9,numberStates=2)<br/>
	 * getEditLimits(userId=0,questionId=9,questionState=0,assumptionIds=[],assumedStates=[])=[0.45426682, 0.5457332]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29942876, 0.2994287, 0.40114254], 6=[0.46374357, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.49149516], 9=[0.5, 0.5]}<br/>
	 * getCash(userId=0,assumptionIds=null,assumedStates=null)=13.838821<br/>
	 * getCash(userId=0,assumptionIds=[],assumedStates=[])=13.838821<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:19:49 BOT 2012,userId=0,questionId=9,newValues=[0.5312497, 0.4687494],assumptionIds=[],assumedStates=[])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.49999994], 1=[0.49999994, 0.49999994], 2=[0.49999994, 0.49999994], 3=[0.6206053, 0.37939516], 4=[0.6124166, 0.38758484], 5=[0.29942834, 0.2994288, 0.40114295], 6=[0.4637435, 0.5362562], 7=[0.4999998, 0.4999998], 8=[0.5085042, 0.49149504], 9=[0.531251, 0.4687496]}<br/>
	 * getCash(userId=0,assumptionIds=null,assumedStates=null)=4.5278234<br/>
	 * getCash(userId=0,assumptionIds=[],assumedStates=[])=4.5278234<br/>
	 * scoreUserEV(userId=0,assumptionIds=null,assumedStates=null)=114.30382<br/>
	 * addQuestion(questionId=1,numberStates=2)<br/>
	 * addQuestion(questionId=0,numberStates=2)<br/>
	 * addQuestionAssumption(childQuestionId=1,parentQuestionIds=[0])<br/>
	 * getEditLimits(userId=0,questionId=1,questionState=0,assumptionIds=[0],assumedStates=[1])=[0.48455146, 0.5154486]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29942873, 0.2994287, 0.40114254], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.49149516], 9=[0.5312502, 0.46874982]}<br/>
	 * getCash(userId=0,assumptionIds=null,assumedStates=null)=4.5278234<br/>
	 * getCash(userId=0,assumptionIds=[0],assumedStates=[1])=4.5278234<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:20:03 BOT 2012,userId=0,questionId=1,newValues=[0.48541012, 0.51459014],assumptionIds=[0],assumedStates=[1])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999985, 0.5000003], 1=[0.49270466, 0.5072953], 2=[0.50000006, 0.50000006], 3=[0.6206056, 0.37939495], 4=[0.6124163, 0.38758457], 5=[0.29942837, 0.29942843, 0.40114293], 6=[0.46374363, 0.5362562], 7=[0.5, 0.5], 8=[0.5085049, 0.4914949], 9=[0.53125113, 0.46874946]}<br/>
	 * getCash(userId=0,assumptionIds=null,assumedStates=null)=0.2554088<br/>
	 * getCash(userId=0,assumptionIds=[0],assumedStates=[1])=0.2554088<br/>
	 * scoreUserEV(userId=0,assumptionIds=null,assumedStates=null)=114.33453<br/>
	 * getEditLimits(userId=5,questionId=5,questionState=2,assumptionIds=[6, 8],assumedStates=[0, 1])=[0.1725362, 0.6725362]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29942873, 0.2994287, 0.40114254], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.49149516], 9=[0.5312502, 0.46874982]}<br/>
	 * getCash(userId=5,assumptionIds=null,assumedStates=null)=100.0<br/>
	 * getCash(userId=5,assumptionIds=[6, 8],assumedStates=[0, 1])=100.0<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:20:04 BOT 2012,userId=5,questionId=5,newValues=[0.313011, 0.28106615, 0.40592253],assumptionIds=[6, 8],assumedStates=[0, 1])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999973, 0.5], 1=[0.49270454, 0.507295], 2=[0.49999982, 0.49999982], 3=[0.62060565, 0.37939453], 4=[0.6124168, 0.38758388], 5=[0.29168558, 0.29247606, 0.4158375], 6=[0.46374315, 0.5362562], 7=[0.4999998, 0.4999998], 8=[0.5085049, 0.49149442], 9=[0.53125095, 0.46874893]}<br/>
	 * getCash(userId=5,assumptionIds=null,assumedStates=null)=85.93142<br/>
	 * getCash(userId=5,assumptionIds=[6, 8],assumedStates=[0, 1])=85.93142<br/>
	 * scoreUserEV(userId=5,assumptionIds=null,assumedStates=null)=100.2785<br/>
	 * getEditLimits(userId=2,questionId=8,questionState=0,assumptionIds=[5, 6],assumedStates=[0, 1])=[0.47227493, 0.8048]<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29168606, 0.2924763, 0.4158376], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.4914951], 9=[0.5312502, 0.46874982]}<br/>
	 * getCash(userId=2,assumptionIds=null,assumedStates=null)=58.321434<br/>
	 * getCash(userId=2,assumptionIds=[5, 6],assumedStates=[0, 1])=58.321434<br/>
	 * addQuestion(occurredWhen=Wed Sep 05 07:20:06 BOT 2012,userId=2,questionId=8,newValues=[0.6097233, 0.390277],assumptionIds=[5, 6],assumedStates=[0, 1])<br/>
	 * getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5000002, 0.49999994], 1=[0.49270457, 0.5072953], 2=[0.50000006, 0.50000006], 3=[0.6206052, 0.37939462], 4=[0.6124164, 0.3875839], 5=[0.29168588, 0.29247606, 0.4158375], 6=[0.46374315, 0.53625655], 7=[0.5, 0.5], 8=[0.49196953, 0.50803006], 9=[0.5312506, 0.46874934]}<br/>
	 * getCash(userId=2,assumptionIds=null,assumedStates=null)=36.85278<br/>
	 * getCash(userId=2,assumptionIds=[5, 6],assumedStates=[0, 1])=36.85278<br/>
	 * scoreUserEV(userId=2,assumptionIds=null,assumedStates=null)=161.59337<br/>
	 * addQuestion(questionId=2,numberStates=2)<br/>
	 * addQuestionAssumption(childQuestionId=3,parentQuestionIds=[2])<br/>
	 * addQuestionAssumption(childQuestionId=3,parentQuestionIds=[4, 2])<br/>
	 * getEditLimits(userId=9,questionId=2,questionState=0,assumptionIds=[4],assumedStates=[1])=[0.4425387, 0.55746126]<br/>
	 * resolveQuestion(questionId=2,settledState=0)<br/>
	 * getProbLists(questionIds=null,assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[1.0, 0.0], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.2916861, 0.2924763, 0.4158376], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.49196956, 0.5080304], 9=[0.5312502, 0.46874982]}<br/>
	 * [CAUTION]!!! scoreUserEV(userId=9,assumptionIds=null,assumedStates=null)=101.49192 (expected 102.35)<br/>
	 * [CAUTION]!!! scoreUserEV(userId=9,assumptionIds=[4],assumedStates=[1])=101.49193 (expected 102.35)<br/>
	 * scoreUserQuestionEvStates(userId=9,questionId=2,assumptionIds=[4],assumedStates=[1])=[101.49193, 0.0]<br/>
	 * getCashPerStates(userId=9,questionId=2,assumptionIds+[4],assumedStates=[1])=[17.612444, -Infinity]<br/>
	 * getCash(userId=9,assumptionIds=null,assumedStates=null)=17.612444<br/>
	 * getCash(userId=9,assumptionIds=[4],assumedStates=[1])=17.612444<br/>
	 * <br/>
	 * <br/>
	 * <br/>
	 * Users starts with 100 assets. The currency constant b is 100, and the base of log is 2
	 * 
	 */
	public final void testCompareWithExpectedFromMatlab()  {
		// TODO make engine to work with this example when engine.isToAddArcsWithoutReboot() == true
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		engine.setToAddArcsWithoutReboot(false);
				
		engine.setToUseQValues(false);					// use asset space instead of q-values
		engine.setCurrentCurrencyConstant(100f);		// b = 100
		engine.setCurrentLogBase(2f);					// base of log is 2
		engine.setDefaultInitialAssetTableValue(100f);	// users starts with 100 assets
		
		// reset engine
		assertTrue(engine.initialize());
		
//		 addQuestion(questionId=8,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 8L, 2, null));
		
//		 addQuestion(questionId=5,numberStates=3)
		assertTrue(engine.addQuestion(null, new Date(), 5L, 3, null));
		
//		 addQuestion(questionId=7,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 7L, 2, null));
		
//		 addQuestionAssumption(childQuestionId=7,parentQuestionIds=[8, 5])
		List<Long> questionIds = new ArrayList<Long>();
		questionIds.add(8L); questionIds.add(5L);
		assertTrue(engine.addQuestionAssumption(null, new Date(), 7L, questionIds , null));
		
//		 addQuestion(questionId=6,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 6L, 2, null));
		
//		 addQuestionAssumption(childQuestionId=5,parentQuestionIds=[6])
		questionIds = new ArrayList<Long>();
		questionIds.add(6L);
		assertTrue(engine.addQuestionAssumption(null, new Date(), 5L, questionIds , null));

//		 addQuestionAssumption(childQuestionId=8,parentQuestionIds=[6])
		assertTrue(engine.addQuestionAssumption(null, new Date(), 8L, questionIds , null));
		
//		 getEditLimits(userId=6,questionId=8,questionState=1,assumptionIds=[5, 6],assumedStates=[1, 0])=[0.25, 0.75]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.5, 0.5], 4=[0.5, 0.5], 5=[0.3333333, 0.3333333, 0.3333333], 6=[0.49999997, 0.49999997], 7=[0.49999997, 0.49999997], 8=[0.49999997, 0.49999997], 9=[0.5, 0.5]}
//		 getCash(userId=6,assumptionIds=null,assumedStates=null)=100.0
//		 getCash(userId=6,assumptionIds=[5, 6],assumedStates=[1, 0])=100.0
		
		
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:16:47 BOT 2012,userId=6,questionId=8,newValues=[0.5510288, 0.4489712],assumptionIds=[5, 6],assumedStates=[1, 0])
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(0.5510288f);
		newValues.add(0.4489712f);
		questionIds = new ArrayList<Long>();
		questionIds.add(5L); questionIds.add(6L);
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(1); assumedStates.add(0);
		assertFalse(engine.addTrade(null, new Date(), "", 6, 8, newValues, questionIds, assumedStates , false).isEmpty());
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.4999979, 0.4999979], 1=[0.4999979, 0.4999979], 2=[0.4999979, 0.4999979], 3=[0.4999979, 0.4999979], 4=[0.4999979, 0.4999979], 5=[0.3333328, 0.33333367, 0.3333328], 6=[0.4999989, 0.49999693], 7=[0.4999979, 0.4999979], 8=[0.5085031, 0.49149314], 9=[0.49999782, 0.49999782]}
//		 getCash(userId=6,assumptionIds=null,assumedStates=null)=84.4695
//		 getCash(userId=6,assumptionIds=[5, 6],assumedStates=[1, 0])=84.4695
//		 scoreUserEv(userId=6,assumptionIds=null,assumedStates=null)=100.12542
//		 getCash(userId=4,assumptionIds=null,assumedStates=null)=100.0
//		 getCash(userId=4,assumptionIds=[6, 8],assumedStates=[1, 1])=100.0
		
		
//		 addCash(userId=4,assets=55.029358)
		assertTrue(engine.addCash(null, new Date(), 4, 55.029358f, ""));
		
//		 getEditLimits(userId=4,questionId=5,questionState=2,assumptionIds=[6, 8],assumedStates=[1, 1])=[0.113813534, 0.77237296]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.5, 0.5], 4=[0.5, 0.5], 5=[0.33333334, 0.33333334, 0.33333334], 6=[0.5, 0.5], 7=[0.5, 0.5], 8=[0.5085048, 0.49149522], 9=[0.5, 0.5]}
//		 getCash(userId=4,assumptionIds=null,assumedStates=null)=155.02936
//		 getCash(userId=4,assumptionIds=[6, 8],assumedStates=[1, 1])=155.02936
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:16:48 BOT 2012,userId=4,questionId=5,newValues=[0.1977148, 0.1977148, 0.60457015],assumptionIds=[6, 8],assumedStates=[1, 1])
		newValues = new ArrayList<Float>();
		newValues.add(0.1977148f);
		newValues.add(0.1977148f);
		newValues.add(0.60457015f);
		questionIds = new ArrayList<Long>();
		questionIds.add(6L); questionIds.add(8L);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1); assumedStates.add(1);
		assertFalse(engine.addTrade(null, new Date(), "", 4,5, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999744, 0.49999744], 1=[0.49999744, 0.49999744], 2=[0.49999744, 0.49999744], 3=[0.49999744, 0.49999744], 4=[0.49999744, 0.49999744], 5=[0.2994283, 0.29942888, 0.40114138], 6=[0.4999989, 0.499996], 7=[0.49999744, 0.49999744], 8=[0.5085031, 0.4914929], 9=[0.49999782, 0.49999782]}
//		 getCash(userId=4,assumptionIds=null,assumedStates=null)=79.67487
//		 getCash(userId=4,assumptionIds=[6, 8],assumedStates=[1, 1])=79.67487
//		 scoreUserEv(userId=4,assumptionIds=null,assumedStates=null)=160.56232
		
		
//		 addQuestion(questionId=4,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 4L, 2, null));
		
		
//		 addQuestion(questionId=3,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 3L, 2, null));
		
		
//		 addQuestionAssumption(childQuestionId=3,parentQuestionIds=[4])
		questionIds = new ArrayList<Long>();
		questionIds.add(4L);
		assertTrue(engine.addQuestionAssumption(null, new Date(), 3L, questionIds , null));
		
		
//		 getEditLimits(userId=0,questionId=4,questionState=0,assumptionIds=[3],assumedStates=[0])=[0.25, 0.75]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.5, 0.5], 4=[0.5, 0.5], 5=[0.2994287, 0.2994287, 0.40114254], 6=[0.5, 0.49999994], 7=[0.5, 0.5], 8=[0.5085048, 0.49149516], 9=[0.5, 0.5]}
//		 getCash(userId=0,assumptionIds=null,assumedStates=null)=100.0
//		 getCash(userId=0,assumptionIds=[3],assumedStates=[0])=100.0
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:18:00 BOT 2012,userId=0,questionId=4,newValues=[0.7248325, 0.2751689],assumptionIds=[3],assumedStates=[0])
		newValues = new ArrayList<Float>();
		newValues.add(0.7248325f);
		newValues.add(0.2751689f);
		questionIds = new ArrayList<Long>();
		questionIds.add(3L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assertFalse(engine.addTrade(null, new Date(), "",0,4, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.4999977, 0.4999977], 1=[0.4999977, 0.4999977], 2=[0.4999977, 0.4999977], 3=[0.49999797, 0.49999744], 4=[0.6124153, 0.3875832], 5=[0.29942897, 0.29942918, 0.4011416], 6=[0.49999803, 0.49999732], 7=[0.49999765, 0.49999765], 8=[0.50850254, 0.4914935], 9=[0.4999984, 0.4999984]}
//		 getCash(userId=0,assumptionIds=null,assumedStates=null)=13.838821
//		 getCash(userId=0,assumptionIds=[3],assumedStates=[0])=13.838821
//		 scoreUserEv(userId=0,assumptionIds=null,assumedStates=null)=107.56082
//		 getCash(userId=2,assumptionIds=null,assumedStates=null)=100.0
//		 getCash(userId=2,assumptionIds=[4],assumedStates=[0])=100.0
		
		
//		 addCash(userId=2,assets=53.335693)
		assertTrue(engine.addCash(null, new Date(), 2, 53.335693f, ""));
		
		
//		 getEditLimits(userId=2,questionId=3,questionState=0,assumptionIds=[4],assumedStates=[0])=[0.20444407, 0.8589715]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.50000036, 0.4999997], 4=[0.61241585, 0.3875842], 5=[0.2994287, 0.2994287, 0.40114254], 6=[0.5, 0.49999994], 7=[0.5, 0.5], 8=[0.5085048, 0.49149516], 9=[0.5, 0.5]}
//		 getCash(userId=2,assumptionIds=null,assumedStates=null)=153.3357
//		 getCash(userId=2,assumptionIds=[4],assumedStates=[0])=153.3357
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:18:02 BOT 2012,userId=2,questionId=3,newValues=[0.78871393, 0.21128666],assumptionIds=[4],assumedStates=[0])
		newValues = new ArrayList<Float>();
		newValues.add(0.78871393f);
		newValues.add(0.21128666f);
		questionIds = new ArrayList<Long>();
		questionIds.add(4L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assertFalse(engine.addTrade(null, new Date(), "",2,3, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999982, 0.49999982], 1=[0.49999982, 0.49999982], 2=[0.49999982, 0.49999982], 3=[0.6206021, 0.3793949], 4=[0.61241585, 0.38758308], 5=[0.29942888, 0.2994291, 0.40114206], 6=[0.49999994, 0.49999967], 7=[0.4999998, 0.4999998], 8=[0.5085046, 0.491495], 9=[0.49999958, 0.49999958]}
//		 getCash(userId=2,assumptionIds=null,assumedStates=null)=58.321434
//		 getCash(userId=2,assumptionIds=[4],assumedStates=[0])=58.321434
//		 scoreUserEv(userId=2,assumptionIds=null,assumedStates=null)=161.05951
//		 getEditLimits(userId=9,questionId=6,questionState=0,assumptionIds=[5, 8],assumedStates=[0, 0])=[0.25, 0.75]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.2994287, 0.2994287, 0.40114254], 6=[0.5, 0.49999994], 7=[0.5, 0.5], 8=[0.5085048, 0.49149516], 9=[0.5, 0.5]}
//		 getCash(userId=9,assumptionIds=null,assumedStates=null)=100.0
//		 getCash(userId=9,assumptionIds=[5, 8],assumedStates=[0, 0])=100.0
		
		// trade of iteration number 5
		{
			// Before Iteration#5, the joint probabilities should be
//		    node_names: {'6'  '5'  '8'  '7'  '3'  '4'}
//		         sizes: [2 3 2 2 2 2]
//		joint probabilities:
			float[] jointIteration5 = {
		        0.0201258844722234f,	// 6=0,5=0,8=0,7=0,3=0,4=0
		        0.0201258844722234f,	// 6=1,5=0,8=0,7=0,3=0,4=0
		        0.0221798839393358f,	// 6=0,5=1,8=0,7=0,3=0,4=0
		        0.0201258844722234f,	// 6=1,5=1,8=0,7=0,3=0,4=0
		        0.0201258844722234f,
		        0.0201258844722234f,
		        0.0201258844722234f,
		        0.0119375556697463f,
		         0.018071885005111f,
		        0.0119375556697463f,
		        0.0201258844722234f,
		        0.0365025269827644f,
		        0.0201258844722234f,
		        0.0201258844722234f,
		        0.0221798839393358f,
		        0.0201258844722234f,
		        0.0201258844722234f,
		        0.0201258844722234f,
		        0.0201258844722234f,
		        0.0119375556697463f,
		         0.018071885005111f,
		        0.0119375556697463f,
		        0.0201258844722234f,
		        0.0365025269827644f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00594171526389791f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00319792280836825f,
		       0.00484123340212084f,
		       0.00319792280836825f,
		       0.00539147433300938f,
		       0.00977857333868589f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00594171526389791f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00539147433300938f,
		       0.00319792280836825f,
		       0.00484123340212084f,
		       0.00319792280836825f,
		       0.00539147433300938f,
		       0.00977857333868589f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		       0.00631774953184667f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		        0.0034003102518575f,
		       0.00514762130148667f,
		        0.0034003102518575f,
		       0.00573268541666667f,
		        0.0103974314467709f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		       0.00631774953184667f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		       0.00573268541666667f,
		        0.0034003102518575f,
		       0.00514762130148667f,
		        0.0034003102518575f,
		       0.00573268541666667f,
		        0.0103974314467709f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		        0.0114797666666667f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		              0.0061785875f,
		       0.00935356666666667f,
		              0.0061785875f,
		        0.0104166666666667f,
		           0.0188928171875f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		        0.0114797666666667f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		        0.0104166666666667f,
		              0.0061785875f,
		       0.00935356666666667f,
		              0.0061785875f,
		        0.0104166666666667f,
		           0.0188928171875f,
			};
			
			// check that the matlab is summing up to 1
			float sum = 0f;
			for (int i = 0; i < jointIteration5.length; i++) {
				sum += jointIteration5[i];
			}
			assertEquals(1f, sum, PROB_ERROR_MARGIN);
			
			// check joint probabilities
//		    node_names: {'6'  '5'  '8'  '7'  '3'  '4'}
			questionIds = new ArrayList<Long>();
			questionIds.add(6L); questionIds.add(5L); questionIds.add(8L);
			questionIds.add(7L); questionIds.add(3L); questionIds.add(4L);
			// start from all questions in state 0
			List<Integer> states = new ArrayList<Integer>();
			states.add(0); states.add(0); states.add(0);
			states.add(0); states.add(0); states.add(0);
			// index to be used to access joint probability
			int indexForJointProbability = 0;	
			sum = 0;	// check that joint prob of ME is summing up to 1
			// compare joint probability returned by the engine and expected
			for (int stateNode4 = 0; stateNode4 < 2; stateNode4++) {	// iterate on states of node 4
				for (int stateNode3 = 0; stateNode3 < 2; stateNode3++) {	// iterate on states of node 3
					for (int stateNode7 = 0; stateNode7 < 2; stateNode7++) {	// iterate on states of node 7
						for (int stateNode8 = 0; stateNode8 < 2; stateNode8++) {	// iterate on states of node 8
							for (int stateNode5 = 0; stateNode5 < 3; stateNode5++) {	// iterate on states of node 5
								for (int stateNode6 = 0; stateNode6 < 2; stateNode6++) {	// iterate on states of node 6
									// set states accourdingly to current iteration
									states.set(0, stateNode6); states.set(1, stateNode5); states.set(2, stateNode8);
									states.set(3, stateNode7); states.set(4, stateNode3); states.set(5, stateNode4);
									// obtain the joint probability from engine
									float jointProbability = engine.getJointProbability(questionIds, states);
									// compare results
//									System.out.format(
//											"%d,%d,%d,%d,%d,%d,%1.20f,%1.20f%n",
//											stateNode6,stateNode5,stateNode8,stateNode7,stateNode3,stateNode4 ,
//											jointIteration5[indexForJointProbability],jointProbability);
									assertEquals(
											"joint index = " + indexForJointProbability + "; "
											+ "[6,5,8,7,3,4]=["
											+ stateNode6+"," + stateNode5+","+ stateNode8+","+ stateNode7+","+ stateNode3+","+ stateNode4 + "]", 
											jointIteration5[indexForJointProbability], 
											jointProbability, 
											PROB_ERROR_MARGIN //0.00005
										);
									sum += jointProbability;
									indexForJointProbability++;	// point to next item in jointBeforeIteration5
								}
							}
						}
					}
				}
			}
			assertEquals(1f, sum, PROB_ERROR_MARGIN);
		}
		
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:18:03 BOT 2012,userId=9,questionId=6,newValues=[0.2824612, 0.71753895],assumptionIds=[5, 8],assumedStates=[0, 0])
		newValues = new ArrayList<Float>();
		newValues.add(0.2824612f);
		newValues.add(0.71753895f);
		questionIds = new ArrayList<Long>();
		questionIds.add(5L); 
		questionIds.add(8L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assumedStates.add(0); 
		assertFalse(engine.addTrade(null, new Date(), "",9,6, newValues, questionIds, assumedStates , false).isEmpty());
		
		assertEquals(102.35, engine.scoreUserEv(9L, null, null), ASSET_ERROR_MARGIN);
		
//		After Iteration #5, joint probabilities should be:
		float[] jointIteration5 = {
				0.0113695629581712f,	// 6=0,5=0,8=0,7=0,3=0,4=0
				0.028882212024041f,		// 6=1,5=0,8=0,7=0,3=0,4=0
				0.0221798839393358f,	// 6=0,5=1,8=0,7=0,3=0,4=0
				0.0201258844722234f,	// 6=1,5=1,8=0,7=0,3=0,4=0
				0.0201258844722234f,
				0.0201258844722234f,
				0.0201258844722234f,
				0.0119375556697463f,
				0.018071885005111f,
				0.0119375556697463f,
				0.0201258844722234f,
				0.0365025269827644f,
				0.0113695629581712f,
				0.028882212024041f,
				0.0221798839393358f,
				0.0201258844722234f,
				0.0201258844722234f,
				0.0201258844722234f,
				0.0201258844722234f,
				0.0119375556697463f,
				0.018071885005111f,
				0.0119375556697463f,
				0.0201258844722234f,
				0.0365025269827644f,
				0.00304576461974206f,
				0.007737185663719f,
				0.00594171526389791f,
				0.00539147433300938f,
				0.00539147433300938f,
				0.00539147433300938f,
				0.00539147433300938f,
				0.00319792280836825f,
				0.00484123340212084f,
				0.00319792280836825f,
				0.00539147433300938f,
				0.00977857333868589f,
				0.00304576461974206f,
				0.007737185663719f,
				0.00594171526389791f,
				0.00539147433300938f,
				0.00539147433300938f,
				0.00539147433300938f,
				0.00539147433300938f,
				0.00319792280836825f,
				0.00484123340212084f,
				0.00319792280836825f,
				0.00539147433300938f,
				0.00977857333868589f,
				0.00323852240402833f,
				0.00822685014911062f,
				0.00631774953184667f,
				0.00573268541666667f,
				0.00573268541666667f,
				0.00573268541666667f,
				0.00573268541666667f,
				0.0034003102518575f,
				0.00514762130148667f,
				0.0034003102518575f,
				0.00573268541666667f,
				0.0103974314467709f,
				0.00323852240402833f,
				0.00822685014911062f,
				0.00631774953184667f,
				0.00573268541666667f,
				0.00573268541666667f,
				0.00573268541666667f,
				0.00573268541666667f,
				0.0034003102518575f,
				0.00514762130148667f,
				0.0034003102518575f,
				0.00573268541666667f,
				0.0103974314467709f,
				0.00588460833333333f,
				0.014948728125f,
				0.0114797666666667f,
				0.0104166666666667f,
				0.0104166666666667f,
				0.0104166666666667f,
				0.0104166666666667f,
				0.0061785875f,
				0.00935356666666667f,
				0.0061785875f,
				0.0104166666666667f,
				0.0188928171875f,
				0.00588460833333333f,
				0.014948728125f,
				0.0114797666666667f,
				0.0104166666666667f,
				0.0104166666666667f,
				0.0104166666666667f,
				0.0104166666666667f,
				0.0061785875f,
				0.00935356666666667f,
				0.0061785875f,
				0.0104166666666667f,
				0.0188928171875f,
		};
		// check that the matlab is summing up to 1
		float sum = 0f;
		for (int i = 0; i < jointIteration5.length; i++) {
			sum += jointIteration5[i];
		}
		assertEquals(1f, sum, PROB_ERROR_MARGIN);
		
		// check joint probabilities
//		    node_names: {'6'  '5'  '8'  '7'  '3'  '4'}
		questionIds = new ArrayList<Long>();
		questionIds.add(6L); questionIds.add(5L); questionIds.add(8L);
		questionIds.add(7L); questionIds.add(3L); questionIds.add(4L);
		// start from all questions in state 0
		List<Integer> states = new ArrayList<Integer>();
		states.add(0); states.add(0); states.add(0);
		states.add(0); states.add(0); states.add(0);
		// index to be used to access joint probability
		int indexForJointProbability = 0;	
		sum = 0;	// check that joint prob of ME is summing up to 1
		// compare joint probability returned by the engine and expected
		for (int stateNode4 = 0; stateNode4 < 2; stateNode4++) {	// iterate on states of node 4
			for (int stateNode3 = 0; stateNode3 < 2; stateNode3++) {	// iterate on states of node 3
				for (int stateNode7 = 0; stateNode7 < 2; stateNode7++) {	// iterate on states of node 7
					for (int stateNode8 = 0; stateNode8 < 2; stateNode8++) {	// iterate on states of node 8
						for (int stateNode5 = 0; stateNode5 < 3; stateNode5++) {	// iterate on states of node 5
							for (int stateNode6 = 0; stateNode6 < 2; stateNode6++) {	// iterate on states of node 6
								// set states accourdingly to current iteration
								states.set(0, stateNode6); states.set(1, stateNode5); states.set(2, stateNode8);
								states.set(3, stateNode7); states.set(4, stateNode3); states.set(5, stateNode4);
								// obtain the joint probability from engine
								float jointProbability = engine.getJointProbability(questionIds, states);
								// compare results
//								System.out.format(
//										"%d,%d,%d,%d,%d,%d,%1.20f,%1.20f%n",
//										stateNode6,stateNode5,stateNode8,stateNode7,stateNode3,stateNode4 ,
//										jointIteration5[indexForJointProbability],jointProbability);
								assertEquals(
										"joint index = " + indexForJointProbability + "; "
										+ "[6,5,8,7,3,4]=["
										+ stateNode6+"," + stateNode5+","+ stateNode8+","+ stateNode7+","+ stateNode3+","+ stateNode4 + "]", 
										jointIteration5[indexForJointProbability], 
										jointProbability, 
										0.00005
								);
								sum += jointProbability;
								indexForJointProbability++;	// point to next item in jointBeforeIteration5
							}
						}
					}
				}
			}
		}
		assertEquals(1f, sum, PROB_ERROR_MARGIN);
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5000001, 0.5000001], 1=[0.5000001, 0.5000001], 2=[0.5000001, 0.5000001], 3=[0.62060255, 0.379395], 4=[0.61241543, 0.38758317], 5=[0.29942867, 0.2994291, 0.40114206], 6=[0.46374366, 0.53625685], 7=[0.5000001, 0.5000001], 8=[0.50850505, 0.491495], 9=[0.49999952, 0.49999952]}
//		 getCash(userId=9,assumptionIds=null,assumedStates=null)=17.612444
//		 getCash(userId=9,assumptionIds=[5, 8],assumedStates=[0, 0])=17.612444
//		 scoreUserEv(userId=9,assumptionIds=null,assumedStates=null)=102.353615
		
		
//		 addQuestion(questionId=9,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 9L, 2, null));
		
		
//		 getEditLimits(userId=0,questionId=9,questionState=0,assumptionIds=[],assumedStates=[])=[0.45426682, 0.5457332]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29942876, 0.2994287, 0.40114254], 6=[0.46374357, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.49149516], 9=[0.5, 0.5]}
//		 getCash(userId=0,assumptionIds=null,assumedStates=null)=13.838821
//		 getCash(userId=0,assumptionIds=[],assumedStates=[])=13.838821
		
		// check that addding a question did not change joint probability of other nodes
		
		questionIds = new ArrayList<Long>();
		questionIds.add(6L); questionIds.add(5L); questionIds.add(8L);
		questionIds.add(7L); questionIds.add(3L); questionIds.add(4L);
		// start from all questions in state 0
		states = new ArrayList<Integer>();
		states.add(0); states.add(0); states.add(0);
		states.add(0); states.add(0); states.add(0);
		// index to be used to access joint probability
		indexForJointProbability = 0;	
		sum = 0;	// check that joint prob of ME is summing up to 1
		// compare joint probability returned by the engine and expected
		for (int stateNode4 = 0; stateNode4 < 2; stateNode4++) {	// iterate on states of node 4
			for (int stateNode3 = 0; stateNode3 < 2; stateNode3++) {	// iterate on states of node 3
				for (int stateNode7 = 0; stateNode7 < 2; stateNode7++) {	// iterate on states of node 7
					for (int stateNode8 = 0; stateNode8 < 2; stateNode8++) {	// iterate on states of node 8
						for (int stateNode5 = 0; stateNode5 < 3; stateNode5++) {	// iterate on states of node 5
							for (int stateNode6 = 0; stateNode6 < 2; stateNode6++) {	// iterate on states of node 6
								// set states accourdingly to current iteration
								states.set(0, stateNode6); states.set(1, stateNode5); states.set(2, stateNode8);
								states.set(3, stateNode7); states.set(4, stateNode3); states.set(5, stateNode4);
								// obtain the joint probability from engine
								float jointProbability = engine.getJointProbability(questionIds, states);
								// compare results
//								System.out.format(
//										"%d,%d,%d,%d,%d,%d,%1.20f,%1.20f%n",
//										stateNode6,stateNode5,stateNode8,stateNode7,stateNode3,stateNode4 ,
//										jointIteration5[indexForJointProbability],jointProbability);
								assertEquals(
										"joint index = " + indexForJointProbability + "; "
										+ "[6,5,8,7,3,4]=["
										+ stateNode6+"," + stateNode5+","+ stateNode8+","+ stateNode7+","+ stateNode3+","+ stateNode4 + "]", 
										jointIteration5[indexForJointProbability], 
										jointProbability, 
										0.00005
								);
								sum += jointProbability;
								indexForJointProbability++;	// point to next item in jointBeforeIteration5
							}
						}
					}
				}
			}
		}
		assertEquals(1f, sum, PROB_ERROR_MARGIN);
		
//		 addTrade(occurredWhen=Wed Sep 05 07:19:49 BOT 2012,userId=0,questionId=9,newValues=[0.5312497, 0.4687494],assumptionIds=[],assumedStates=[])
		newValues = new ArrayList<Float>();
		newValues.add(0.5312497f);
		newValues.add(0.4687494f);
		questionIds = new ArrayList<Long>();
		assumedStates = new ArrayList<Integer>();
		assertFalse(engine.addTrade(null, new Date(), "",0,9, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.49999994], 1=[0.49999994, 0.49999994], 2=[0.49999994, 0.49999994], 3=[0.6206053, 0.37939516], 4=[0.6124166, 0.38758484], 5=[0.29942834, 0.2994288, 0.40114295], 6=[0.4637435, 0.5362562], 7=[0.4999998, 0.4999998], 8=[0.5085042, 0.49149504], 9=[0.531251, 0.4687496]}
//		 getCash(userId=0,assumptionIds=null,assumedStates=null)=4.5278234
//		 getCash(userId=0,assumptionIds=[],assumedStates=[])=4.5278234
//		 scoreUserEv(userId=0,assumptionIds=null,assumedStates=null)=114.30382
		
		
//		 addQuestion(questionId=1,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 1L, 2, null));
		
		
//		 addQuestion(questionId=0,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 0L, 2, null));
		
		
//		 addQuestionAssumption(childQuestionId=1,parentQuestionIds=[0])
		questionIds = new ArrayList<Long>();
		questionIds.add(0L);
		assertTrue(engine.addQuestionAssumption(null, new Date(), 1L, questionIds , null));
		
		
//		 getEditLimits(userId=0,questionId=1,questionState=0,assumptionIds=[0],assumedStates=[1])=[0.48455146, 0.5154486]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.5, 0.5], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29942873, 0.2994287, 0.40114254], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.49149516], 9=[0.5312502, 0.46874982]}
//		 getCash(userId=0,assumptionIds=null,assumedStates=null)=4.5278234
//		 getCash(userId=0,assumptionIds=[0],assumedStates=[1])=4.5278234
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:20:03 BOT 2012,userId=0,questionId=1,newValues=[0.48541012, 0.51459014],assumptionIds=[0],assumedStates=[1])
		newValues = new ArrayList<Float>();
		newValues.add(0.48541012f);
		newValues.add(0.51459014f);
		questionIds = new ArrayList<Long>();
		questionIds.add(0L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1); 
		assertFalse(engine.addTrade(null, new Date(), "",0,1, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999985, 0.5000003], 1=[0.49270466, 0.5072953], 2=[0.50000006, 0.50000006], 3=[0.6206056, 0.37939495], 4=[0.6124163, 0.38758457], 5=[0.29942837, 0.29942843, 0.40114293], 6=[0.46374363, 0.5362562], 7=[0.5, 0.5], 8=[0.5085049, 0.4914949], 9=[0.53125113, 0.46874946]}
//		 getCash(userId=0,assumptionIds=null,assumedStates=null)=0.2554088
//		 getCash(userId=0,assumptionIds=[0],assumedStates=[1])=0.2554088
//		 scoreUserEv(userId=0,assumptionIds=null,assumedStates=null)=114.33453
//		 getEditLimits(userId=5,questionId=5,questionState=2,assumptionIds=[6, 8],assumedStates=[0, 1])=[0.1725362, 0.6725362]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29942873, 0.2994287, 0.40114254], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.49149516], 9=[0.5312502, 0.46874982]}
//		 getCash(userId=5,assumptionIds=null,assumedStates=null)=100.0
//		 getCash(userId=5,assumptionIds=[6, 8],assumedStates=[0, 1])=100.0
		
		// obtain conditional prob 5|6,8 and 8|5,6 before trade for posterior comparison
		List<INode> parentNodes = new ArrayList<INode>();
		parentNodes.add(engine.getProbabilisticNetwork().getNode("6"));
		parentNodes.add(engine.getProbabilisticNetwork().getNode("8"));
		PotentialTable cpt5Given68 = (PotentialTable) engine.getConditionalProbabilityExtractor().buildCondicionalProbability(engine.getProbabilisticNetwork().getNode("5"), parentNodes, engine.getProbabilisticNetwork(), null);
		
		
//		 addTrade(occurredWhen=Wed Sep 05 07:20:04 BOT 2012,userId=5,questionId=5,newValues=[0.313011, 0.28106615, 0.40592253],assumptionIds=[6, 8],assumedStates=[0, 1])
		newValues = new ArrayList<Float>();
		newValues.add(0.313011f);
		newValues.add(0.28106615f);
		newValues.add(0.40592253f);
		questionIds = new ArrayList<Long>();
		questionIds.add(6L); 
		questionIds.add(8L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assumedStates.add(1); 
		assertFalse(engine.addTrade(null, new Date(), "",5,5, newValues, questionIds, assumedStates , false).isEmpty());
		
		
		// check that P(5|6=0,8=1) = [0.313011, 0.28106615, 0.40592253] and other conditions remains the same
		parentNodes = new ArrayList<INode>();
		parentNodes.add(engine.getProbabilisticNetwork().getNode("6"));
		parentNodes.add(engine.getProbabilisticNetwork().getNode("8"));
		PotentialTable cpt5Given68Posteriori = (PotentialTable) engine.getConditionalProbabilityExtractor().buildCondicionalProbability(engine.getProbabilisticNetwork().getNode("5"), parentNodes, engine.getProbabilisticNetwork(), null);
		assertEquals(cpt5Given68.tableSize(), cpt5Given68Posteriori.tableSize());
		for (int i = 0; i < cpt5Given68Posteriori.tableSize(); i++) {
			int[] coord = cpt5Given68Posteriori.getMultidimensionalCoord(i);
			if (coord[1] == 0 && coord[2] == 1) {
				// 6=0,8=1
				switch (coord[0]) {
				case 0:
					assertEquals("index="+i,0.313011f, cpt5Given68Posteriori.getValue(i), 0.00001);
					break;
				case 1:
					assertEquals("index="+i,0.28106615f, cpt5Given68Posteriori.getValue(i), 0.00001);
					break;
				case 2:
					assertEquals("index="+i,0.40592253f, cpt5Given68Posteriori.getValue(i), 0.00001);
					break;
				default:
					fail("Unkown state for node 5: " + coord[0]);
				}
			} else {
				assertEquals("index="+i,cpt5Given68.getValue(i), cpt5Given68Posteriori.getValue(i), 0.00001);
			}
		}
		
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999973, 0.5], 1=[0.49270454, 0.507295], 2=[0.49999982, 0.49999982], 3=[0.62060565, 0.37939453], 4=[0.6124168, 0.38758388], 5=[0.29168558, 0.29247606, 0.4158375], 6=[0.46374315, 0.5362562], 7=[0.4999998, 0.4999998], 8=[0.5085049, 0.49149442], 9=[0.53125095, 0.46874893]}
//		 getCash(userId=5,assumptionIds=null,assumedStates=null)=85.93142
//		 getCash(userId=5,assumptionIds=[6, 8],assumedStates=[0, 1])=85.93142
//		 scoreUserEv(userId=5,assumptionIds=null,assumedStates=null)=100.2785
//		 getEditLimits(userId=2,questionId=8,questionState=0,assumptionIds=[5, 6],assumedStates=[0, 1])=[0.47227493, 0.8048]
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[0.5, 0.5], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29168606, 0.2924763, 0.4158376], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.50850487, 0.4914951], 9=[0.5312502, 0.46874982]}
//		 getCash(userId=2,assumptionIds=null,assumedStates=null)=58.321434
//		 getCash(userId=2,assumptionIds=[5, 6],assumedStates=[0, 1])=58.321434
		
		// store conditional prob P(8|5,6) for posterior comparison
		parentNodes = new ArrayList<INode>();
		parentNodes.add(engine.getProbabilisticNetwork().getNode("5"));
		parentNodes.add(engine.getProbabilisticNetwork().getNode("6"));
		PotentialTable cpt8Given56 = (PotentialTable) engine.getConditionalProbabilityExtractor().buildCondicionalProbability(engine.getProbabilisticNetwork().getNode("8"), parentNodes, engine.getProbabilisticNetwork(), null);
		
		

//		Before Iteration#9, the joint probabilities should be
//		node_names: {'N6'  'N5'  'N8'  'N7'  'N3'  'N4'  'N9'  'N0' 'N1'}
//	sizes: [2 3 2 2 2 2 2 2 2]
//	        joint probabilities are:
		float[] jointIteration9 = {
	        	0.00151001922766489f,
	        	0.00383591661827705f,
	        	0.00294576417220174f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00242461635884228f,
	        	0.0015854557170715f,
	        	0.00217716816727469f,
	        	0.0015854557170715f,
	        	0.00314431891103075f,
	        	0.00484798912720887f,
	        	0.00151001922766489f,
	        	0.00383591661827705f,
	        	0.00294576417220174f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00242461635884228f,
	        	0.0015854557170715f,
	        	0.00217716816727469f,
	        	0.0015854557170715f,
	        	0.00314431891103075f,
	        	0.00484798912720887f,
	        	0.000404515385127145f,
	        	0.00102759439067375f,
	        	0.000789133612857797f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000649524590292385f,
	        	0.000424723883142197f,
	        	0.000583236294966657f,
	        	0.000424723883142197f,
	        	0.00084232395982473f,
	        	0.00129871603815122f,
	        	0.000404515385127145f,
	        	0.00102759439067375f,
	        	0.000789133612857797f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000649524590292385f,
	        	0.000424723883142197f,
	        	0.000583236294966657f,
	        	0.000424723883142197f,
	        	0.00084232395982473f,
	        	0.00129871603815122f,
	        	0.000430116013895833f,
	        	0.00109262791841499f,
	        	0.00083907563586717f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.00069063115514401f,
	        	0.000451603450301555f,
	        	0.000620147662051429f,
	        	0.000451603450301555f,
	        	0.000895632248684165f,
	        	0.00138090808421691f,
	        	0.000430116013895833f,
	        	0.00109262791841499f,
	        	0.00083907563586717f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.00069063115514401f,
	        	0.000451603450301555f,
	        	0.000620147662051429f,
	        	0.000451603450301555f,
	        	0.000895632248684165f,
	        	0.00138090808421691f,
	        	0.000781549102925208f,
	        	0.00198537683294695f,
	        	0.00152465564943417f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00125492225891809f,
	        	0.000820593188949688f,
	        	0.00112684911349253f,
	        	0.000820593188949688f,
	        	0.00162742273687936f,
	        	0.00250920086575355f,
	        	0.000781549102925208f,
	        	0.00198537683294695f,
	        	0.00152465564943417f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00125492225891809f,
	        	0.000820593188949688f,
	        	0.00112684911349253f,
	        	0.000820593188949688f,
	        	0.00162742273687936f,
	        	0.00250920086575355f,
	        	0.00133236895372624f,
	        	0.0033846298892355f,
	        	0.00259920182215833f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00213936584517131f,
	        	0.00139893051441504f,
	        	0.00192102936172785f,
	        	0.00139893051441504f,
	        	0.00277439705463235f,
	        	0.00427763440541365f,
	        	0.00133236895372624f,
	        	0.0033846298892355f,
	        	0.00259920182215833f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00213936584517131f,
	        	0.00139893051441504f,
	        	0.00192102936172785f,
	        	0.00139893051441504f,
	        	0.00277439705463235f,
	        	0.00427763440541365f,
	        	0.000356925084511329f,
	        	0.00090670028438922f,
	        	0.000696293866230747f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000573109522668533f,
	        	0.000374756099417233f,
	        	0.000514619892159644f,
	        	0.000374756099417233f,
	        	0.000743226491748543f,
	        	0.00114592509634125f,
	        	0.000356925084511329f,
	        	0.00090670028438922f,
	        	0.000696293866230747f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000573109522668533f,
	        	0.000374756099417233f,
	        	0.000514619892159644f,
	        	0.000374756099417233f,
	        	0.000743226491748543f,
	        	0.00114592509634125f,
	        	0.00037951385844371f,
	        	0.000964082767821379f,
	        	0.000740360325600851f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000609379995122937f,
	        	0.000398473347593013f,
	        	0.000547188722173415f,
	        	0.000398473347593013f,
	        	0.000790263183567639f,
	        	0.00121844743805375f,
	        	0.00037951385844371f,
	        	0.000964082767821379f,
	        	0.000740360325600851f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000609379995122937f,
	        	0.000398473347593013f,
	        	0.000547188722173415f,
	        	0.000398473347593013f,
	        	0.000790263183567639f,
	        	0.00121844743805375f,
	        	0.00068960165637125f,
	        	0.00175180183483922f,
	        	0.001345283434285f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.00110728355406977f,
	        	0.000724052295868125f,
	        	0.000994277918350175f,
	        	0.000724052295868125f,
	        	0.00143596021128776f,
	        	0.00221399918023758f,
	        	0.00068960165637125f,
	        	0.00175180183483922f,
	        	0.001345283434285f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.00110728355406977f,
	        	0.000724052295868125f,
	        	0.000994277918350175f,
	        	0.000724052295868125f,
	        	0.00143596021128776f,
	        	0.00221399918023758f,
	        	0.00146595722900624f,
	        	0.00372398549197571f,
	        	0.0028598074806403f,
	        	0.00259497097124533f,
	        	0.00259497097124533f,
	        	0.00259497097124533f,
	        	0.00235386663539919f,
	        	0.00153919249975673f,
	        	0.00211363892267398f,
	        	0.00153919249975673f,
	        	0.00305256843984341f,
	        	0.00470652596799431f,
	        	0.00146595722900624f,
	        	0.00372398549197571f,
	        	0.0028598074806403f,
	        	0.00259497097124533f,
	        	0.00259497097124533f,
	        	0.00259497097124533f,
	        	0.00235386663539919f,
	        	0.00153919249975673f,
	        	0.00211363892267398f,
	        	0.00153919249975673f,
	        	0.00305256843984341f,
	        	0.00470652596799431f,
	        	0.000392711723272828f,
	        	0.000997609432976548f,
	        	0.000766106883426673f,
	        	0.000695160473850617f,
	        	0.000695160473850617f,
	        	0.000695160473850617f,
	        	0.000630571618633555f,
	        	0.00041233054216584f,
	        	0.00056621759985624f,
	        	0.00041233054216584f,
	        	0.000817745148834794f,
	        	0.00126081981584982f,
	        	0.000392711723272828f,
	        	0.000997609432976548f,
	        	0.000766106883426673f,
	        	0.000695160473850617f,
	        	0.000695160473850617f,
	        	0.000695160473850617f,
	        	0.000630571618633555f,
	        	0.00041233054216584f,
	        	0.00056621759985624f,
	        	0.00041233054216584f,
	        	0.000817745148834794f,
	        	0.00126081981584982f,
	        	0.000417565331838196f,
	        	0.00106074529798634f,
	        	0.000814591610190719f,
	        	0.00073915520403899f,
	        	0.00073915520403899f,
	        	0.00073915520403899f,
	        	0.000670478703788385f,
	        	0.000438425770006584f,
	        	0.000602051902108207f,
	        	0.000438425770006584f,
	        	0.000869497914619301f,
	        	0.0013406135177374f,
	        	0.000417565331838196f,
	        	0.00106074529798634f,
	        	0.000814591610190719f,
	        	0.00073915520403899f,
	        	0.00073915520403899f,
	        	0.00073915520403899f,
	        	0.000670478703788385f,
	        	0.000438425770006584f,
	        	0.000602051902108207f,
	        	0.000438425770006584f,
	        	0.000869497914619301f,
	        	0.0013406135177374f,
	        	0.000758743687673635f,
	        	0.001927444013452f,
	        	0.00148016656350103f,
	        	0.00134309364909877f,
	        	0.00134309364909877f,
	        	0.00134309364909877f,
	        	0.0012183039285842f,
	        	0.000796648476638501f,
	        	0.0010939679268046f,
	        	0.000796648476638501f,
	        	0.00157993493199868f,
	        	0.00243598298669907f,
	        	0.000758743687673635f,
	        	0.001927444013452f,
	        	0.00148016656350103f,
	        	0.00134309364909877f,
	        	0.00134309364909877f,
	        	0.00134309364909877f,
	        	0.0012183039285842f,
	        	0.000796648476638501f,
	        	0.0010939679268046f,
	        	0.000796648476638501f,
	        	0.00157993493199868f,
	        	0.00243598298669907f,
	        	0.00129349074742506f,
	        	0.00328586720137878f,
	        	0.00252335773679618f,
	        	0.00228967863095013f,
	        	0.00228967863095013f,
	        	0.00228967863095013f,
	        	0.00207693966325701f,
	        	0.00135811005774774f,
	        	0.00186497418599968f,
	        	0.00135811005774774f,
	        	0.00269344081443347f,
	        	0.00415281406009594f,
	        	0.00129349074742506f,
	        	0.00328586720137878f,
	        	0.00252335773679618f,
	        	0.00228967863095013f,
	        	0.00228967863095013f,
	        	0.00228967863095013f,
	        	0.00207693966325701f,
	        	0.00135811005774774f,
	        	0.00186497418599968f,
	        	0.00135811005774774f,
	        	0.00269344081443347f,
	        	0.00415281406009594f,
	        	0.000346510096207309f,
	        	0.000880242987698811f,
	        	0.000675976178324662f,
	        	0.000613376449946592f,
	        	0.000613376449946592f,
	        	0.000613376449946592f,
	        	0.000556386324343351f,
	        	0.000363820806377702f,
	        	0.0004996034072152f,
	        	0.000363820806377702f,
	        	0.000721539321093679f,
	        	0.00111248727705204f,
	        	0.000346510096207309f,
	        	0.000880242987698811f,
	        	0.000675976178324662f,
	        	0.000613376449946592f,
	        	0.000613376449946592f,
	        	0.000613376449946592f,
	        	0.000556386324343351f,
	        	0.000363820806377702f,
	        	0.0004996034072152f,
	        	0.000363820806377702f,
	        	0.000721539321093679f,
	        	0.00111248727705204f,
	        	0.000368439735137648f,
	        	0.000935951064036215f,
	        	0.000718756788986297f,
	        	0.000652195301757637f,
	        	0.000652195301757637f,
	        	0.000652195301757637f,
	        	0.000591598433116448f,
	        	0.000386845990943852f,
	        	0.000531221886585688f,
	        	0.000386845990943852f,
	        	0.000767203493534299f,
	        	0.00118289343423873f,
	        	0.000368439735137648f,
	        	0.000935951064036215f,
	        	0.000718756788986297f,
	        	0.000652195301757637f,
	        	0.000652195301757637f,
	        	0.000652195301757637f,
	        	0.000591598433116448f,
	        	0.000386845990943852f,
	        	0.000531221886585688f,
	        	0.000386845990943852f,
	        	0.000767203493534299f,
	        	0.00118289343423873f,
	        	0.000669479245542734f,
	        	0.00170068467773105f,
	        	0.00130602838654059f,
	        	0.00118508178387462f,
	        	0.00118508178387462f,
	        	0.00118508178387462f,
	        	0.00107497328571006f,
	        	0.000702924623647244f,
	        	0.000965265127319417f,
	        	0.000702924623647244f,
	        	0.00139405923695283f,
	        	0.00214939521551805f,
	        	0.000669479245542734f,
	        	0.00170068467773105f,
	        	0.00130602838654059f,
	        	0.00118508178387462f,
	        	0.00118508178387462f,
	        	0.00118508178387462f,
	        	0.00107497328571006f,
	        	0.000702924623647244f,
	        	0.000965265127319417f,
	        	0.000702924623647244f,
	        	0.00139405923695283f,
	        	0.00214939521551805f,
	        	0.00151001922766489f,
	        	0.00383591661827705f,
	        	0.00294576417220174f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00242461635884228f,
	        	0.0015854557170715f,
	        	0.00217716816727469f,
	        	0.0015854557170715f,
	        	0.00314431891103075f,
	        	0.00484798912720887f,
	        	0.00151001922766489f,
	        	0.00383591661827705f,
	        	0.00294576417220174f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00267296752202584f,
	        	0.00242461635884228f,
	        	0.0015854557170715f,
	        	0.00217716816727469f,
	        	0.0015854557170715f,
	        	0.00314431891103075f,
	        	0.00484798912720887f,
	        	0.000404515385127145f,
	        	0.00102759439067375f,
	        	0.000789133612857797f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000649524590292385f,
	        	0.000424723883142197f,
	        	0.000583236294966657f,
	        	0.000424723883142197f,
	        	0.00084232395982473f,
	        	0.00129871603815122f,
	        	0.000404515385127145f,
	        	0.00102759439067375f,
	        	0.000789133612857797f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000716054780492233f,
	        	0.000649524590292385f,
	        	0.000424723883142197f,
	        	0.000583236294966657f,
	        	0.000424723883142197f,
	        	0.00084232395982473f,
	        	0.00129871603815122f,
	        	0.000430116013895833f,
	        	0.00109262791841499f,
	        	0.00083907563586717f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.00069063115514401f,
	        	0.000451603450301555f,
	        	0.000620147662051429f,
	        	0.000451603450301555f,
	        	0.000895632248684165f,
	        	0.00138090808421691f,
	        	0.000430116013895833f,
	        	0.00109262791841499f,
	        	0.00083907563586717f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.000761371851949635f,
	        	0.00069063115514401f,
	        	0.000451603450301555f,
	        	0.000620147662051429f,
	        	0.000451603450301555f,
	        	0.000895632248684165f,
	        	0.00138090808421691f,
	        	0.000781549102925208f,
	        	0.00198537683294695f,
	        	0.00152465564943417f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00125492225891809f,
	        	0.000820593188949688f,
	        	0.00112684911349253f,
	        	0.000820593188949688f,
	        	0.00162742273687936f,
	        	0.00250920086575355f,
	        	0.000781549102925208f,
	        	0.00198537683294695f,
	        	0.00152465564943417f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00138346276041667f,
	        	0.00125492225891809f,
	        	0.000820593188949688f,
	        	0.00112684911349253f,
	        	0.000820593188949688f,
	        	0.00162742273687936f,
	        	0.00250920086575355f,
	        	0.00133236895372624f,
	        	0.0033846298892355f,
	        	0.00259920182215833f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00213936584517131f,
	        	0.00139893051441504f,
	        	0.00192102936172785f,
	        	0.00139893051441504f,
	        	0.00277439705463235f,
	        	0.00427763440541365f,
	        	0.00133236895372624f,
	        	0.0033846298892355f,
	        	0.00259920182215833f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00235849906770601f,
	        	0.00213936584517131f,
	        	0.00139893051441504f,
	        	0.00192102936172785f,
	        	0.00139893051441504f,
	        	0.00277439705463235f,
	        	0.00427763440541365f,
	        	0.000356925084511329f,
	        	0.00090670028438922f,
	        	0.000696293866230747f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000573109522668533f,
	        	0.000374756099417233f,
	        	0.000514619892159644f,
	        	0.000374756099417233f,
	        	0.000743226491748543f,
	        	0.00114592509634125f,
	        	0.000356925084511329f,
	        	0.00090670028438922f,
	        	0.000696293866230747f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000631812589678386f,
	        	0.000573109522668533f,
	        	0.000374756099417233f,
	        	0.000514619892159644f,
	        	0.000374756099417233f,
	        	0.000743226491748543f,
	        	0.00114592509634125f,
	        	0.00037951385844371f,
	        	0.000964082767821379f,
	        	0.000740360325600851f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000609379995122937f,
	        	0.000398473347593013f,
	        	0.000547188722173415f,
	        	0.000398473347593013f,
	        	0.000790263183567639f,
	        	0.00121844743805375f,
	        	0.00037951385844371f,
	        	0.000964082767821379f,
	        	0.000740360325600851f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000671798212362812f,
	        	0.000609379995122937f,
	        	0.000398473347593013f,
	        	0.000547188722173415f,
	        	0.000398473347593013f,
	        	0.000790263183567639f,
	        	0.00121844743805375f,
	        	0.00068960165637125f,
	        	0.00175180183483922f,
	        	0.001345283434285f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.00110728355406977f,
	        	0.000724052295868125f,
	        	0.000994277918350175f,
	        	0.000724052295868125f,
	        	0.00143596021128776f,
	        	0.00221399918023758f,
	        	0.00068960165637125f,
	        	0.00175180183483922f,
	        	0.001345283434285f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.0012207015625f,
	        	0.00110728355406977f,
	        	0.000724052295868125f,
	        	0.000994277918350175f,
	        	0.000724052295868125f,
	        	0.00143596021128776f,
	        	0.00221399918023758f,
	        	0.00155408201153354f,
	        	0.00394784973925502f,
	        	0.00303172239556056f,
	        	0.00275096546274946f,
	        	0.00275096546274946f,
	        	0.00275096546274946f,
	        	0.00249536734308588f,
	        	0.00163171975882325f,
	        	0.00224069854400285f,
	        	0.00163171975882325f,
	        	0.00323607101726392f,
	        	0.00498945480737778f,
	        	0.00155408201153354f,
	        	0.00394784973925502f,
	        	0.00303172239556056f,
	        	0.00275096546274946f,
	        	0.00275096546274946f,
	        	0.00275096546274946f,
	        	0.00249536734308588f,
	        	0.00163171975882325f,
	        	0.00224069854400285f,
	        	0.00163171975882325f,
	        	0.00323607101726392f,
	        	0.00498945480737778f,
	        	0.000416319257329463f,
	        	0.00105757988272004f,
	        	0.000812160752638399f,
	        	0.000736949459482335f,
	        	0.000736949459482335f,
	        	0.000736949459482335f,
	        	0.000668477899704002f,
	        	0.000437117444974974f,
	        	0.000600255293359946f,
	        	0.000437117444974974f,
	        	0.000866903208823124f,
	        	0.00133661293578496f,
	        	0.000416319257329463f,
	        	0.00105757988272004f,
	        	0.000812160752638399f,
	        	0.000736949459482335f,
	        	0.000736949459482335f,
	        	0.000736949459482335f,
	        	0.000668477899704002f,
	        	0.000437117444974974f,
	        	0.000600255293359946f,
	        	0.000437117444974974f,
	        	0.000866903208823124f,
	        	0.00133661293578496f,
	        	0.000442666919613797f,
	        	0.00112451110701016f,
	        	0.000863560097862953f,
	        	0.000783588895773644f,
	        	0.000783588895773644f,
	        	0.000783588895773644f,
	        	0.000710783965627836f,
	        	0.000464781365430321f,
	        	0.000638243744471435f,
	        	0.000464781365430321f,
	        	0.000921767048477799f,
	        	0.00142120336876862f,
	        	0.000442666919613797f,
	        	0.00112451110701016f,
	        	0.000863560097862953f,
	        	0.000783588895773644f,
	        	0.000783588895773644f,
	        	0.000783588895773644f,
	        	0.000710783965627836f,
	        	0.000464781365430321f,
	        	0.000638243744471435f,
	        	0.000464781365430321f,
	        	0.000921767048477799f,
	        	0.00142120336876862f,
	        	0.000804354924582315f,
	        	0.00204331068483786f,
	        	0.00156914552818824f,
	        	0.0014238325911352f,
	        	0.0014238325911352f,
	        	0.0014238325911352f,
	        	0.00129154124181155f,
	        	0.000844538327969332f,
	        	0.00115973088614199f,
	        	0.000844538327969332f,
	        	0.00167491138801987f,
	        	0.00258242004959249f,
	        	0.000804354924582315f,
	        	0.00204331068483786f,
	        	0.00156914552818824f,
	        	0.0014238325911352f,
	        	0.0014238325911352f,
	        	0.0014238325911352f,
	        	0.00129154124181155f,
	        	0.000844538327969332f,
	        	0.00115973088614199f,
	        	0.000844538327969332f,
	        	0.00167491138801987f,
	        	0.00258242004959249f,
	        	0.00137124785285928f,
	        	0.00348339433709976f,
	        	0.00267504725910542f,
	        	0.00242732073088141f,
	        	0.00242732073088141f,
	        	0.00242732073088141f,
	        	0.00220179313955584f,
	        	0.00143975169852622f,
	        	0.00197708553639129f,
	        	0.00143975169852622f,
	        	0.00285535473751769f,
	        	0.00440245697510126f,
	        	0.00137124785285928f,
	        	0.00348339433709976f,
	        	0.00267504725910542f,
	        	0.00242732073088141f,
	        	0.00242732073088141f,
	        	0.00242732073088141f,
	        	0.00220179313955584f,
	        	0.00143975169852622f,
	        	0.00197708553639129f,
	        	0.00143975169852622f,
	        	0.00285535473751769f,
	        	0.00440245697510126f,
	        	0.000367340258416393f,
	        	0.000933158052563777f,
	        	0.000716611916209643f,
	        	0.000650249057952727f,
	        	0.000650249057952727f,
	        	0.000650249057952727f,
	        	0.000589833019010667f,
	        	0.000385691587329935f,
	        	0.000529636644706432f,
	        	0.000385691587329935f,
	        	0.000764914048881184f,
	        	0.00117936351151152f,
	        	0.000367340258416393f,
	        	0.000933158052563777f,
	        	0.000716611916209643f,
	        	0.000650249057952727f,
	        	0.000650249057952727f,
	        	0.000650249057952727f,
	        	0.000589833019010667f,
	        	0.000385691587329935f,
	        	0.000529636644706432f,
	        	0.000385691587329935f,
	        	0.000764914048881184f,
	        	0.00117936351151152f,
	        	0.000390588179096978f,
	        	0.000992214972929582f,
	        	0.000761964247202775f,
	        	0.000691401472303059f,
	        	0.000691401472303059f,
	        	0.000691401472303059f,
	        	0.000627161874007023f,
	        	0.000410100911448314f,
	        	0.000563155842299277f,
	        	0.000410100911448314f,
	        	0.000813323284537834f,
	        	0.00125400207546144f,
	        	0.000390588179096978f,
	        	0.000992214972929582f,
	        	0.000761964247202775f,
	        	0.000691401472303059f,
	        	0.000691401472303059f,
	        	0.000691401472303059f,
	        	0.000627161874007023f,
	        	0.000410100911448314f,
	        	0.000563155842299277f,
	        	0.000410100911448314f,
	        	0.000813323284537834f,
	        	0.00125400207546144f,
	        	0.000709724425792627f,
	        	0.00180291990288434f,
	        	0.0013845391815768f,
	        	0.00125632197589019f,
	        	0.00125632197589019f,
	        	0.00125632197589019f,
	        	0.00113959439821692f,
	        	0.0007451803445962f,
	        	0.00102329122640545f,
	        	0.0007451803445962f,
	        	0.00147786193232199f,
	        	0.00227860429623668f,
	        	0.000709724425792627f,
	        	0.00180291990288434f,
	        	0.0013845391815768f,
	        	0.00125632197589019f,
	        	0.00125632197589019f,
	        	0.00125632197589019f,
	        	0.00113959439821692f,
	        	0.0007451803445962f,
	        	0.00102329122640545f,
	        	0.0007451803445962f,
	        	0.00147786193232199f,
	        	0.00227860429623668f,
		};
		
		// check that the matlab is summing up to 1
		sum = 0f;
		float min = Float.POSITIVE_INFINITY;
		float max = Float.NEGATIVE_INFINITY;
		for (int i = 0; i < jointIteration9.length; i++) {
			sum += jointIteration9[i];
			if (jointIteration9[i] < min) {
				min = jointIteration9[i];
			}
			if (jointIteration9[i] > max) {
				max = jointIteration9[i];
			}
		}
		assertEquals(1f, sum, PROB_ERROR_MARGIN);
		assertFalse(Float.isInfinite(min));
		
		// check joint probabilities
//		node_names: {'N6'  'N5'  'N8'  'N7'  'N3'  'N4'  'N9'  'N0' 'N1'}
//		sizes: [2 3 2 2 2 2 2 2 2]
		questionIds = new ArrayList<Long>();
		questionIds.add(6L); questionIds.add(5L); questionIds.add(8L); 
		questionIds.add(7L); questionIds.add(3L); questionIds.add(4L);  
		questionIds.add(9L); questionIds.add(0L); questionIds.add(1L);
		// start from all questions in state 0
		states = new ArrayList<Integer>();
		states.add(0); states.add(0); states.add(0);
		states.add(0); states.add(0); states.add(0);
		states.add(0); states.add(0); states.add(0);
		// index to be used to access joint probability
		indexForJointProbability = 0;	
		sum = 0;	// check that joint prob of ME is summing up to 1
		// compare joint probability returned by the engine and expected
		for (int stateNode1 = 0; stateNode1 < 2; stateNode1++) {	// iterate on states of node 1
			for (int stateNode0 = 0; stateNode0 < 2; stateNode0++) {	// iterate on states of node 0
				for (int stateNode9 = 0; stateNode9 < 2; stateNode9++) {	// iterate on states of node 9
					for (int stateNode4 = 0; stateNode4 < 2; stateNode4++) {	// iterate on states of node 4
						for (int stateNode3 = 0; stateNode3 < 2; stateNode3++) {	// iterate on states of node 3
							for (int stateNode7 = 0; stateNode7 < 2; stateNode7++) {	// iterate on states of node 7
								for (int stateNode8 = 0; stateNode8 < 2; stateNode8++) {	// iterate on states of node 8
									for (int stateNode5 = 0; stateNode5 < 3; stateNode5++) {	// iterate on states of node 5
										for (int stateNode6 = 0; stateNode6 < 2; stateNode6++) {	// iterate on states of node 6
											// set states accourdingly to current iteration
											states.set(0, stateNode6); states.set(1, stateNode5); states.set(2, stateNode8);
											states.set(3, stateNode7); states.set(4, stateNode3); states.set(5, stateNode4);
											states.set(6, stateNode9); states.set(7, stateNode0); states.set(8, stateNode1);
											// obtain the joint probability from engine
											float jointProbability = engine.getJointProbability(questionIds, states);
											// compare results
//											System.out.format(
//													"%d,%d,%d,%d,%d,%d,%d,%d,%d,%1.20f,%1.20f%n",
//													stateNode6,stateNode5,stateNode8,stateNode7,stateNode3,stateNode4,stateNode9,stateNode0,stateNode1,
//													jointIteration9[indexForJointProbability],jointProbability
//												);
											assertEquals(
													"joint index = " + indexForJointProbability + "; "
													+ "[6,5,8,7,3,4,9,0,1]=["
													+ stateNode6+"," + stateNode5+","+ stateNode8+","+ stateNode7+","+ stateNode3+","+ stateNode4+","+ stateNode9+","+ stateNode0+","+ stateNode1 + "]", 
													jointIteration9[indexForJointProbability], 
													jointProbability, 
													min/2	// use the half of the smallest joint prob as the error margin
											);
											sum += jointProbability;
											indexForJointProbability++;	// point to next item in jointBeforeIteration5
										}
									}
								}
							}
						}
					}
				}
			}
		}
		assertEquals(1f, sum, PROB_ERROR_MARGIN);
		
//		 addTrade(occurredWhen=Wed Sep 05 07:20:06 BOT 2012,userId=2,questionId=8,newValues=[0.6097233, 0.390277],assumptionIds=[5, 6],assumedStates=[0, 1])
		newValues = new ArrayList<Float>();
		newValues.add(0.6097233f);
		newValues.add(0.390277f);
		questionIds = new ArrayList<Long>();
		questionIds.add(5L); 
		questionIds.add(6L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assumedStates.add(1); 
		assertFalse(engine.addTrade(null, new Date(), "",2,8, newValues, questionIds, assumedStates , false).isEmpty());
		
		// check that P(8|5=0,6=1) = [0.6097233, 0.390277] and other conditions remains the same
		PotentialTable cpt8Given56Posteriori = (PotentialTable) engine.getConditionalProbabilityExtractor().buildCondicionalProbability(engine.getProbabilisticNetwork().getNode("8"), parentNodes, engine.getProbabilisticNetwork(), null);
		assertEquals(cpt8Given56.tableSize(), cpt8Given56Posteriori.tableSize());
		for (int i = 0; i < cpt8Given56Posteriori.tableSize(); i++) {
			int[] coord = cpt8Given56Posteriori.getMultidimensionalCoord(i);
			if (coord[1] == 0 && coord[2] == 1) {
				// 5=0,6=1
				switch (coord[0]) {
				case 0:
					assertEquals("index="+i,0.6097233f, cpt8Given56Posteriori.getValue(i), 0.00001);
					break;
				case 1:
					assertEquals("index="+i,0.390277f, cpt8Given56Posteriori.getValue(i), 0.00001);
					break;
				default:
					fail("Unkown state for node 8: " + coord[0]);
				}
			} else {
				assertEquals("index="+i,cpt8Given56.getValue(i), cpt8Given56Posteriori.getValue(i), 0.00001);
			}
		}
		
//		 getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5000002, 0.49999994], 1=[0.49270457, 0.5072953], 2=[0.50000006, 0.50000006], 3=[0.6206052, 0.37939462], 4=[0.6124164, 0.3875839], 5=[0.29168588, 0.29247606, 0.4158375], 6=[0.46374315, 0.53625655], 7=[0.5, 0.5], 8=[0.49196953, 0.50803006], 9=[0.5312506, 0.46874934]}
//		 getCash(userId=2,assumptionIds=null,assumedStates=null)=36.85278
//		 getCash(userId=2,assumptionIds=[5, 6],assumedStates=[0, 1])=36.85278
//		 scoreUserEv(userId=2,assumptionIds=null,assumedStates=null)=161.59337
		

//		After Iteration #9, JP are,
		float[] jointAfter9 = {
				0.00151001922766489f,
				0.00330553703083742f,
				0.00294576417220174f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00242461635884228f,
				0.00211583693092283f,
				0.00217716816727469f,
				0.0015854557170715f,
				0.00314431891103075f,
				0.00484798912720887f,
				0.00151001922766489f,
				0.00330553703083742f,
				0.00294576417220174f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00242461635884228f,
				0.00211583693092283f,
				0.00217716816727469f,
				0.0015854557170715f,
				0.00314431891103075f,
				0.00484798912720887f,
				0.000404515385127145f,
				0.000885512290561366f,
				0.000789133612857797f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000649524590292385f,
				0.000566806418950068f,
				0.000583236294966657f,
				0.000424723883142197f,
				0.00084232395982473f,
				0.00129871603815122f,
				0.000404515385127145f,
				0.000885512290561366f,
				0.000789133612857797f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000649524590292385f,
				0.000566806418950068f,
				0.000583236294966657f,
				0.000424723883142197f,
				0.00084232395982473f,
				0.00129871603815122f,
				0.000430116013895833f,
				0.000941553846097371f,
				0.00083907563586717f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.00069063115514401f,
				0.000602677985888588f,
				0.000620147662051429f,
				0.000451603450301555f,
				0.000895632248684165f,
				0.00138090808421691f,
				0.000430116013895833f,
				0.000941553846097371f,
				0.00083907563586717f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.00069063115514401f,
				0.000602677985888588f,
				0.000620147662051429f,
				0.000451603450301555f,
				0.000895632248684165f,
				0.00138090808421691f,
				0.000781549102925208f,
				0.00171086530145189f,
				0.00152465564943417f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00125492225891809f,
				0.00109510556223576f,
				0.00112684911349253f,
				0.000820593188949688f,
				0.00162742273687936f,
				0.00250920086575355f,
				0.000781549102925208f,
				0.00171086530145189f,
				0.00152465564943417f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00125492225891809f,
				0.00109510556223576f,
				0.00112684911349253f,
				0.000820593188949688f,
				0.00162742273687936f,
				0.00250920086575355f,
				0.00133236895372624f,
				0.00291664823506314f,
				0.00259920182215833f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00213936584517131f,
				0.00186691360365552f,
				0.00192102936172785f,
				0.00139893051441504f,
				0.00277439705463235f,
				0.00427763440541365f,
				0.00133236895372624f,
				0.00291664823506314f,
				0.00259920182215833f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00213936584517131f,
				0.00186691360365552f,
				0.00192102936172785f,
				0.00139893051441504f,
				0.00277439705463235f,
				0.00427763440541365f,
				0.000356925084511329f,
				0.000781333815140537f,
				0.000696293866230747f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000573109522668533f,
				0.000500122953102831f,
				0.000514619892159644f,
				0.000374756099417233f,
				0.000743226491748543f,
				0.00114592509634125f,
				0.000356925084511329f,
				0.000781333815140537f,
				0.000696293866230747f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000573109522668533f,
				0.000500122953102831f,
				0.000514619892159644f,
				0.000374756099417233f,
				0.000743226491748543f,
				0.00114592509634125f,
				0.00037951385844371f,
				0.000830782211125644f,
				0.000740360325600851f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000609379995122937f,
				0.000531774313055582f,
				0.000547188722173415f,
				0.000398473347593013f,
				0.000790263183567639f,
				0.00121844743805375f,
				0.00037951385844371f,
				0.000830782211125644f,
				0.000740360325600851f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000609379995122937f,
				0.000531774313055582f,
				0.000547188722173415f,
				0.000398473347593013f,
				0.000790263183567639f,
				0.00121844743805375f,
				0.00068960165637125f,
				0.00150958595089351f,
				0.001345283434285f,
				0.0012207015625f,
				0.0012207015625f,
				0.0012207015625f,
				0.00110728355406977f,
				0.00096626892257007f,
				0.000994277918350175f,
				0.000724052295868125f,
				0.00143596021128776f,
				0.00221399918023758f,
				0.00068960165637125f,
				0.00150958595089351f,
				0.001345283434285f,
				0.0012207015625f,
				0.0012207015625f,
				0.0012207015625f,
				0.00110728355406977f,
				0.00096626892257007f,
				0.000994277918350175f,
				0.000724052295868125f,
				0.00143596021128776f,
				0.00221399918023758f,
				0.00146595722900624f,
				0.00320908225360648f,
				0.0028598074806403f,
				0.00259497097124533f,
				0.00259497097124533f,
				0.00259497097124533f,
				0.00235386663539919f,
				0.00205409731707936f,
				0.00211363892267398f,
				0.00153919249975673f,
				0.00305256843984341f,
				0.00470652596799431f,
				0.00146595722900624f,
				0.00320908225360648f,
				0.0028598074806403f,
				0.00259497097124533f,
				0.00259497097124533f,
				0.00259497097124533f,
				0.00235386663539919f,
				0.00205409731707936f,
				0.00211363892267398f,
				0.00153919249975673f,
				0.00305256843984341f,
				0.00470652596799431f,
				0.000392711723272828f,
				0.000859673254445735f,
				0.000766106883426673f,
				0.000695160473850617f,
				0.000695160473850617f,
				0.000695160473850617f,
				0.000630571618633555f,
				0.000550267143678645f,
				0.00056621759985624f,
				0.00041233054216584f,
				0.000817745148834794f,
				0.00126081981584982f,
				0.000392711723272828f,
				0.000859673254445735f,
				0.000766106883426673f,
				0.000695160473850617f,
				0.000695160473850617f,
				0.000695160473850617f,
				0.000630571618633555f,
				0.000550267143678645f,
				0.00056621759985624f,
				0.00041233054216584f,
				0.000817745148834794f,
				0.00126081981584982f,
				0.000417565331838196f,
				0.000914079530841173f,
				0.000814591610190719f,
				0.00073915520403899f,
				0.00073915520403899f,
				0.00073915520403899f,
				0.000670478703788385f,
				0.000585091986903076f,
				0.000602051902108207f,
				0.000438425770006584f,
				0.000869497914619301f,
				0.0013406135177374f,
				0.000417565331838196f,
				0.000914079530841173f,
				0.000814591610190719f,
				0.00073915520403899f,
				0.00073915520403899f,
				0.00073915520403899f,
				0.000670478703788385f,
				0.000585091986903076f,
				0.000602051902108207f,
				0.000438425770006584f,
				0.000869497914619301f,
				0.0013406135177374f,
				0.000758743687673635f,
				0.0016609426625632f,
				0.00148016656350103f,
				0.00134309364909877f,
				0.00134309364909877f,
				0.00134309364909877f,
				0.0012183039285842f,
				0.00106315064475505f,
				0.0010939679268046f,
				0.000796648476638501f,
				0.00157993493199868f,
				0.00243598298669907f,
				0.000758743687673635f,
				0.0016609426625632f,
				0.00148016656350103f,
				0.00134309364909877f,
				0.00134309364909877f,
				0.00134309364909877f,
				0.0012183039285842f,
				0.00106315064475505f,
				0.0010939679268046f,
				0.000796648476638501f,
				0.00157993493199868f,
				0.00243598298669907f,
				0.00129349074742506f,
				0.00283154113955958f,
				0.00252335773679618f,
				0.00228967863095013f,
				0.00228967863095013f,
				0.00228967863095013f,
				0.00207693966325701f,
				0.00181243751276012f,
				0.00186497418599968f,
				0.00135811005774774f,
				0.00269344081443347f,
				0.00415281406009594f,
				0.00129349074742506f,
				0.00283154113955958f,
				0.00252335773679618f,
				0.00228967863095013f,
				0.00228967863095013f,
				0.00228967863095013f,
				0.00207693966325701f,
				0.00181243751276012f,
				0.00186497418599968f,
				0.00135811005774774f,
				0.00269344081443347f,
				0.00415281406009594f,
				0.000346510096207309f,
				0.000758534681934852f,
				0.000675976178324662f,
				0.000613376449946592f,
				0.000613376449946592f,
				0.000613376449946592f,
				0.000556386324343351f,
				0.000485529485360799f,
				0.0004996034072152f,
				0.000363820806377702f,
				0.000721539321093679f,
				0.00111248727705204f,
				0.000346510096207309f,
				0.000758534681934852f,
				0.000675976178324662f,
				0.000613376449946592f,
				0.000613376449946592f,
				0.000613376449946592f,
				0.000556386324343351f,
				0.000485529485360799f,
				0.0004996034072152f,
				0.000363820806377702f,
				0.000721539321093679f,
				0.00111248727705204f,
				0.000368439735137648f,
				0.000806540185592728f,
				0.000718756788986297f,
				0.000652195301757637f,
				0.000652195301757637f,
				0.000652195301757637f,
				0.000591598433116448f,
				0.000516257266226456f,
				0.000531221886585688f,
				0.000386845990943852f,
				0.000767203493534299f,
				0.00118289343423873f,
				0.000368439735137648f,
				0.000806540185592728f,
				0.000718756788986297f,
				0.000652195301757637f,
				0.000652195301757637f,
				0.000652195301757637f,
				0.000591598433116448f,
				0.000516257266226456f,
				0.000531221886585688f,
				0.000386845990943852f,
				0.000767203493534299f,
				0.00118289343423873f,
				0.000669479245542734f,
				0.00146553659514707f,
				0.00130602838654059f,
				0.00118508178387462f,
				0.00118508178387462f,
				0.00118508178387462f,
				0.00107497328571006f,
				0.000938073427314016f,
				0.000965265127319417f,
				0.000702924623647244f,
				0.00139405923695283f,
				0.00214939521551805f,
				0.000669479245542734f,
				0.00146553659514707f,
				0.00130602838654059f,
				0.00118508178387462f,
				0.00118508178387462f,
				0.00118508178387462f,
				0.00107497328571006f,
				0.000938073427314016f,
				0.000965265127319417f,
				0.000702924623647244f,
				0.00139405923695283f,
				0.00214939521551805f,
				0.00151001922766489f,
				0.00330553703083742f,
				0.00294576417220174f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00242461635884228f,
				0.00211583693092283f,
				0.00217716816727469f,
				0.0015854557170715f,
				0.00314431891103075f,
				0.00484798912720887f,
				0.00151001922766489f,
				0.00330553703083742f,
				0.00294576417220174f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00267296752202584f,
				0.00242461635884228f,
				0.00211583693092283f,
				0.00217716816727469f,
				0.0015854557170715f,
				0.00314431891103075f,
				0.00484798912720887f,
				0.000404515385127145f,
				0.000885512290561366f,
				0.000789133612857797f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000649524590292385f,
				0.000566806418950068f,
				0.000583236294966657f,
				0.000424723883142197f,
				0.00084232395982473f,
				0.00129871603815122f,
				0.000404515385127145f,
				0.000885512290561366f,
				0.000789133612857797f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000716054780492233f,
				0.000649524590292385f,
				0.000566806418950068f,
				0.000583236294966657f,
				0.000424723883142197f,
				0.00084232395982473f,
				0.00129871603815122f,
				0.000430116013895833f,
				0.000941553846097371f,
				0.00083907563586717f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.00069063115514401f,
				0.000602677985888588f,
				0.000620147662051429f,
				0.000451603450301555f,
				0.000895632248684165f,
				0.00138090808421691f,
				0.000430116013895833f,
				0.000941553846097371f,
				0.00083907563586717f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.000761371851949635f,
				0.00069063115514401f,
				0.000602677985888588f,
				0.000620147662051429f,
				0.000451603450301555f,
				0.000895632248684165f,
				0.00138090808421691f,
				0.000781549102925208f,
				0.00171086530145189f,
				0.00152465564943417f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00125492225891809f,
				0.00109510556223576f,
				0.00112684911349253f,
				0.000820593188949688f,
				0.00162742273687936f,
				0.00250920086575355f,
				0.000781549102925208f,
				0.00171086530145189f,
				0.00152465564943417f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00138346276041667f,
				0.00125492225891809f,
				0.00109510556223576f,
				0.00112684911349253f,
				0.000820593188949688f,
				0.00162742273687936f,
				0.00250920086575355f,
				0.00133236895372624f,
				0.00291664823506314f,
				0.00259920182215833f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00213936584517131f,
				0.00186691360365552f,
				0.00192102936172785f,
				0.00139893051441504f,
				0.00277439705463235f,
				0.00427763440541365f,
				0.00133236895372624f,
				0.00291664823506314f,
				0.00259920182215833f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00235849906770601f,
				0.00213936584517131f,
				0.00186691360365552f,
				0.00192102936172785f,
				0.00139893051441504f,
				0.00277439705463235f,
				0.00427763440541365f,
				0.000356925084511329f,
				0.000781333815140537f,
				0.000696293866230747f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000573109522668533f,
				0.000500122953102831f,
				0.000514619892159644f,
				0.000374756099417233f,
				0.000743226491748543f,
				0.00114592509634125f,
				0.000356925084511329f,
				0.000781333815140537f,
				0.000696293866230747f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000631812589678386f,
				0.000573109522668533f,
				0.000500122953102831f,
				0.000514619892159644f,
				0.000374756099417233f,
				0.000743226491748543f,
				0.00114592509634125f,
				0.00037951385844371f,
				0.000830782211125644f,
				0.000740360325600851f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000609379995122937f,
				0.000531774313055582f,
				0.000547188722173415f,
				0.000398473347593013f,
				0.000790263183567639f,
				0.00121844743805375f,
				0.00037951385844371f,
				0.000830782211125644f,
				0.000740360325600851f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000671798212362812f,
				0.000609379995122937f,
				0.000531774313055582f,
				0.000547188722173415f,
				0.000398473347593013f,
				0.000790263183567639f,
				0.00121844743805375f,
				0.00068960165637125f,
				0.00150958595089351f,
				0.001345283434285f,
				0.0012207015625f,
				0.0012207015625f,
				0.0012207015625f,
				0.00110728355406977f,
				0.00096626892257007f,
				0.000994277918350175f,
				0.000724052295868125f,
				0.00143596021128776f,
				0.00221399918023758f,
				0.00068960165637125f,
				0.00150958595089351f,
				0.001345283434285f,
				0.0012207015625f,
				0.0012207015625f,
				0.0012207015625f,
				0.00110728355406977f,
				0.00096626892257007f,
				0.000994277918350175f,
				0.000724052295868125f,
				0.00143596021128776f,
				0.00221399918023758f,
				0.00155408201153354f,
				0.00340199352694763f,
				0.00303172239556056f,
				0.00275096546274946f,
				0.00275096546274946f,
				0.00275096546274946f,
				0.00249536734308588f,
				0.00217757764500149f,
				0.00224069854400285f,
				0.00163171975882325f,
				0.00323607101726392f,
				0.00498945480737778f,
				0.00155408201153354f,
				0.00340199352694763f,
				0.00303172239556056f,
				0.00275096546274946f,
				0.00275096546274946f,
				0.00275096546274946f,
				0.00249536734308588f,
				0.00217757764500149f,
				0.00224069854400285f,
				0.00163171975882325f,
				0.00323607101726392f,
				0.00498945480737778f,
				0.000416319257329463f,
				0.000911351787143388f,
				0.000812160752638399f,
				0.000736949459482335f,
				0.000736949459482335f,
				0.000736949459482335f,
				0.000668477899704002f,
				0.000583345988960828f,
				0.000600255293359946f,
				0.000437117444974974f,
				0.000866903208823124f,
				0.00133661293578496f,
				0.000416319257329463f,
				0.000911351787143388f,
				0.000812160752638399f,
				0.000736949459482335f,
				0.000736949459482335f,
				0.000736949459482335f,
				0.000668477899704002f,
				0.000583345988960828f,
				0.000600255293359946f,
				0.000437117444974974f,
				0.000866903208823124f,
				0.00133661293578496f,
				0.000442666919613797f,
				0.000969028650961569f,
				0.000863560097862953f,
				0.000783588895773644f,
				0.000783588895773644f,
				0.000783588895773644f,
				0.000710783965627836f,
				0.000620264298266653f,
				0.000638243744471435f,
				0.000464781365430321f,
				0.000921767048477799f,
				0.00142120336876862f,
				0.000442666919613797f,
				0.000969028650961569f,
				0.000863560097862953f,
				0.000783588895773644f,
				0.000783588895773644f,
				0.000783588895773644f,
				0.000710783965627836f,
				0.000620264298266653f,
				0.000638243744471435f,
				0.000464781365430321f,
				0.000921767048477799f,
				0.00142120336876862f,
				0.000804354924582315f,
				0.00176078882999054f,
				0.00156914552818824f,
				0.0014238325911352f,
				0.0014238325911352f,
				0.0014238325911352f,
				0.00129154124181155f,
				0.00112706104917135f,
				0.00115973088614199f,
				0.000844538327969332f,
				0.00167491138801987f,
				0.00258242004959249f,
				0.000804354924582315f,
				0.00176078882999054f,
				0.00156914552818824f,
				0.0014238325911352f,
				0.0014238325911352f,
				0.0014238325911352f,
				0.00129154124181155f,
				0.00112706104917135f,
				0.00115973088614199f,
				0.000844538327969332f,
				0.00167491138801987f,
				0.00258242004959249f,
				0.00137124785285928f,
				0.00300175684722379f,
				0.00267504725910542f,
				0.00242732073088141f,
				0.00242732073088141f,
				0.00242732073088141f,
				0.00220179313955584f,
				0.001921390665346f,
				0.00197708553639129f,
				0.00143975169852622f,
				0.00285535473751769f,
				0.00440245697510126f,
				0.00137124785285928f,
				0.00300175684722379f,
				0.00267504725910542f,
				0.00242732073088141f,
				0.00242732073088141f,
				0.00242732073088141f,
				0.00220179313955584f,
				0.001921390665346f,
				0.00197708553639129f,
				0.00143975169852622f,
				0.00285535473751769f,
				0.00440245697510126f,
				0.000367340258416393f,
				0.000804133354639806f,
				0.000716611916209643f,
				0.000650249057952727f,
				0.000650249057952727f,
				0.000650249057952727f,
				0.000589833019010667f,
				0.000514716680908798f,
				0.000529636644706432f,
				0.000385691587329935f,
				0.000764914048881184f,
				0.00117936351151152f,
				0.000367340258416393f,
				0.000804133354639806f,
				0.000716611916209643f,
				0.000650249057952727f,
				0.000650249057952727f,
				0.000650249057952727f,
				0.000589833019010667f,
				0.000514716680908798f,
				0.000529636644706432f,
				0.000385691587329935f,
				0.000764914048881184f,
				0.00117936351151152f,
				0.000390588179096978f,
				0.000855024668665309f,
				0.000761964247202775f,
				0.000691401472303059f,
				0.000691401472303059f,
				0.000691401472303059f,
				0.000627161874007023f,
				0.000547291636407352f,
				0.000563155842299277f,
				0.000410100911448314f,
				0.000813323284537834f,
				0.00125400207546144f,
				0.000390588179096978f,
				0.000855024668665309f,
				0.000761964247202775f,
				0.000691401472303059f,
				0.000691401472303059f,
				0.000691401472303059f,
				0.000627161874007023f,
				0.000547291636407352f,
				0.000563155842299277f,
				0.000410100911448314f,
				0.000813323284537834f,
				0.00125400207546144f,
				0.000709724425792627f,
				0.00155363609162465f,
				0.0013845391815768f,
				0.00125632197589019f,
				0.00125632197589019f,
				0.00125632197589019f,
				0.00113959439821692f,
				0.000994464920285962f,
				0.00102329122640545f,
				0.0007451803445962f,
				0.00147786193232199f,
				0.00227860429623668f,
				0.000709724425792627f,
				0.00155363609162465f,
				0.0013845391815768f,
				0.00125632197589019f,
				0.00125632197589019f,
				0.00125632197589019f,
				0.00113959439821692f,
				0.000994464920285962f,
				0.00102329122640545f,
				0.0007451803445962f,
				0.00147786193232199f,
				0.00227860429623668f
		};
		
		// check joint probabilities
//		node_names: {'N6'  'N5'  'N8'  'N7'  'N3'  'N4'  'N9'  'N0' 'N1'}
//		sizes: [2 3 2 2 2 2 2 2 2]
		questionIds = new ArrayList<Long>();
		questionIds.add(6L); questionIds.add(5L); questionIds.add(8L); 
		questionIds.add(7L); questionIds.add(3L); questionIds.add(4L);  
		questionIds.add(9L); questionIds.add(0L); questionIds.add(1L);
		// start from all questions in state 0
		states = new ArrayList<Integer>();
		states.add(0); states.add(0); states.add(0);
		states.add(0); states.add(0); states.add(0);
		states.add(0); states.add(0); states.add(0);
		// index to be used to access joint probability
		indexForJointProbability = 0;	
		sum = 0;	// check that joint prob of ME is summing up to 1
		// compare joint probability returned by the engine and expected
		for (int stateNode1 = 0; stateNode1 < 2; stateNode1++) {	// iterate on states of node 1
			for (int stateNode0 = 0; stateNode0 < 2; stateNode0++) {	// iterate on states of node 0
				for (int stateNode9 = 0; stateNode9 < 2; stateNode9++) {	// iterate on states of node 9
					for (int stateNode4 = 0; stateNode4 < 2; stateNode4++) {	// iterate on states of node 4
						for (int stateNode3 = 0; stateNode3 < 2; stateNode3++) {	// iterate on states of node 3
							for (int stateNode7 = 0; stateNode7 < 2; stateNode7++) {	// iterate on states of node 7
								for (int stateNode8 = 0; stateNode8 < 2; stateNode8++) {	// iterate on states of node 8
									for (int stateNode5 = 0; stateNode5 < 3; stateNode5++) {	// iterate on states of node 5
										for (int stateNode6 = 0; stateNode6 < 2; stateNode6++) {	// iterate on states of node 6
											// set states accourdingly to current iteration
											states.set(0, stateNode6); states.set(1, stateNode5); states.set(2, stateNode8);
											states.set(3, stateNode7); states.set(4, stateNode3); states.set(5, stateNode4);
											states.set(6, stateNode9); states.set(7, stateNode0); states.set(8, stateNode1);
											// obtain the joint probability from engine
											float jointProbability = engine.getJointProbability(questionIds, states);
											// compare results
//											System.out.format(
//													"%d,%d,%d,%d,%d,%d,%d,%d,%d,%1.20f,%1.20f%n",
//													stateNode6,stateNode5,stateNode8,stateNode7,stateNode3,stateNode4,stateNode9,stateNode0,stateNode1,
//													jointAfter9[indexForJointProbability],jointProbability
//												);
											assertEquals(
													"joint index = " + indexForJointProbability + "; "
													+ "[6,5,8,7,3,4,9,0,1]=["
													+ stateNode6+"," + stateNode5+","+ stateNode8+","+ stateNode7+","+ stateNode3+","+ stateNode4+","+ stateNode9+","+ stateNode0+","+ stateNode1 + "]", 
													jointAfter9[indexForJointProbability], 
													jointProbability, 
													PROB_ERROR_MARGIN	// use the half of the smallest joint prob as the error margin
											);
											sum += jointProbability;
											indexForJointProbability++;	// point to next item in jointBeforeIteration5
										}
									}
								}
							}
						}
					}
				}
			}
		}
		assertEquals(1f, sum, PROB_ERROR_MARGIN);
		
		
//		System.out.println("Cumulative error = " + cumulativeError + ", max error = " + maximumError + " at " + indexOfMaxError 
//				+ ", min prob matlab = " + min + ", min prob ME = " + minJointProbME
//				+ ", max prob matlab = " + max + ", max prob ME = " + maxJointProbME);
		
		assertEquals(101.49, engine.scoreUserEv(9, null, null), ASSET_ERROR_MARGIN);
		
//		 addQuestion(questionId=2,numberStates=2)
		assertTrue(engine.addQuestion(null, new Date(), 2L, 2, null));
		
//		List<Long> ids = new ArrayList<Long>();
//		List<Integer> states = new ArrayList<Integer>();
//		ids.add(6l); states.add(0);
//		ids.add(5l); states.add(0);
//		ids.add(8l); states.add(0);
//		System.out.println("P("+ids +"=" + states + ") = " + engine.getJointProbability(ids, states));
		
//		 addQuestionAssumption(childQuestionId=3,parentQuestionIds=[2])
		questionIds = new ArrayList<Long>();
		questionIds.add(2L);
		assertTrue(engine.addQuestionAssumption(null, new Date(), 3L, questionIds , null));
		
		
//		 addQuestionAssumption(childQuestionId=3,parentQuestionIds=[4, 2])
		questionIds = new ArrayList<Long>();
		questionIds.add(4L);
		questionIds.add(2L);
		assertTrue(engine.addQuestionAssumption(null, new Date(), 3L, questionIds , null));
		
		
//		 getEditLimits(userId=9,questionId=2,questionState=0,assumptionIds=[4],assumedStates=[1])=[0.4425387, 0.55746126]
		
		
		assertEquals(101.49, engine.scoreUserEv(9, null, null), ASSET_ERROR_MARGIN);
	        	
		// iteration 10
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 2L, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 2L, null, null).get(0));
		}
		engine.resolveQuestion(null, new Date(), 2L, 0);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		
		
		
//		 getProbLists(questionIds=null,assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[1.0, 0.0], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.2916861, 0.2924763, 0.4158376], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.49196956, 0.5080304], 9=[0.5312502, 0.46874982]}
//		 !!! scoreUserEv(userId=9,assumptionIds=null,assumedStates=null)=101.49192 (expected 101.49)
//		 !!! scoreUserEv(userId=9,assumptionIds=[4],assumedStates=[1])=101.49193 (expected 101.49)
//		 scoreUserQuestionEvStates(userId=9,questionId=2,assumptionIds=[4],assumedStates=[1])=[101.49193, 0.0]
//		 getCashPerStates(userId=9,questionId=2,assumptionIds+[4],assumedStates=[1])=[17.612444, -Infinity]
//		 getCash(userId=9,assumptionIds=null,assumedStates=null)=17.612444
//		 getCash(userId=9,assumptionIds=[4],assumedStates=[1])=17.612444

		assertEquals(101.49, engine.scoreUserEv(9, null, null), ASSET_ERROR_MARGIN);
		
//		===============Iteration#11, user8, (8|7)
//		getEditLimits(userId=8,questionId=8,questionState=0,assumptionIds=[7],assumedStates=[0])=[0.2459848, 0.7459848]
//		getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[1.0, 0.0], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.2916861, 0.2924763, 0.4158376], 6=[0.4637435, 0.53625643], 7=[0.5, 0.5], 8=[0.49196956, 0.5080304], 9=[0.5312502, 0.46874982]}
//		getCash(userId=8,assumptionIds=null,assumedStates=null)=100.0
//		getCash(userId=8,assumptionIds=[7],assumedStates=[0])=100.0
		
		
//		addTrade(occurredWhen=Wed Sep 05 07:20:15 BOT 2012,userId=8,questionId=8,newValues=[0.4979575, 0.50204265],assumptionIds=[7],assumedStates=[0])
		newValues = new ArrayList<Float>();
		newValues.add(0.4979575f);
		newValues.add(0.50204265f);
		questionIds = new ArrayList<Long>();
		questionIds.add(7L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assertFalse(engine.addTrade(null, new Date(), "",8,8, newValues, questionIds, assumedStates , false).isEmpty());

		
//		getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999958, 0.5], 1=[0.4927048, 0.50729483], 2=[1.0, 0.0], 3=[0.620605, 0.37939486], 4=[0.6124158, 0.3875838], 5=[0.2917655, 0.29285103, 0.41538346], 6=[0.4636725, 0.5363272], 7=[0.49999955, 0.49999985], 8=[0.49496323, 0.50503665], 9=[0.5312505, 0.46874982]}
//		getCash(userId=8,assumptionIds=null,assumedStates=null)=98.28947
//		getCash(userId=8,assumptionIds=[7],assumedStates=[0])=98.28947
//		scoreUserEv(userId=8,assumptionIds=null,assumedStates=null)=100.00515

//		=============== Iteration#12, user6, (N1|N0)
//		getEditLimits(userId=6,questionId=1,questionState=1,assumptionIds=[0],assumedStates=[0])=[0.27841428, 0.72158575]
//		getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.492705, 0.507295], 2=[1.0, 0.0], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.29176554, 0.29285103, 0.41538346], 6=[0.46367282, 0.53632724], 7=[0.5, 0.5], 8=[0.4949635, 0.5050365], 9=[0.5312502, 0.46874982]}
//		getCash(userId=6,assumptionIds=null,assumedStates=null)=84.4695
//		getCash(userId=6,assumptionIds=[0],assumedStates=[0])=84.4695
		
		
//		addTrade(occurredWhen=Wed Sep 05 07:20:17 BOT 2012,userId=6,questionId=1,newValues=[0.34704185, 0.65295815],assumptionIds=[0],assumedStates=[0])
		newValues = new ArrayList<Float>();
		newValues.add(0.34704185f);
		newValues.add(0.65295815f);
		questionIds = new ArrayList<Long>();
		questionIds.add(0L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0); 
		assertFalse(engine.addTrade(null, new Date(), "",6,1, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5, 0.5], 1=[0.41622612, 0.58377403], 2=[0.9999998, 0.0], 3=[0.6206048, 0.37939483], 4=[0.61241597, 0.38758415], 5=[0.29176563, 0.292851, 0.41538358], 6=[0.46367282, 0.53632736], 7=[0.49999985, 0.5000002], 8=[0.4949635, 0.5050367], 9=[0.5312503, 0.4687498]}
//		getCash(userId=6,assumptionIds=null,assumedStates=null)=31.787628
//		getCash(userId=6,assumptionIds=[0],assumedStates=[0])=31.787628
//		scoreUserEv(userId=6,assumptionIds=null,assumedStates=null)=103.67753
		
		
//		=============== Iteration#13, user3, (N6|N5,N8)
//		getEditLimits(userId=3,questionId=6,questionState=0,assumptionIds=[5, 8],assumedStates=[2, 1])=[0.19670908, 0.6967091]
		
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 6L, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 6L, null, null).get(0));
		}

		engine.resolveQuestion(null, new Date(), 6L, 0);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		
//		getProbLists(questionIds=null,assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.41622594, 0.5837741], 2=[1.0, 0.0], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.26421338, 0.34479752, 0.39098936], 6=[1.0000002, 0.0], 7=[0.49992394, 0.5000763], 8=[0.48223865, 0.5177616], 9=[0.5312502, 0.46874982]}
//		scoreUserEv(userId=3,assumptionIds=null,assumedStates=null)=100.00003
//		scoreUserEv(userId=3,assumptionIds=[5, 8],assumedStates=[2, 1])=100.0
//		scoreUserQuestionEvStates(userId=3,questionId=6,assumptionIds=[5, 8],assumedStates=[2, 1])=[100.0, 0.0]
//		getCashPerStates(userId=3,questionId=6,assumptionIds+[5, 8],assumedStates=[2, 1])=[100.0, -Infinity]
//		getCash(userId=3,assumptionIds=null,assumedStates=null)=100.0
//		getCash(userId=3,assumptionIds=[5, 8],assumedStates=[2, 1])=100.0
		
		
//		=============== Iteration#14, user10, (N4|N3)
//		getEditLimits(userId=0,questionId=4,questionState=1,assumptionIds=[3],assumedStates=[1])=[0.36199987, 0.8126356]
//		getProbLists(assumptionIds=null,assumedStates=null)={0=[0.49999994, 0.50000006], 1=[0.41622594, 0.5837741], 2=[1.0, 0.0], 3=[0.620605, 0.379395], 4=[0.61241597, 0.38758403], 5=[0.26421338, 0.34479752, 0.39098936], 6=[1.0000002, 0.0], 7=[0.49992394, 0.5000763], 8=[0.48223865, 0.5177616], 9=[0.5312502, 0.46874982]}
//		getCash(userId=0,assumptionIds=null,assumedStates=null)=0.2554088
//		getCash(userId=0,assumptionIds=[3],assumedStates=[1])=86.41649
		
		
//		addTrade(occurredWhen=Wed Sep 05 07:20:18 BOT 2012,userId=0,questionId=4,newValues=[0.3710119, 0.6289884],assumptionIds=[3],assumedStates=[1])
		newValues = new ArrayList<Float>();
		newValues.add(0.3710119f);
		newValues.add(0.6289884f);
		questionIds = new ArrayList<Long>();
		questionIds.add(3L); 
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1); 
		assertFalse(engine.addTrade(null, new Date(), "",0,4, newValues, questionIds, assumedStates , false).isEmpty());
		
		
//		getProbLists(assumptionIds=null,assumedStates=null)={0=[0.5000001, 0.50000054], 1=[0.41622627, 0.5837745], 2=[1.000001, 0.0], 3=[0.62060535, 0.37939534], 4=[0.623781, 0.3762196], 5=[0.26421347, 0.3447977, 0.39098936], 6=[1.000001, 0.0], 7=[0.499924, 0.5000766], 8=[0.48223886, 0.5177619], 9=[0.53125066, 0.4687501]}
//		getCash(userId=0,assumptionIds=null,assumedStates=null)=0.25542596
//		getCash(userId=0,assumptionIds=[3],assumedStates=[1])=79.70443
//		scoreUserEv(userId=0,assumptionIds=null,assumedStates=null)=114.44239
		
		
//		=============== Iteration#15, user1, (N0|N1)
//		getCash(userId=1,assumptionIds=null,assumedStates=null)=100.0
//		getCash(userId=1,assumptionIds=[1],assumedStates=[0])=100.0
		
//		addCash(userId=1,assets=77.755005)
		assertTrue(engine.addCash(null, new Date(), 1,77.755005f , ""));
		
//		getEditLimits(userId=1,questionId=0,questionState=1,assumptionIds=[1],assumedStates=[0])=[0.1700802, 0.8784019]
		
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0L, null, null).get(1));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0L, null, null).get(1));
		}

		engine.resolveQuestion(null, new Date(), 0L, 1);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		
//		getProbLists(questionIds=null,assumptionIds=null,assumedStates=null)={0=[0.0, 1.0], 1=[0.48541, 0.51459], 2=[1.0, 0.0], 3=[0.620605, 0.3793951], 4=[0.6237807, 0.37621933], 5=[0.26427856, 0.34488264, 0.39108586], 6=[1.0002471, 0.0], 7=[0.5000473, 0.50019974], 8=[0.4823577, 0.5178894], 9=[0.5312502, 0.46874982]}
//		!!! scoreUserEv(userId=1,assumptionIds=null,assumedStates=null)=177.79893 (expected 177.755)
//		!!! scoreUserEv(userId=1,assumptionIds=[1],assumedStates=[0])=177.84286 (expected 177.755)
//		scoreUserQuestionEvStates(userId=1,questionId=0,assumptionIds=[1],assumedStates=[0])=[0.0, 177.84286]
//		getCashPerStates(userId=1,questionId=0,assumptionIds+[1],assumedStates=[0])=[-Infinity, 177.755]
		
		
		assertEquals(177.755, engine.scoreUserEv(1, null, null), ASSET_ERROR_MARGIN);
		
		// restore backup
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
	}
	
	/**
	 * Test method for {@link MarkovEngineImpl#doBalanceTrade(Long, Date, String, long, long, List, List)}
	 * with incomplete set of assumptions
	 */
	public final void testBalanceTradeIncompleteAssumptions()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setDefaultInitialAssetTableValue(1000f);
		engine.initialize();
		/*
		 * Generate the following net
		 * 
		 * 0 -> 1 <- 2
		 *      |
		 *      V
		 *      3
		 *      
		 *  All nodes have 3 states
		 */
		long transactionKey = engine.startNetworkActions();
		// the nodes
		engine.addQuestion(transactionKey, new Date(), 0, 3, null);
		engine.addQuestion(transactionKey, new Date(), 1, 3, null);
		engine.addQuestion(transactionKey, new Date(), 2, 3, null);
		engine.addQuestion(transactionKey, new Date(), 3, 3, null);
		// edges 0 -> 1 <- 2
		List<Long> questionIds = new ArrayList<Long>();
		questionIds.add(0L);
		questionIds.add(2L);
		engine.addQuestionAssumption(transactionKey, new Date(), 1, questionIds , null);
		// edge 1 -> 3
		engine.addQuestionAssumption(transactionKey, new Date(), 3, Collections.singletonList(1L) , null);
		engine.commitNetworkActions(transactionKey);
		
		// user 1 makes trades in question 3 (clique has 2 nodes and question is not in separator), 
		// so that the assets are completely different given different assumptions.
		List<Float> newValues = new ArrayList<Float>(3);
		newValues.add(.6f);
		newValues.add(.2f);
		newValues.add(.2f);
		engine.addTrade(null, new Date(), "User 1, P(3|1=0)=[.6,.2,.2]", 1, 3, newValues , Collections.singletonList(1L), Collections.singletonList(0), false);
		newValues.set(0, .2f);
		newValues.set(1, .2f);
		newValues.set(2, .6f);
		engine.addTrade(null, new Date(), "User 1, P(3|1=2)=[.2,.2,.6]", 1, 3, newValues , Collections.singletonList(1L), Collections.singletonList(2), false);
		
		// user 2 makes trades in question 0 (clique has 3 nodes and question is not in separator)
		questionIds = new ArrayList<Long>();
		questionIds.add(1L);
		questionIds.add(2L);
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(0);
		newValues.set(0, .2f);
		newValues.set(1, .2f);
		newValues.set(2, .6f);
		engine.addTrade(null, new Date(), "User 2, P(0|1,=0,2=0)=[.2,.2,.6]", 2, 0, newValues , questionIds, assumedStates, false);
		assumedStates.set(0,0);
		assumedStates.set(1,2);
		newValues.set(0, .6f);
		newValues.set(1, .2f);
		newValues.set(2, .2f);
		engine.addTrade(null, new Date(), "User 2, P(0|1,=0,2=2)=[.6,.2,.2]", 2, 0, newValues , questionIds, assumedStates, false);
		assumedStates.set(0,2);
		assumedStates.set(1,0);
		newValues.set(0, .1f);
		newValues.set(1, .8f);
		newValues.set(2, .1f);
		engine.addTrade(null, new Date(), "User 2, P(0|1=2,2=2)=[.1,.8,.1]", 2, 0, newValues , questionIds, assumedStates, false);
		assumedStates.set(0,1);
		assumedStates.set(1,1);
		newValues.set(0, .4f);
		newValues.set(1, .2f);
		newValues.set(2, .4f);
		engine.addTrade(null, new Date(), "User 2, P(0|1,=1,2=1)=[.4,.2,.4]", 2, 0, newValues , questionIds, assumedStates, false);
		
		
		// user 3 makes trades in question 1 given question 3 (question is in separator and trade is in one of the cliques)
		newValues.set(0, .2f);
		newValues.set(1, .1f);
		newValues.set(2, .7f);
		engine.addTrade(null, new Date(), "User 3, P(1|3=0)=[.2,.1,.7]", 3, 1, newValues , Collections.singletonList(3L), Collections.singletonList(0), false);
		newValues.set(0, .7f);
		newValues.set(1, .2f);
		newValues.set(2, .1f);
		engine.addTrade(null, new Date(), "User 3, P(1|3=2)=[.7,.2,.1]", 3, 1, newValues , Collections.singletonList(3L), Collections.singletonList(2), false);
		
		// user 3 makes trades in question 1 given question 0 (question is in separator and trade is in the another clique)
		newValues.set(0, .6f);
		newValues.set(1, .2f);
		newValues.set(2, .2f);
		engine.addTrade(null, new Date(), "User 3, P(1|0=0)=[.6,.2,.2]", 3, 1, newValues , Collections.singletonList(0L), Collections.singletonList(0), false);
		newValues.set(0, .2f);
		newValues.set(1, .2f);
		newValues.set(2, .6f);
		engine.addTrade(null, new Date(), "User 3, P(1|0=2)=[.2,.2,.6]", 3, 1, newValues , Collections.singletonList(0L), Collections.singletonList(2), false);

		
		// case 1: clique has 2 nodes and we are balancing a node not in separator
		
		// user 1 balances question 3
		List<TradeSpecification> previewedTrades = engine.previewBalancingTrades(1, 3 , null, null);	// check that preview matches executed
		engine.doBalanceTrade(null, new Date(), "Case 1 - balance 3", 1, 3, null, null);
		
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(3L, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 3L)) {
				assertNotNull(qe.getUserId());
			}
		}
		assertTrue(questionHistory.get(questionHistory.size()-1) instanceof BalanceTradeNetworkAction);
		assertFalse(((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades().isEmpty());
		List<TradeSpecification> executedTrades = ((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades();
		for (int i = 0; i < executedTrades.size(); i++) {
			TradeSpecification trade = executedTrades.get(i);
			assertEquals(3L, trade.getQuestionId().longValue());
			assertEquals(1L, trade.getUserId().longValue());
			
			// compare with previewed
			assertEquals(trade.getQuestionId(), previewedTrades.get(i).getQuestionId());
			assertEquals(trade.getUserId(), previewedTrades.get(i).getUserId());
			if (trade.getAssumptionIds() == null) {
				assertNull(previewedTrades.get(i).getAssumptionIds());
			} else {
				// check that the content of assumptions are the same
				assertEquals(trade.getAssumptionIds().size(), previewedTrades.get(i).getAssumptionIds().size());
				for (int j = 0; j < trade.getAssumptionIds().size(); j++) {
					assertEquals(trade.getAssumptionIds().get(j), previewedTrades.get(i).getAssumptionIds().get(j));
					assertEquals(trade.getAssumedStates().get(j), previewedTrades.get(i).getAssumedStates().get(j));
				}
			}
			// check that the  probabilities are the same
			assertEquals(trade.getProbabilities().size(), previewedTrades.get(i).getProbabilities().size());
			for (int j = 0; j < trade.getProbabilities().size(); j++) {
				assertEquals(trade.getProbabilities().get(j), previewedTrades.get(i).getProbabilities().get(j));
			}
		}
		
		// check that the assets given states of a balanced question are the same
		List<Float> assetsIf = engine.getAssetsIfStates(1, 3L, null, null);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assetsIf = engine.getAssetsIfStates(1, 3L, Collections.singletonList(1L), Collections.singletonList(0));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assetsIf = engine.getAssetsIfStates(1, 3L, Collections.singletonList(1L), Collections.singletonList(1));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assetsIf = engine.getAssetsIfStates(1, 3L, Collections.singletonList(1L), Collections.singletonList(2));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		// check that the cash given states of a balanced question are the same
		List<Float> cashPerState = engine.getCashPerStates(1, 3L, null, null);
		assertEquals(3, cashPerState.size()); // all nodes have 3 states
		for (int i = 1; i < cashPerState.size(); i++) {
			assertEquals("["+i+"]"+cashPerState.toString(), cashPerState.get(i-1), cashPerState.get(i), ASSET_ERROR_MARGIN);
		}
		
		// case 2: clique has 3 nodes and we are balancing a node not in separator, given only 1 assumption
		
		// user 2 balances question 0 given 2=2
		previewedTrades = engine.previewBalancingTrades(2, 0, Collections.singletonList(2L), Collections.singletonList(2));	// check that preview matches executed
		engine.doBalanceTrade(null, new Date(), "Case 2 - balance 0|2=2", 2, 0, Collections.singletonList(2L), Collections.singletonList(2));
		questionHistory = engine.getQuestionHistory(0L, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 0L)) {
				assertNotNull(qe.getUserId());
			}
		}
		assertTrue(questionHistory.get(questionHistory.size()-1) instanceof BalanceTradeNetworkAction);
		assertFalse(((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades().isEmpty());
		boolean hasAssumptionState = false;
		executedTrades = ((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades();
		for (int i = 0; i < executedTrades.size(); i++) {
			TradeSpecification trade = executedTrades.get(i);
			assertEquals(2L, trade.getUserId().longValue());
			assertEquals(0L, trade.getQuestionId().longValue());
			assertTrue(trade.getAssumptionIds().contains(2L));
			if (trade.getAssumedStates().contains(2)) {
				hasAssumptionState = true;
			}
			
			// compare with previewed
			assertEquals(trade.getQuestionId(), previewedTrades.get(i).getQuestionId());
			assertEquals(trade.getUserId(), previewedTrades.get(i).getUserId());
			if (trade.getAssumptionIds() == null) {
				assertNull(previewedTrades.get(i).getAssumptionIds());
			} else {
				// check that the content of assumptions are the same
				assertEquals(trade.getAssumptionIds().size(), previewedTrades.get(i).getAssumptionIds().size());
				for (int j = 0; j < trade.getAssumptionIds().size(); j++) {
					assertEquals(trade.getAssumptionIds().get(j), previewedTrades.get(i).getAssumptionIds().get(j));
					assertEquals(trade.getAssumedStates().get(j), previewedTrades.get(i).getAssumedStates().get(j));
				}
			}
			// check that the  probabilities are the same
			assertEquals(trade.getProbabilities().size(), previewedTrades.get(i).getProbabilities().size());
			for (int j = 0; j < trade.getProbabilities().size(); j++) {
				assertEquals(trade.getProbabilities().get(j), previewedTrades.get(i).getProbabilities().get(j));
			}
		}
		assertTrue(hasAssumptionState);
		
		// check that the assets given states of a balanced question are the same
		assetsIf = engine.getAssetsIfStates(2, 0, Collections.singletonList(2L), Collections.singletonList(2));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		questionIds = new ArrayList<Long>();
		questionIds.add(1L);
		questionIds.add(2L);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(2);
		assetsIf = engine.getAssetsIfStates(2, 0, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,1);
		assetsIf = engine.getAssetsIfStates(2, 0, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,2);
		assetsIf = engine.getAssetsIfStates(2, 0, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		// check that the cash given states of a balanced question are the same
		cashPerState = engine.getCashPerStates(2, 0, Collections.singletonList(2L), Collections.singletonList(2));
		assertEquals(3, cashPerState.size()); // all nodes have 3 states
		for (int i = 1; i < cashPerState.size(); i++) {
			assertEquals("["+i+"]"+cashPerState.toString(), cashPerState.get(i-1), cashPerState.get(i), ASSET_ERROR_MARGIN);
		}
		
		
		// case 3 balance a node in separator
		
		// User 3 balances question 1
		previewedTrades = engine.previewBalancingTrades(3, 1, null, null);	// check that preview matches executed
		engine.doBalanceTrade(null, new Date(), "User 3 balances question 1", 3, 1, null, null);
		questionHistory = engine.getQuestionHistory(1L, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 1L)) {
				assertNotNull(qe.getUserId());
			}
		}
		assertTrue(questionHistory.get(questionHistory.size()-1) instanceof BalanceTradeNetworkAction);
		assertFalse(((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades().isEmpty());
		executedTrades = ((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades();
		for (int i = 0; i < executedTrades.size(); i++) {
			TradeSpecification trade = executedTrades.get(i);
			assertEquals(3L, trade.getUserId().longValue());
			assertEquals(1L, trade.getQuestionId().longValue());
			
			// compare with previewed
			assertEquals(trade.getQuestionId(), previewedTrades.get(i).getQuestionId());
			assertEquals(trade.getUserId(), previewedTrades.get(i).getUserId());
			if (trade.getAssumptionIds() == null) {
				assertNull(previewedTrades.get(i).getAssumptionIds());
			} else {
				// check that the content of assumptions are the same
				assertEquals(trade.getAssumptionIds().size(), previewedTrades.get(i).getAssumptionIds().size());
				for (int j = 0; j < trade.getAssumptionIds().size(); j++) {
					assertEquals(trade.getAssumptionIds().get(j), previewedTrades.get(i).getAssumptionIds().get(j));
					assertEquals(trade.getAssumedStates().get(j), previewedTrades.get(i).getAssumedStates().get(j));
				}
			}
			// check that the  probabilities are the same
			assertEquals(trade.getProbabilities().size(), previewedTrades.get(i).getProbabilities().size());
			for (int j = 0; j < trade.getProbabilities().size(); j++) {
				assertEquals(trade.getProbabilities().get(j), previewedTrades.get(i).getProbabilities().get(j));
			}
		}
		
		// check that the assets given states of a balanced question are the same
		questionIds = new ArrayList<Long>();
		questionIds.add(0L);
		questionIds.add(2L);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(0);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,0);
		assumedStates.set(0,1);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,0);
		assumedStates.set(0,2);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,1);
		assumedStates.set(0,0);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,1);
		assumedStates.set(0,1);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,1);
		assumedStates.set(0,2);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,2);
		assumedStates.set(0,0);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,2);
		assumedStates.set(0,1);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assumedStates.set(0,2);
		assumedStates.set(0,2);
		assetsIf = engine.getAssetsIfStates(3, 1, questionIds, assumedStates);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		
		assetsIf = engine.getAssetsIfStates(3, 1, Collections.singletonList(3L), Collections.singletonList(0));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assetsIf = engine.getAssetsIfStates(3, 1, Collections.singletonList(3L), Collections.singletonList(1));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		assetsIf = engine.getAssetsIfStates(3, 1, Collections.singletonList(3L), Collections.singletonList(2));
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		
		assetsIf = engine.getAssetsIfStates(3, 1, null, null);
		assertEquals(3, assetsIf.size()); // all nodes have 3 states
		for (int i = 1; i < assetsIf.size(); i++) {
			assertEquals("["+i+"]"+assetsIf.toString(), 
					assetsIf.get(i-1), assetsIf.get(i), ASSET_ERROR_MARGIN);
		}
		// check that the cash given states of a balanced question are the same
		cashPerState = engine.getCashPerStates(3, 1, null, null);
		assertEquals(3, cashPerState.size()); // all nodes have 3 states
		for (int i = 1; i < cashPerState.size(); i++) {
			assertEquals("["+i+"]"+cashPerState.toString(), cashPerState.get(i-1), cashPerState.get(i), ASSET_ERROR_MARGIN);
		}

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Tests an optimization which tries to integrate independent
	 * trades into a single propagation
	 */
	public final void testExecuteTradesFullyDisconnected1Transaction()  {
		engine.setDefaultInitialAssetTableValue(1000);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setToDeleteResolvedNode(true);
		engine.setToIntegrateConsecutiveResolutions(true);
		engine.initialize();
		
		/*
		 * Create the following network:
		 * 
		 * 1->2 3 4
		 */
		
		engine.addQuestion(null, new Date(), 1L, 2, null);
		engine.addQuestion(null, new Date(), 2L, 2, null);
		engine.addQuestion(null, new Date(), 3L, 2, null);
		engine.addQuestion(null, new Date(), 4L, 2, null);
		engine.addQuestionAssumption(null, new Date(), 2L, Collections.singletonList(1L), null);
		
		long transactionKey = engine.startNetworkActions();
		
		/*
		 * Trade sequence:
		 *   User  question  prob
		 *1  1     2|1=0     [.2,.8]  buffer
		 *2  2     3         [.2,.8]  wait
		 *3  3     4         [.2,.8]  wait
		 *4  1     2|1=1     [.8,.2]  integrate with trade 1
		 *5  2     4         [.3,.7]  must commit question 4 trade 3 (user 3), wait
		 *6  1     3         [.3,.7]  must commit question 3 trade 2 (user 2), wait
		 *7  3     1         [.3,.7]  must commit buffer trade 1 (user 1), buffer
		 *8  1     2         [.3,.7]  must commit buffer trade 7 (user 2), buffer
		 *9  2     4         [.4,.6]  override question 4, wait
		 *10 1     2         [.4,.6]  override buffer, buffer
		 *11 resolve 4 commit everything
		 *12 1     2|1=0     [.2,.8]  buffer
		 *13 2     3         [.2,.8]  wait
		 * END - commit everything
		 */
		
//		*1  1     2|1=0     [.2,.8]  buffer
		List<Float> newValues = new ArrayList<Float>(); newValues.add(.2f); newValues.add(.8f);
		engine.addTrade(transactionKey, new Date(1), "1;2|1=0;[.2,.8]", 1L, 2L, newValues , Collections.singletonList(1L), Collections.singletonList(0), false);
//		*2  2     3         [.2,.8]  wait
		newValues = new ArrayList<Float>(); newValues.add(.2f); newValues.add(.8f);
		engine.addTrade(transactionKey, new Date(1), "2;3;[.2,.8]", 2L, 3L, newValues , null, null, false);
//		*3  3     4         [.2,.8]  wait
		newValues = new ArrayList<Float>(); newValues.add(.2f); newValues.add(.8f);
		engine.addTrade(transactionKey, new Date(1), "3;4;[.2,.8]", 3L, 4L, newValues , null, null, false);
//		*4  1     2|1=1     [.8,.2]  integrate with trade 1
		newValues = new ArrayList<Float>(); newValues.add(.8f); newValues.add(.2f);
		engine.addTrade(transactionKey, new Date(1), "1;2|1=2;[.8,.2]", 1L, 2L, newValues , Collections.singletonList(1L), Collections.singletonList(1), false);
//		*5  2     4         [.3,.7]  must commit question 4 trade 3 (user 3), wait
//		*6  1     3         [.3,.7]  must commit question 3 trade 2 (user 2), wait
//		*7  3     1         [.3,.7]  must commit buffer trade 1 (user 1), buffer
//		*8  1     2         [.3,.7]  must commit buffer trade 7 (user 2), buffer
//		*9  2     4         [.4,.6]  override question 4, wait
//		*10 1     2         [.4,.6]  override buffer, buffer
//		*11 resolve 4 commit everything
//		*12 1     2|1=0     [.2,.8]  buffer
//		*13 2     3         [.2,.8]  wait
//		* END - commit everything
		engine.commitNetworkActions(transactionKey);
	}
	
	/**
	 * Tests a condition which balances a question in a separator.
	 * The E<-D->F Bayes net is used
	 */
	public final void testBalanceSeparator()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// initialize configuration of this test
		engine.setDefaultInitialAssetTableValue(1000f);
		engine.setCurrentCurrencyConstant(100f);
		engine.setCurrentLogBase(2);
		engine.initialize();
		engine.setToForceBalanceQuestionEntirely(true);	// ignore assumptions in balance trade (i.e. exit from question completely)
		
		
		// create the E<-D->F Bayes net
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0DL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0EL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0FL, 2, null);
		// D->E
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0EL, Collections.singletonList(0x0DL), null);
		// D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0FL, Collections.singletonList(0x0DL), null);
		engine.commitNetworkActions(transactionKey);
		
		// make sure we have 2 cliques each with size 3 ([D,E];[D,F])
		assertEquals(2, engine.getProbabilisticNetwork().getJunctionTree().getCliques().size());
		assertEquals(2, engine.getProbabilisticNetwork().getJunctionTree().getCliques().get(0).getNodes().size());
		assertEquals(2, engine.getProbabilisticNetwork().getJunctionTree().getCliques().get(1).getNodes().size());
		
		// make sure we have 1 separator with size 1 ([D])
		assertEquals(1, engine.getProbabilisticNetwork().getJunctionTree().getSeparators().size());
		assertEquals(1, engine.getProbabilisticNetwork().getJunctionTree().getSeparators().iterator().next().getNodes().size());
		
		// make trades in the separators that: in one of the cliques, state 0 has high assets position, in the other clique, state 1 has low asset position
		

		// check that if I preview balancing trades now, it returns empty
		assertTrue(engine.previewBalancingTrades(1, 0x0D, null, null).isEmpty());
		assertTrue(engine.previewBalancingTrades(1, 0x0E, null, null).isEmpty());
		assertTrue(engine.previewBalancingTrades(1, 0x0F, null, null).isEmpty());
		
		// in [D,E], D=0 has higher asset position
		List<Float> newValues = new ArrayList<Float>(4);
		newValues.add(0.8f);	// P(D=0|E=0)
		newValues.add(0.2f);	// P(D=1|E=0)
		newValues.add(0.8f);	// P(D=0|E=1)
		newValues.add(0.2f);	// P(D=1|E=1)
		engine.addTrade( null, new Date(), 
				"1 trades P(D|E) = [.8,.2,.8,.2]", 
				1, 0x0DL, newValues , 
				Collections.singletonList(0x0EL), 
				null, 	// set states to null, so that I can specify the whole conditional probabilities at once
				false	// do not allow negative cash
			);
		
		// make sure the conditional probabilities are OK
		List<Float> probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), null);
		assertEquals(4, probList.size());
		assertEquals(.8, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.2, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(.8, probList.get(2), PROB_ERROR_MARGIN);
		assertEquals(.2, probList.get(3), PROB_ERROR_MARGIN);
		

		// check that if I preview balancing trades now, it returns empty
		assertTrue(engine.previewBalancingTrades(2, 0x0D, null, null).isEmpty());
		assertTrue(engine.previewBalancingTrades(2, 0x0E, null, null).isEmpty());
		assertTrue(engine.previewBalancingTrades(2, 0x0F, null, null).isEmpty());
		
		// user 2 resets the dependency P(D|E), so that we have another user with unbalanced D
		newValues = new ArrayList<Float>(4);
		newValues.add(0.5f);	// P(D=0|E=0)
		newValues.add(0.5f);	// P(D=1|E=0)
		newValues.add(0.5f);	// P(D=0|E=1)
		newValues.add(0.5f);	// P(D=1|E=1)
		engine.addTrade( null, new Date(), 
				"2 trades P(D|E) = [.5,.5,.5,.5]", 
				2, 0x0DL, newValues , 
				Collections.singletonList(0x0EL), 
				null, 	// set states to null, so that I can specify the whole conditional probabilities at once
				false	// do not allow negative cash
		);
		
		// make sure the conditional probabilities are OK
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), null);
		assertEquals(4, probList.size());
		assertEquals(.5, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.5, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(.5, probList.get(2), PROB_ERROR_MARGIN);
		assertEquals(.5, probList.get(3), PROB_ERROR_MARGIN);
		
		// in [D,F], D=1 has higher asset position
		newValues = new ArrayList<Float>(4);
		newValues.add(0.3f);	// P(D=0|F=0)
		newValues.add(0.7f);	// P(D=1|F=0)
		newValues.add(0.3f);	// P(D=0|F=1)
		newValues.add(0.7f);	// P(D=1|F=1)
		engine.addTrade( null, new Date(), 
				"1 trades P(D|F) = [.3,.7,.3,.7]", 
				1, 0x0DL, newValues , 
				Collections.singletonList(0x0FL), 
				null, 	// set states to null, so that I can specify the whole conditional probabilities at once
				false	// do not allow negative cash
		);
		
		// make sure the conditional probabilities are OK
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), null);
		assertEquals(4, probList.size());
		assertEquals(.3, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.7, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(.3, probList.get(2), PROB_ERROR_MARGIN);
		assertEquals(.7, probList.get(3), PROB_ERROR_MARGIN);
		
		// user 2 resets the dependency P(D|F), so that we have another user with unbalanced D
		newValues = new ArrayList<Float>(4);
		newValues.add(0.5f);	// P(D=0|F=0)
		newValues.add(0.5f);	// P(D=1|F=0)
		newValues.add(0.5f);	// P(D=0|F=1)
		newValues.add(0.5f);	// P(D=1|F=1)
		engine.addTrade( null, new Date(), 
				"2 trades P(D|F) = [.5,.5,.5,.5]", 
				2, 0x0DL, newValues , 
				Collections.singletonList(0x0FL), 
				null, 	// set states to null, so that I can specify the whole conditional probabilities at once
				false	// do not allow negative cash
		);
		
		
		// make sure the conditional probabilities are OK
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), null);
		assertEquals(4, probList.size());
		assertEquals(.5, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.5, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(.5, probList.get(2), PROB_ERROR_MARGIN);
		assertEquals(.5, probList.get(3), PROB_ERROR_MARGIN);
		
		// resolve E, so that we have at least 1 clique with only D
		int settledState = (Math.random()<.5)?0:1;
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(settledState ));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(settledState));
		}
		engine.resolveQuestion(null, new Date(), 0x0EL, settledState);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// balance D, which is in 2 cliques
		engine.doBalanceTrade(null, new Date(), "User 1 balances D", 1L, 0x0DL, null, null);
		
		// make sure history is OK
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		QuestionEvent questionEvent = questionHistory.get(questionHistory.size()-1);
		assertTrue(questionEvent instanceof BalanceTradeNetworkAction);
		List<TradeSpecification> executedTrades = ((BalanceTradeNetworkAction)questionEvent).getExecutedTrades();
		if (engine.isToCollapseSimilarBalancingTrades()) {
			assertEquals(2, executedTrades.size());	// 1 in the clique [D], and 1 in [D,E] - collapsed from 2
		} else {
			assertEquals(1 + 2, executedTrades.size());	// 1 in the clique [D], and 2 of [D,E]
		}
		
		// check that assetsIf are the same
		List<Float> assetsIfStates = engine.getAssetsIfStates(1L, 0x0DL, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// check that cash given states are the same
		List<Float> cashPerState = engine.getCashPerStates(1L, 0x0DL, null, null);
		assertEquals(2, cashPerState.size());
		assertEquals(cashPerState.get(0), cashPerState.get(1), ASSET_ERROR_MARGIN);
		
		// now, resolve F, so that we have 2 cliques with only D in them
		settledState = (Math.random()<.5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0FL, null, null).get(settledState));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0FL, null, null).get(settledState));
		}
		engine.resolveQuestion(null, new Date(), 0x0FL, settledState);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// balance D, which is in 2 cliques
		engine.doBalanceTrade(null, new Date(), "User 2 balances D", 2L, 0x0DL, null, null);
		
		// make sure history is OK
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(qe.getUserId());
			}
		}
		questionEvent = questionHistory.get(questionHistory.size()-1);
		assertTrue(questionEvent instanceof BalanceTradeNetworkAction);
		executedTrades = ((BalanceTradeNetworkAction)questionEvent).getExecutedTrades();
		assertEquals(1+1, executedTrades.size());	// 1 for each clique
		
		// check that assetsIf are the same
		assetsIfStates = engine.getAssetsIfStates(2L, 0x0DL, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// check that cash given states are the same
		cashPerState = engine.getCashPerStates(2L, 0x0DL, null, null);
		assertEquals(2, cashPerState.size());
		assertEquals(cashPerState.get(0), cashPerState.get(1), ASSET_ERROR_MARGIN);
		
		// get the marginals now, for comparison
		Map<Long, List<Float>> probsBeforeEmptyBalance = engine.getProbLists(null, null, null);
		
		// if we balance again, it shouldn't do anything
		engine.doBalanceTrade(null, new Date(), "User 1 balances D", 1L, 0x0DL, null, null);
		
		// make sure it did nothing in the history
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(qe.getUserId());
			}
		}
		questionEvent = questionHistory.get(questionHistory.size()-1);
		assertTrue(questionEvent instanceof BalanceTradeNetworkAction);
		executedTrades = ((BalanceTradeNetworkAction)questionEvent).getExecutedTrades();
		assertEquals(0, executedTrades.size());	// 1 in the clique [D], and 2 of [D,E]
		
		// check that assetsIf are still the same
		assetsIfStates = engine.getAssetsIfStates(1L, 0x0DL, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// check that cash given states are still the same
		cashPerState = engine.getCashPerStates(1L, 0x0DL, null, null);
		assertEquals(2, cashPerState.size());
		assertEquals(cashPerState.get(0), cashPerState.get(1), ASSET_ERROR_MARGIN);
		
		// check other user as well
		engine.doBalanceTrade(null, new Date(), "User 2 balances D", 2L, 0x0DL, null, null);
		
		// make sure it did nothing in the history
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		questionEvent = questionHistory.get(questionHistory.size()-1);
		assertTrue(questionEvent instanceof BalanceTradeNetworkAction);
		executedTrades = ((BalanceTradeNetworkAction)questionEvent).getExecutedTrades();
		assertEquals(0, executedTrades.size());	// it did nothing
		
		// check that assetsIf are still the same
		assetsIfStates = engine.getAssetsIfStates(2L, 0x0DL, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// check that cash given states are still the same
		cashPerState = engine.getCashPerStates(2L, 0x0DL, null, null);
		assertEquals(2, cashPerState.size());
		assertEquals(cashPerState.get(0), cashPerState.get(1), ASSET_ERROR_MARGIN);
		
		Map<Long, List<Float>> probsAfterEmptyBalance = engine.getProbLists(null, null, null);
		
		// make sure the marginals did not change
		assertEquals(probsBeforeEmptyBalance.size(), probsAfterEmptyBalance.size());
		for (Long questionId : probsBeforeEmptyBalance.keySet()) {
			List<Float> before = probsBeforeEmptyBalance.get(questionId);
			List<Float> after = probsAfterEmptyBalance.get(questionId);
			assertEquals(probsBeforeEmptyBalance + " -> " + probsAfterEmptyBalance, before.size(), after.size());
			for (int i = 0; i < before.size(); i++) {
				assertEquals(probsBeforeEmptyBalance + " -> " + probsAfterEmptyBalance, before.get(i), after.get(i), PROB_ERROR_MARGIN);
			}
		}
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * This method checks whether {@link MarkovEngineImpl#doBalanceTrade(Long, Date, String, long, long, List, List)}
	 * will balance both cliques related to a node in the separator.
	 * This test is similar to {@link #testBalanceSeparator()}, but this test focuses on
	 * whether both cliques are balanced locally.
	 */
	public final void testLocallyAndGloballyBalanceSeparator() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// make sure new users starts with 100 assets, and b=100 and base of log is 2
		engine.setDefaultInitialAssetTableValue(1000);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		
		// start the transaction
		Long transactionKey = engine.startNetworkActions();;
		
		// generate network with 2 cliques, with separator of size 2. Network = E->[C,D]->F; junction tree = [CDE]-[CD]-[CDF]
		engine.addQuestion(transactionKey, new Date(), 0x0CL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0DL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0EL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0FL, 2, null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0CL, Collections.singletonList(0x0EL), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0DL, Collections.singletonList(0x0EL), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0FL, Collections.singletonList(0x0CL), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0FL, Collections.singletonList(0x0DL), null);
		
		// generate some trades, so that user has position in both cliques
		// trade which changes the position of clique CDE
		List<Long> assumptions = new ArrayList<Long>(2);
		assumptions.add(0x0CL);
		assumptions.add(0x0DL);
		List<Float> newValues = new ArrayList<Float>(4);
		newValues.add(.2f);
		newValues.add(.8f);
		newValues.add(.7f);
		newValues.add(.3f);
		newValues.add(.1f);
		newValues.add(.9f);
		newValues.add(.6f);
		newValues.add(.4f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"User 666 sets P(E|C,D) = [.2,.8,.7,.3,.1,.9,.6,.4]",  // this should be a string UUID, but I use as comment in test suites
				666L, 
				0x0EL, 
				newValues, 
				assumptions, null, // assumed question & unspecified state
				false);
		// trade which changes the position of clique CDF
		newValues = new ArrayList<Float>(4);
		newValues.add(.9f);
		newValues.add(.1f);
		newValues.add(.4f);
		newValues.add(.6f);
		newValues.add(.7f);
		newValues.add(.3f);
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(
				transactionKey, 
				new Date(), 
				"User 666 sets P(F|C,D) = [.9,.1,.4,.6,.7,.3,.8,.2]",  // this should be a string UUID, but I use as comment in test suites
				666L, 
				0x0FL, 
				newValues, 
				assumptions, null, // assumed question & unspecified state
				false);
		
		// finish the transaction
		engine.commitNetworkActions(transactionKey);
		
		
		// balance D, which belongs to separators.
		engine.doBalanceTrade(null, new Date(), "Balance D", 666L, 0x0DL, null, null);
		
		// make sure getAssetsIf is returning same values
		List<Float> assetsIfStates = engine.getAssetsIfStates(666L, 0x0DL, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// make sure getAssetsIf of cliques having E is balanced
		assumptions = new ArrayList<Long>(2);
		assumptions.add(0x0CL);
		assumptions.add(0x0EL);
		assetsIfStates = engine.getAssetsIfStates(666L, 0x0DL, assumptions, null);
		assertEquals(8, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		assertEquals(assetsIfStates.get(2), assetsIfStates.get(3), ASSET_ERROR_MARGIN);	
		assertEquals(assetsIfStates.get(4), assetsIfStates.get(5), ASSET_ERROR_MARGIN);
		assertEquals(assetsIfStates.get(6), assetsIfStates.get(7), ASSET_ERROR_MARGIN);
		// make sure getAssetsIf of cliques having F is balanced
		assumptions = new ArrayList<Long>(2);
		assumptions.add(0x0CL);
		assumptions.add(0x0FL);
		assetsIfStates = engine.getAssetsIfStates(666L, 0x0DL, assumptions, null);
		assertEquals(8, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);	
		assertEquals(assetsIfStates.get(2), assetsIfStates.get(3), ASSET_ERROR_MARGIN);	
		assertEquals(assetsIfStates.get(4), assetsIfStates.get(5), ASSET_ERROR_MARGIN);
		assertEquals(assetsIfStates.get(6), assetsIfStates.get(7), ASSET_ERROR_MARGIN);
		
		// make sure the cash is also the same for both outputs
		assetsIfStates = engine.getCashPerStates(666L, 0x0DL,  Collections.singletonList(0x0CL), Collections.singletonList(0));
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}

	
	/**
	 * Tests a situation in which ME resolves a question without removing the node
	 * from the system (i.e. there are zeros/infinites in the asset junction tree), 
	 * and then attempt to balance the question.
	 */
	public final void testResolveWithoutDeletingNodeAndThenBalance()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// set engine not to delete nodes when it resolves questions
		engine.setToDeleteResolvedNode(false);
		
		// make sure new users starts with 100 assets, and b=100 and base of log is 2
		engine.setDefaultInitialAssetTableValue(1000);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		
		/*
		 * Create following structure: F->D<- E
		 */
		engine.addQuestion(null, new Date(), 0x0DL, 2, null);
		engine.addQuestion(null, new Date(), 0x0EL, 2, null);
		engine.addQuestion(null, new Date(), 0x0FL, 2, null);
		engine.addQuestionAssumption(null, new Date(), 0x0DL, Collections.singletonList(0x0EL), null);
		engine.addQuestionAssumption(null, new Date(), 0x0DL, Collections.singletonList(0x0FL), null);
		// make sure the arcs were created correctly
		assertTrue(engine.getProbabilisticNetwork().getNode("13").getParents().contains(engine.getProbabilisticNetwork().getNode("14")));
		assertTrue(engine.getProbabilisticNetwork().getNode("13").getParents().contains(engine.getProbabilisticNetwork().getNode("15")));
		
		// new user adds trade on D|E
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(0.1f); newValues.add(0.9f);
		newValues.add(0.7f); newValues.add(0.3f);
		engine.addTrade(null, new Date(), "User 666, P(D|E)=[.1,.9,.7,.3]", 666L, 0x0DL, newValues, Collections.singletonList(0x0EL), null, false);
		
		// check conditional prob
		List<Float> probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0.1, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.9, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0.7, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.3, probList.get(1), PROB_ERROR_MARGIN);
		
		// new user adds another trade on D|F
		newValues.clear();
		newValues.add(0.6f); newValues.add(0.4f);
		newValues.add(0.8f); newValues.add(0.2f);
		engine.addTrade(null, new Date(), "User 666, P(D|F)=[.6,.4,.8,.2]", 666L, 0x0DL, newValues, Collections.singletonList(0x0FL), null, false);
		
		// check conditional prob
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0.6, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.4, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0.8, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2, probList.get(1), PROB_ERROR_MARGIN);
		
		// resolve one of the parents of D
		int resolvedStateE = (Math.random()<0.5)?0:1;
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(resolvedStateE));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(resolvedStateE));
		}

		engine.resolveQuestion(null, new Date(), 0x0EL, resolvedStateE);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check that E was resolved
		assertEquals(1, engine.getResolvedQuestions().size());
		assertTrue(engine.getResolvedQuestions().containsKey(0x0EL));
		probList = engine.getProbList(0x0EL, null, null);
		assertEquals(2, probList.size());
		assertEquals(1f, probList.get(resolvedStateE), PROB_ERROR_MARGIN);
		assertEquals(0f, probList.get(1-resolvedStateE), PROB_ERROR_MARGIN);
		
		// balance D
		assertTrue(engine.doBalanceTrade(null, new Date(), "666 balances D", 666L, 0x0DL, null, null));
		
		// check that asset ifs are equals
		List<Float> assetsIfStates = engine.getAssetsIfStates(666L, 0x0DL, null, null);
		assertEquals(2, assetsIfStates.size());
		assertEquals(assetsIfStates.get(0), assetsIfStates.get(1), ASSET_ERROR_MARGIN);
		
		// check that cash per state matches
		List<Float> cashPerStates = engine.getCashPerStates(666L, 0x0DL, null, null);
		assertEquals(2, cashPerStates.size());
		assertEquals(cashPerStates.get(0), cashPerStates.get(1), ASSET_ERROR_MARGIN);

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	

	/**
	 * This is a test case for {@link AssetAwareInferenceAlgorithm#calculateExpectedLocalAssets(Map)}
	 */
	public final void testDEFNetCalculateExpectedLocalAssets() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// set up to the default values used in daggre market
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setDefaultInitialAssetTableValue(1000f);
		engine.initialize();
		
		// create the DEF network with one disconnected nodes and one disconnected sub-net with 2 nodes
		long transactionKey = engine.startNetworkActions();
		engine.addQuestion(transactionKey, new Date(), 0x0DL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0EL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0FL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0AL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0BL, 2, null);
		engine.addQuestion(transactionKey, new Date(), 0x0CL, 2, null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0EL, Collections.singletonList(0x0DL), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0FL, Collections.singletonList(0x0DL), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0BL, Collections.singletonList(0x0AL), null);
		engine.commitNetworkActions(transactionKey);
		
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		newValues.add(.3f);
		newValues.add(.7f);
		engine.addTrade(
				null, 
				new Date(), 
				"User 1 bets P(E|D) = [.1, .9, .3, .7]", 
				1L, 
				0x0EL, 
				newValues, 
				Collections.singletonList(0x0DL), 
				null, 
				false
			);
		
		
		// assert that the expected assets of clique FD did not change by trading on E
		List<Float> evStates = engine.scoreUserQuestionEvStates(1L, 0x0FL, null, null, true);
		assertEquals(2, evStates.size());
		assertEquals(1000d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1000d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on E
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null, true);
		assertEquals(2, evStates.size());
		assertEquals(886.6794025d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1068.9372625d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on D
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, null, null, true);
		assertEquals(2, evStates.size());
		assertEquals(1053.10045d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1011.870931d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on D and E
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0), true);
		assertEquals(2, evStates.size());
		assertEquals(767.8072d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(926.30347d, evStates.get(1), ASSET_ERROR_MARGIN);
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1), true);
		assertEquals(2, evStates.size());
		assertEquals(1084.7997d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1048.5427d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on D and F (which did not change)
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0), true);
		assertEquals(2, evStates.size());
		assertEquals(1000d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1000d, evStates.get(1), ASSET_ERROR_MARGIN);
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1), true);
		assertEquals(2, evStates.size());
		assertEquals(1000d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1000d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test invalid conditions
		try {
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())), true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())), true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			List<Long> assumptions = new ArrayList<Long>();
			assumptions.add(0x0EL);
			assumptions.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add((int)Math.round(Math.random()));
			assumedStates.add((int)Math.round(Math.random()));
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, assumptions, assumedStates , true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			List<Long> assumptions = new ArrayList<Long>();
			assumptions.add(0x0DL);
			assumptions.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add((int)Math.round(Math.random()));
			assumedStates.add((int)Math.round(Math.random()));
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, assumptions, assumedStates , true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			List<Long> assumptions = new ArrayList<Long>();
			assumptions.add(0x0EL);
			assumptions.add(0x0DL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add((int)Math.round(Math.random()));
			assumedStates.add((int)Math.round(Math.random()));
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0FL, assumptions, assumedStates , true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		
		// Tom bets P(D|F) = [.9, .1, .3, .7]
		engine.addTrade(
				null, 
				new Date(), 
				"User 1 bets P(D|F) = [.1, .9, .3, .7]", 
				1L, 
				0x0DL, 
				newValues, 
				Collections.singletonList(0x0FL), 
				null, 
				false
			);
		
		// test conditioned on F
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0FL, null, null, true);
		assertEquals(2, evStates.size());
		assertEquals(1053.10045d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1011.870931d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on E
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null, true);
		assertEquals(2, evStates.size());
		assertEquals(914.1114492308d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1057.3619702703d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on D
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, null, null, true);
		assertEquals(2, evStates.size());
		assertEquals(939.7798525d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1080.8081935d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on D and E
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0), true);
		assertEquals(2, evStates.size());
		assertEquals(767.8072d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(926.30347d, evStates.get(1), ASSET_ERROR_MARGIN);
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1), true);
		assertEquals(2, evStates.size());
		assertEquals(1084.7997d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1048.5427d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test conditioned on D and F (which did not change)
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0), true);
		assertEquals(2, evStates.size());
		assertEquals(767.8072d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1084.7997d, evStates.get(1), ASSET_ERROR_MARGIN);
		evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1), true);
		assertEquals(2, evStates.size());
		assertEquals(926.30347d, evStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(1048.5427d, evStates.get(1), ASSET_ERROR_MARGIN);
		
		// test invalid conditions
		try {
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())), true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())), true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			List<Long> assumptions = new ArrayList<Long>();
			assumptions.add(0x0EL);
			assumptions.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add((int)Math.round(Math.random()));
			assumedStates.add((int)Math.round(Math.random()));
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0DL, assumptions, assumedStates , true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			List<Long> assumptions = new ArrayList<Long>();
			assumptions.add(0x0DL);
			assumptions.add(0x0FL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add((int)Math.round(Math.random()));
			assumedStates.add((int)Math.round(Math.random()));
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0EL, assumptions, assumedStates , true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		try {
			List<Long> assumptions = new ArrayList<Long>();
			assumptions.add(0x0EL);
			assumptions.add(0x0DL);
			List<Integer> assumedStates = new ArrayList<Integer>();
			assumedStates.add((int)Math.round(Math.random()));
			assumedStates.add((int)Math.round(Math.random()));
			evStates = engine.scoreUserQuestionEvStates(1L, 0x0FL, assumptions, assumedStates , true);
			fail();
		} catch (IllegalArgumentException e) {
			assertNotNull(e);
			// OK
		}
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);

	}
	
	
	
	

	
	/**
	 * Tests the lazy creation of users (create users
	 * only on first edit)
	 */
	public final void testLazyUserCreation()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// force engine to lazy init users
		engine.setToLazyInitializeUsers(true);
		
		// decide what will be the initial assets of every user
		float initialAssets = (float) (100+Math.random()*1000);
		
		// decide what will be the manna
		float manna = (float) (100+Math.random()*1000);
		
		// set the initial assets of users to the generated value
		engine.setDefaultInitialAssetTableValue(initialAssets);
		
		/*
		 * Create following structure: F<-D->E
		 */
		engine.addQuestion(null, new Date(), 0x0DL, 2, null);
		engine.addQuestion(null, new Date(), 0x0EL, 2, null);
		engine.addQuestion(null, new Date(), 0x0FL, 2, null);
		engine.addQuestionAssumption(null, new Date(), 0x0EL, Collections.singletonList(0x0DL), null);
		engine.addQuestionAssumption(null, new Date(), 0x0FL, Collections.singletonList(0x0DL), null);
		// make sure the arcs were created correctly
		assertTrue(engine.getProbabilisticNetwork().getNode("14").getParents().contains(engine.getProbabilisticNetwork().getNode("13")));
		assertTrue(engine.getProbabilisticNetwork().getNode("15").getParents().contains(engine.getProbabilisticNetwork().getNode("13")));
		
		// assert that user is not created yet
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L));
		
		// call methods that will not create user.
		List<Float> returnedValues = engine.getAssetsIfStates(1L, 0x0DL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0EL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0FL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		
		returnedValues = engine.getCashPerStates(1L, 0x0DL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0EL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0FL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, null, null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, null, null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets, asset);
		}
		
		// preview trade shall return OK for uninitialized users
		
		// generate a random trade
		
		List<Float> newValues = new ArrayList<Float>();
		newValues.add((float) Math.random());
		newValues.add(1-newValues.get(0));
		
		// pick question to trade
		long questionId = (Math.random()<.34)?0x0DL:(Math.random()<.5)?0x0EL:0x0FL;
		
		// generate random assumption
		List<Long> assumptionIds = new ArrayList<Long>();
		if (questionId == 0x0DL) {
			if (Math.random() < .5) {
				// eventually add E or F as asssumption
				assumptionIds.add((Math.random() < .5)?0x0EL:0x0FL);
			} // else, do not add assumption
		} else {
			// this is either E or F, so the only possible assumption is D
			if (Math.random() < .5) {
				assumptionIds.add(0x0DL);
			} // else, do not add assumption
		}
		
		// randomly set assumed states
		List<Integer> assumedStates = new ArrayList<Integer>();
		for (int i = 0; i < assumptionIds.size(); i++) {
			assumedStates.add((int) Math.round(Math.random()));
		}
		
		// eventually test null assumption
		if (assumptionIds.isEmpty() && Math.random() < .5) {
			assumptionIds = null;
			assumedStates = null;
		}
		

		// make sure the calculation of edit limits is OK.
		List<Float> probList = engine.getEditLimits(1L, questionId, (int) Math.round(Math.random()), assumptionIds, assumedStates);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, probList.size());
		assertTrue(Math.abs(probList.get(0) - probList.get(1)) > PROB_ERROR_MARGIN); // this fails if cash == 0
		
		
		// get old probability, in order to calculate the ratio
		probList = engine.getProbList(questionId, assumptionIds, assumedStates);
		
		// preview the trade
		returnedValues = engine.previewTrade(1L, questionId, newValues, assumptionIds, assumedStates);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		assertEquals(initialAssets + engine.getScoreFromQValues(newValues.get(0)/probList.get(0)), returnedValues.get(0), ASSET_ERROR_MARGIN);
		assertEquals(initialAssets + engine.getScoreFromQValues(newValues.get(1)/probList.get(1)), returnedValues.get(1), ASSET_ERROR_MARGIN);
		
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0DL, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0EL, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0FL, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0DL, Collections.singletonList(0x0EL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0DL, Collections.singletonList(0x0FL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0EL, Collections.singletonList(0x0DL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserQuestionEv(1L, 0x0FL, Collections.singletonList(0x0DL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		// the following methods were supposedly called by the above methods, so test only random combinations
		
		assertEquals(initialAssets, engine.getCash(1L, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		assumptionIds = new ArrayList<Long>(3);
		if (Math.random() < .5) { assumptionIds.add(0x0DL); }
		if (Math.random() < .5) { assumptionIds.add(0x0EL); }
		if (Math.random() < .5) { assumptionIds.add(0x0FL); }
		assumedStates = new ArrayList<Integer>();
		for (int i = 0; i < assumptionIds.size(); i++) {
			assumedStates.add((int) Math.round(Math.random()));
		}
		assertEquals(initialAssets, engine.getCash(1L, assumptionIds, assumedStates));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets, engine.scoreUserEv(1L, assumptionIds, assumedStates));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		// a previewBalancingTrade (singular) with uninitialized user should return a trade which does not change anything.
		
		List<Float> balancingTrade = engine.previewBalancingTrade(1L, 0x0DL, null, null);
		probList = engine.getProbList(0x0DL, null, null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0EL, null, null);
		probList = engine.getProbList(0x0EL, null, null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0FL, null, null);
		probList = engine.getProbList(0x0FL, null, null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created

		balancingTrade = engine.previewBalancingTrade(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		// assert that user is not created by balancing a trade which is balanced already
		int sizeOfHistory = engine.getExecutedActions().size();
		if (assumptionIds.remove(questionId)){ // make sure assumptionIds does not contain questionId
			assumedStates.remove(0);  // make sure the size of the 2 lists remains the same
		}
		engine.doBalanceTrade(null, new Date(), "User 1 balances " + questionId + " | " + assumptionIds + "=" + assumedStates, 
				1L, questionId, assumptionIds, assumedStates);
		// check that nothing was done
		assertEquals(sizeOfHistory, engine.getExecutedActions().size());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		
		/************************************************************************************************************/
		
		// add cash to user
		engine.addCash(null, new Date(), 1L, manna, "Added cash " + manna + " to user 1");
		
		
		/************************************************************************************************************/
		
		
		// call methods that will not create user again and check that values were modified.
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0EL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0FL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getAssetsIfStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		
		returnedValues = engine.getCashPerStates(1L, 0x0DL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0EL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0FL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.getCashPerStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, null, null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, null, null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, null, null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, null, null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), null, (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(4, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0DL, Collections.singletonList(0x0FL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		returnedValues = engine.scoreUserQuestionEvStates(1L, 0x0FL, Collections.singletonList(0x0DL), Collections.singletonList((int)Math.round(Math.random())), (Math.random()<.5));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		for (Float asset : returnedValues) {
			assertEquals(initialAssets + manna, asset);
		}
		
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0DL, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0EL, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0FL, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0DL, Collections.singletonList(0x0EL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0DL, Collections.singletonList(0x0FL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0EL, Collections.singletonList(0x0DL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserQuestionEv(1L, 0x0FL, Collections.singletonList(0x0DL), null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		assertTrue(engine.previewBalancingTrades(1L, 0x0DL, null, null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertTrue(engine.previewBalancingTrades(1L, 0x0EL, null, null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertTrue(engine.previewBalancingTrades(1L, 0x0FL, null, null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertTrue(engine.previewBalancingTrades(1L, 0x0DL, Collections.singletonList(0x0EL), null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertTrue(engine.previewBalancingTrades(1L, 0x0DL, Collections.singletonList(0x0FL), null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertTrue(engine.previewBalancingTrades(1L, 0x0EL, Collections.singletonList(0x0DL), null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertTrue(engine.previewBalancingTrades(1L, 0x0FL, Collections.singletonList(0x0DL), null).isEmpty());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		// a previewBalancingTrade (singular) with uninitialized user should return a trade which does not change anything, even after cash was added.
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0DL, null, null);
		probList = engine.getProbList(0x0DL, null, null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0EL, null, null);
		probList = engine.getProbList(0x0EL, null, null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0FL, null, null);
		probList = engine.getProbList(0x0FL, null, null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created

		balancingTrade = engine.previewBalancingTrade(1L, 0x0DL, Collections.singletonList(0x0EL), null);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0DL, Collections.singletonList(0x0FL), null);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0FL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0EL, Collections.singletonList(0x0DL), null);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		balancingTrade = engine.previewBalancingTrade(1L, 0x0FL, Collections.singletonList(0x0DL), null);
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0DL), null);
		assertEquals(probList.size(), balancingTrade.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probList.get(i), balancingTrade.get(i), PROB_ERROR_MARGIN);
		}
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		
		// the following methods were supposedly called by the above methods, so test only random combinations
		
		assertEquals(initialAssets + manna, engine.getCash(1L, null, null));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		assumptionIds = new ArrayList<Long>(3);
		if (Math.random() < .5) { assumptionIds.add(0x0DL); }
		if (Math.random() < .5) { assumptionIds.add(0x0EL); }
		if (Math.random() < .5) { assumptionIds.add(0x0FL); }
		assumedStates = new ArrayList<Integer>();
		for (int i = 0; i < assumptionIds.size(); i++) {
			assumedStates.add((int) Math.round(Math.random()));
		}
		assertEquals(initialAssets + manna, engine.getCash(1L, assumptionIds, assumedStates));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(initialAssets + manna, engine.scoreUserEv(1L, assumptionIds, assumedStates));
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		// preview trade shall return OK for uninitialized users, after adding cash
		// generate a random trade
		newValues = new ArrayList<Float>();
		newValues.add((float) Math.random());
		newValues.add(1-newValues.get(0));
		
		// pick question to trade
		questionId = (Math.random()<.34)?0x0DL:(Math.random()<.5)?0x0EL:0x0FL;
		
		// generate random assumption
		assumptionIds = new ArrayList<Long>();
		if (questionId == 0x0DL) {
			if (Math.random() < .5) {
				// eventually add E or F as asssumption
				assumptionIds.add((Math.random() < .5)?0x0EL:0x0FL);
			} // else, do not add assumption
		} else {
			// this is either E or F, so the only possible assumption is D
			if (Math.random() < .5) {
				assumptionIds.add(0x0DL);
			} // else, do not add assumption
		}
		
		// randomly set assumed states
		assumedStates = new ArrayList<Integer>();
		for (int i = 0; i < assumptionIds.size(); i++) {
			assumedStates.add((int) Math.round(Math.random()));
		}
		
		// eventually test null assumption
		if (assumptionIds.isEmpty() && Math.random() < .5) {
			assumptionIds = null;
			assumedStates = null;
		}
		// get old probability, in order to calculate the ratio
		probList = engine.getProbList(questionId, assumptionIds, assumedStates);
		
		// preview the trade
		returnedValues = engine.previewTrade(1L, questionId, newValues, assumptionIds, assumedStates);
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		assertEquals(2, returnedValues.size());
		assertEquals(initialAssets + manna + engine.getScoreFromQValues(newValues.get(0)/probList.get(0)), returnedValues.get(0), ASSET_ERROR_MARGIN);
		assertEquals(initialAssets + manna + engine.getScoreFromQValues(newValues.get(1)/probList.get(1)), returnedValues.get(1), ASSET_ERROR_MARGIN);
		
		// assert that user is not created by balancing a trade which is balanced already
		sizeOfHistory = engine.getExecutedActions().size();
		engine.doBalanceTrade(null, new Date(), "User 1 balances " + questionId + " | " + assumptionIds + "=" + assumedStates, 
				1L, questionId, assumptionIds, assumedStates);
		// check that nothing was done
		assertEquals(sizeOfHistory, engine.getExecutedActions().size());
		assertNull(engine.getUserToAssetAwareAlgorithmMap().get(1L)); // assert that user was not created
		
		/******************************************************************************************************************/
		
		questionId = ((Math.random()<.34)?0x0DL:(Math.random()<.5)?0x0EL:0x0FL);
		if (assumptionIds != null && assumptionIds.remove(questionId)){ // make sure assumptionIds does not contain questionId
			assumedStates.remove(0);  // make sure the size of the 2 lists remains the same
		}
		
		// assert that user is created by adding a trade
		engine.addTrade(
				null, new Date(), "Trade of user 1", 
				1L,  questionId, 
				newValues,  assumptionIds, assumedStates,  false);
		assertNotNull(engine.getUserToAssetAwareAlgorithmMap().get(1L));
		assertNotNull(engine.getUserToAssetAwareAlgorithmMap().get(1L));
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Check a condition which a trade should not update history
	 */
	public final void testHistoryOfCancelledTrades()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		
		engine.setDefaultInitialAssetTableValue(100);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setToForceBalanceQuestionEntirely(false);
		engine.initialize();
		
		// create DEF net
		engine.addQuestion(null, new Date(), 0x0DL, 2, null);
		engine.addQuestion(null, new Date(), 0x0EL, 2, null);
		engine.addQuestion(null, new Date(), 0x0FL, 2, null);
		engine.addQuestionAssumption(null, new Date(), 0x0EL, Collections.singletonList(0x0DL), null);
		engine.addQuestionAssumption(null, new Date(), 0x0FL, Collections.singletonList(0x0DL), null);
		
		// set clique potential of clique FD to [0.126	0.374	0.25	0.25], so that the cash does depend heavily on clique FD instead of ED
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(.252f); newValues.add(.748f);
		engine.addTrade(null, new Date(), "User 1 sets P(F|d1)=[0.252,0.748]", 1, 0x0FL, newValues, 
				Collections.singletonList(0x0DL), Collections.singletonList(0), false);
		
		// make sure cash depends on F and D and does not change on E
		List<Float> cashPerStates = engine.getCashPerStates(1, 0x0FL, null, null);
		assertEquals(2, cashPerStates.size());
		assertEquals(cashPerStates.toString(), 1.1495638838f, cashPerStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(cashPerStates.toString(), 100f, cashPerStates.get(1), ASSET_ERROR_MARGIN);
		cashPerStates = engine.getCashPerStates(1, 0x0DL, null, null);
		assertEquals(2, cashPerStates.size());
		assertEquals(cashPerStates.toString(), 1.1495638838f, cashPerStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(cashPerStates.toString(), 100f, cashPerStates.get(1), ASSET_ERROR_MARGIN);
		cashPerStates = engine.getCashPerStates(1, 0x0EL, null, null);
		assertEquals(2, cashPerStates.size());
		assertEquals(cashPerStates.toString(), 1.1495638838f, cashPerStates.get(0), ASSET_ERROR_MARGIN);
		assertEquals(cashPerStates.toString(),  1.1495638838f, cashPerStates.get(1), ASSET_ERROR_MARGIN);
		
		// make sure the history did only change the marginal of F
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(1, questionHistory.size());
		assertTrue(questionHistory.get(0) instanceof AddTradeNetworkAction);
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		assertEquals(0, questionHistory.size());
		questionHistory = engine.getQuestionHistory(0x0EL, null, null);
		assertEquals(0, questionHistory.size());
		
		// make a trade that will make the cash (global min asset) to go negative, but the local assets is still positive
		
		try {
			// Changing P(E|d1) to [.4,.6] shall do the work
			newValues = new ArrayList<Float>(2);
			newValues.add(.4f); newValues.add(.6f);
			engine.addTrade(null, new Date(), "User 1 sets P(E|d1)=[0.4,0.6]", 1, 0x0EL, newValues, 
					Collections.singletonList(0x0DL), Collections.singletonList(0), false);
			fail("Shall throw exception indicating that cash went to negative");
		} catch (ZeroAssetsException e) {
			// OK
		}
		
		// make sure the history did not change
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(1, questionHistory.size());
		assertTrue(questionHistory.get(0) instanceof AddTradeNetworkAction);
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		assertEquals(0, questionHistory.size());
		questionHistory = engine.getQuestionHistory(0x0EL, null, null);
		assertEquals(0, questionHistory.size());
		
		// now, add cash to user, so that user can do the trade
		engine.addCash(null, new Date(), 1, 50, "Added 50 to user 1");
		
		// Changing P(E|d1) to [.4,.6] shall do the work
		newValues = new ArrayList<Float>(2);
		newValues.add(.4f); newValues.add(.6f);
		engine.addTrade(null, new Date(), "User 1 sets P(E|d1)=[0.4,0.6]", 1, 0x0EL, newValues, 
				Collections.singletonList(0x0DL), Collections.singletonList(0), false);
		
		// make sure the history did change the marginal of E
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(1, questionHistory.size());
		assertTrue(questionHistory.get(0) instanceof AddTradeNetworkAction);
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		assertEquals(0, questionHistory.size());
		questionHistory = engine.getQuestionHistory(0x0EL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(1, questionHistory.size());
		
		try {
			// Make a change in E which should change F indirectly, but will be cancelled due to cash
			newValues = new ArrayList<Float>(2);
			newValues.add(.9f); newValues.add(.1f);
			engine.addTrade(null, new Date(), "User 1 sets P(E)=[0.9,0.1]", 1, 0x0EL, newValues, 
					null, null, false);
			fail("Shall throw exception indicating that cash went to negative");
		} catch (ZeroAssetsException e) {
			// OK
		}
		// make sure the history did not change
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(1, questionHistory.size());
		assertTrue(questionHistory.get(0) instanceof AddTradeNetworkAction);
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		assertEquals(0, questionHistory.size());
		questionHistory = engine.getQuestionHistory(0x0EL, null, null);
		assertEquals(1, questionHistory.size());
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(0));
		}

		engine.resolveQuestion(null, new Date(), 0x0EL, 0);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// make sure the history did change for all questions
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertEquals(2, questionHistory.size());
		assertTrue(questionHistory.get(questionHistory.size()-1) instanceof DummyTradeAction);
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		assertEquals(1, questionHistory.size());
		for (QuestionEvent questionEvent : questionHistory) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionEvent.getUserId());
			}
		}
		assertTrue(questionHistory.get(questionHistory.size()-1) instanceof DummyTradeAction);
//		questionHistory = engine.getQuestionHistory(0x0EL, null, null);
//		assertEquals(2, questionHistory.size());
		
		

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Test method for {@link MarkovEngineImpl#getParentCliqueIndexes()}
	 */
	public final void testGetParentCliqueIndexes()  {
		
		// load network from file
		NetIO io = new NetIO();
		ProbabilisticNetwork network = null;
		try {
			network = (ProbabilisticNetwork) io.load(new File(getClass().getClassLoader().getResource("bn20_tw5_max41_bn20_tw10_max31.net").getFile()));
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		} 
		assertNotNull(network);
		
		engine.initialize();
		
		long transactionKey = engine.startNetworkActions();
		// create nodes
		for (Node node : network.getNodes()) {
			engine.addQuestion(transactionKey, new Date(), Long.parseLong(node.getName()), node.getStatesSize(), null); // assume uniform distribution for all nodes 
		}
		// create edges 
		for (Node node : network.getNodes()) {
			List<Long> parentIds = new ArrayList<Long>();
			for (Node parent : node.getParents()) {
				parentIds.add(Long.parseLong(parent.getName()));
			}
			if (parentIds.isEmpty()) {
				parentIds = null;
			}
			engine.addQuestionAssumption(transactionKey, new Date(), Long.parseLong(node.getName()), parentIds, null);	// cpd == null -> linear distro
		}
		// commit changes
		engine.commitNetworkActions(transactionKey);
		
		
		List<Integer> parentCliqueIndexes = engine.getParentCliqueIndexes();
		List<List<Long>> questionAssumptionGroups = engine.getQuestionAssumptionGroups();
		
		assertEquals(parentCliqueIndexes.size(), questionAssumptionGroups.size());
		
		network = engine.getProbabilisticNetwork();
		
		// since we do not have empty cliques, the sizes should match.
		assertEquals(parentCliqueIndexes.size(), network.getJunctionTree().getCliques().size());
		
		
		int index = 0;
		for (Clique clique : network.getJunctionTree().getCliques()) {
			// extract the values to test
			Integer parentIndex = parentCliqueIndexes.get(index);
			assertNotNull(parentIndex);
			List<Long> cliqueNodeIds = questionAssumptionGroups.get(index);
			assertNotNull(cliqueNodeIds);
			assertFalse(cliqueNodeIds.isEmpty());
			index++;
			
			// check that the current clique (cliqueNodeIds) is the correct
			assertEquals(cliqueNodeIds.size(), clique.getNodes().size());	// check that they have the same size
			for (Node node : clique.getNodes()) {
				// check that cliqueNodeIds contains ids of all nodes in the clique
				assertTrue(clique + ", node = " + node, cliqueNodeIds.contains(Long.parseLong(node.getName())));
			}
			
			// check that the parent is OK
			if (parentIndex < 0) {
				// this clique should be a root
				assertNull(clique.getParent());
			} else {
				Clique parentClique = network.getJunctionTree().getCliques().get(parentIndex);
				assertEquals(parentClique, clique.getParent());
			}
		}
		
	}
	
	/**
	 * Test method for {@link MarkovEngineImpl#getNetStatistics()}
	 */
	public final void testGetNetStatistics()  {
		// generate the DEF net
		this.createDEFNetIn1Transaction(new HashMap<String, Long>());
		
		// extract the statistics
		NetStatistics statistics = engine.getNetStatistics();
		assertNotNull(statistics);
		
		// test the numeric statistics
		assertEquals(5, statistics.getDegreeOfFreedom());
		assertEquals(4, statistics.getMaxCliqueTableSize());
		assertEquals(1, statistics.getMaxNumParents());
		assertEquals(2, statistics.getNumberOfCliques());
		assertEquals(2, statistics.getNumberOfNonEmptyCliques());
		assertEquals(1, statistics.getNumberOfSeparators());
		assertEquals(10, statistics.getSumOfCliqueAndSeparatorTableSizes());
		assertEquals(10, statistics.getSumOfCliqueAndSeparatorTableSizesWithoutResolvedCliques());
		assertEquals(8, statistics.getSumOfCliqueTableSizes());
		assertEquals(8, statistics.getSumOfCliqueTableSizesWithoutResolvedCliques());
		
		// test the mapping
		Map<Integer, Integer> map = statistics.getNumberOfStatesToNumberOfNodesMap();
		assertNotNull(map);
		assertEquals(1, map.size());
		assertEquals(2, (int) map.keySet().iterator().next());
		assertEquals(3, (int) map.get(2));
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0DL, null, null).get(0));
		}

		// do the same test after resolving D (which is the separator)
		engine.resolveQuestion(null, new Date(), 0x0DL, 0);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// extract the statistics
		statistics = engine.getNetStatistics();
		assertNotNull(statistics);
		
		// test the numeric statistics
		assertEquals(2, statistics.getDegreeOfFreedom());
		assertEquals(2, statistics.getMaxCliqueTableSize());
		assertEquals(0, statistics.getMaxNumParents());
		assertEquals(2, statistics.getNumberOfCliques());
		assertEquals(2, statistics.getNumberOfNonEmptyCliques());
		assertEquals(1, statistics.getNumberOfSeparators());
		assertEquals(4, statistics.getSumOfCliqueAndSeparatorTableSizes());
		assertEquals(4, statistics.getSumOfCliqueAndSeparatorTableSizesWithoutResolvedCliques());
		assertEquals(4, statistics.getSumOfCliqueTableSizes());
		assertEquals(4, statistics.getSumOfCliqueTableSizesWithoutResolvedCliques());
		
		// test the mapping
		map = statistics.getNumberOfStatesToNumberOfNodesMap();
		assertNotNull(map);
		assertEquals(1, map.size());
		assertEquals(2, (int) map.keySet().iterator().next());
		assertEquals(2, (int) map.get(2));
		
	}
	
	/**
	 * {@link MarkovEngineImpl#previewBalancingTrades(long, long, List, List)} shall return
	 * trades that do not consider all combination of parents whenever possible.
	 */
	public final void testIntegratedPreviewBalanceTrade()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// set up default configuration
		engine.setDefaultInitialAssetTableValue(1000);
		engine.setCurrentCurrencyConstant(200);
		engine.setCurrentLogBase(2);
		engine.setToForceBalanceQuestionEntirely(false);
		
		/*
		 * Create the following structure
		 * 
		 * {1,2,3}->0->4
		 * 3 states each node		
		 */
		engine.addQuestion(null, new Date(), 0, 3, null);
		engine.addQuestion(null, new Date(), 1, 3, null);
		engine.addQuestion(null, new Date(), 2, 3, null);
		engine.addQuestion(null, new Date(), 3, 3, null);
		engine.addQuestion(null, new Date(), 4, 3, null);
		engine.addQuestionAssumption(null, new Date(), 0L, Collections.singletonList(1L), null);
		engine.addQuestionAssumption(null, new Date(), 0L, Collections.singletonList(2L), null);
		engine.addQuestionAssumption(null, new Date(), 0L, Collections.singletonList(3L), null);
		engine.addQuestionAssumption(null, new Date(), 4L, Collections.singletonList(0L), null);
		
		
		// {0,1,2,3} are in the same clique, and 4 is in separate clique
		
		// make trade on 0 with incomplete assumptions (i.e. assumptions are not all 3 parents simultaneously)
		List<Long> assumptionIds = new ArrayList<Long>(2);
		List<Integer> assumedStates = new ArrayList<Integer>(2);
		assumptionIds.add(2L);	assumedStates.add(0);
		// trade is [.2,.2,.6]
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.1f); newValues.add(.1f); newValues.add(.8f);
		
		// execute the trade
		engine.addTrade(null, new Date(), "User 0 trades P(0|2=0) = [.1,.1,.8]", 
				0, 0L, newValues, assumptionIds, assumedStates, false);
		
		// set up another trade, which is more restricted than the previous trade
		// change assumption to 1=1,2=0
		assumptionIds.add(1L);	assumedStates.add(1);
		// trade is [.7,.1,.2]
		newValues = new ArrayList<Float>();
		newValues.add(.9f); newValues.add(.05f); newValues.add(.05f);
		// execute the trade
		engine.addTrade(null, new Date(), "User 0 trades P(0|1=1,2=0) = [.9,.05,.05]", 
				0, 0L, newValues, assumptionIds, assumedStates, false);
		
		// preview the balancing trade for the question
		List<TradeSpecification> balancingTrades = engine.previewBalancingTrades(0, 0L, null, null);
		
		engine.doBalanceTrade(null, new Date(), "User 0 balances 0", 0, 0, null, null);
		BalanceTradeNetworkAction networkAction = (BalanceTradeNetworkAction) engine.getExecutedActions().get(engine.getExecutedActions().size()-1);
		
		assertEquals(balancingTrades.size(), networkAction.getExecutedTrades().size());
		for (int i = 0; i < balancingTrades.size(); i++) {
			assertEquals(balancingTrades.get(i).getQuestionId(), networkAction.getExecutedTrades().get(i).getQuestionId());
			assertEquals(balancingTrades.get(i).getUserId(), networkAction.getExecutedTrades().get(i).getUserId());
			for (int j = 0; j < balancingTrades.get(i).getAssumptionIds().size(); j++) {
				assertEquals(balancingTrades.get(i).getAssumptionIds().get(j), networkAction.getExecutedTrades().get(i).getAssumptionIds().get(j));
			}
			for (int j = 0; j < balancingTrades.get(i).getAssumedStates().size(); j++) {
				assertEquals(balancingTrades.get(i).getAssumedStates().get(j), networkAction.getExecutedTrades().get(i).getAssumedStates().get(j));
			}
			for (int j = 0; j < balancingTrades.get(i).getProbabilities().size(); j++) {
				assertEquals(balancingTrades.get(i).getProbabilities().get(j), networkAction.getExecutedTrades().get(i).getProbabilities().get(j), PROB_ERROR_MARGIN);
			}
		}
		
		if (engine.isToCollapseSimilarBalancingTrades()) {
			assertEquals(3, balancingTrades.size());
		} else {
			assertEquals(9, balancingTrades.size());
		}
			
		
		// check if the assets have been equalized
		// prepare the list of assumptions
		List<Long> assumptions = new ArrayList<Long>(3);
		assumptions.add(1L);
		assumptions.add(2L);
		assumptions.add(3L);
		List<Float> assetsIfStates = engine.getAssetsIfStates(0L, 0L, assumptions , null);
		assertEquals(81, assetsIfStates.size());
		for (int i = 0; i < assetsIfStates.size()-1; i++) {
			assertEquals("Index " + i + " of " + assetsIfStates, assetsIfStates.get(i), assetsIfStates.get(i+1), ASSET_ERROR_MARGIN);
		}
		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * This is a test method for trades being corrected when
	 * {@link MarkovEngineInterface#setToUseCorrectiveTrades(boolean)}
	 * is set to true.
	 * Trades will be executed in a single transaction
	 */
	public final void testCorrectiveTradeSingleTransaction()  {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		assertTrue(engine.isToUseCorrectiveTrades());
		
		engine.setDefaultInitialAssetTableValue(0f);
		
		// crate transaction
		long transactionKey = engine.startNetworkActions();
		
		// create nodes D, E, F
		engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
		engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
		// create edge D->E 
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
		// create edge D->F
		engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro

		// this is a nameless user created just to adjust probabilities
		assertTrue(engine.addCash(transactionKey, new Date(), Long.MIN_VALUE, engine.getScoreFromQValues(2000f), "Initialize John Doe's asset to 2000"));
		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		List<Float> newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"John Doe bets P(E=e1|D=d1) = 0.9", 
				Long.MIN_VALUE, 
				0x0E, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());
		

		// this is a mapping from user name to user ID
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		List<Float> oldValues = new ArrayList<Float>();
		oldValues.add(.55f);
		oldValues.add(.45f);
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(E=e1|D=d2) = .55 -> .4", 
				userNameToIDMap.get("Joe"), 
				0x0E, 
				oldValues,
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		// John Doe bets P(F=f1|D=d1) = .5 -> .3
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"John Doe bets P(F=f1|D=d1) = 0.3", 
				Long.MIN_VALUE, 
				0x0F, 
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(0), 
				false
			).isEmpty());

		// Joe bets P(F=f1|D=d2) = .5 -> .1
		oldValues = new ArrayList<Float>();
		oldValues.add(.5f);
		oldValues.add(.5f);
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Joe bets P(F=f1|D=d2) = .1", 
				userNameToIDMap.get("Joe"), 
				0x0F, 
				//oldValues,
				newValues, 
				Collections.singletonList((long)0x0D), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		
		// create new user Eric
		userNameToIDMap.put("Eric", (long) -666);
		
		// add 100 q-values to new users
		assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
		
		// Eric bets P(E=e1) = .65 -> .8
		oldValues = new ArrayList<Float>();
		oldValues.add(.65f);
		oldValues.add(1f-.65f);
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(E=e1) = .8", 
				userNameToIDMap.get("Eric"), 
				0x0E, 
//				oldValues,
				newValues, 
				(List)Collections.emptyList(), 
				(List)Collections.emptyList(), 
				false
			).isEmpty());
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		oldValues = new ArrayList<Float>();
		oldValues.add(.52f);
		oldValues.add(1f-.52f);
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		assertTrue( engine.addTrade(
				transactionKey, 
				new Date(), 
				"Eric bets P(D=d1|F=f2) = 0.52 -> 0.7", 
				userNameToIDMap.get("Eric"), 
				0x0D, 
				oldValues,
				newValues, 
				Collections.singletonList((long)0x0F), 
				Collections.singletonList(1), 
				false
			).isEmpty());
		
		// commit all trades (including the creation of network and user)
		engine.commitNetworkActions(transactionKey);
		
		// test consistency of history when corrective trades are present
		
		// there should be 1 corrective trade for E at position 1
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0EL, null, null);
		assertEquals(5, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			if (i == 1) {
				assertTrue(questionHistory.get(i).isCorrectiveTrade());
			} else {
				assertFalse(questionHistory.get(i).isCorrectiveTrade());
			}
		}
		// there should be 1 corrective trade for P(E|D=d2) at position 1
		questionHistory = engine.getQuestionHistory(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(4, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0EL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			if (i == 1) {
				assertTrue(questionHistory.get(i).isCorrectiveTrade());
			} else {
				assertFalse(questionHistory.get(i).isCorrectiveTrade());
			}
		}
		
		// no corrective trade for marginal of D
		questionHistory = engine.getQuestionHistory(0x0DL, null, null);
		assertEquals(2, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			assertFalse(questionHistory.get(i).isCorrectiveTrade());
		}
		
		// because there is 1 corrective trade for P(E|D=d2) at position 1, there should be a reciprocal for P(D|E=e1) at position 1
		questionHistory = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(4, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			if (i == 1) {
				assertTrue(questionHistory.get(i).isCorrectiveTrade());
			} else {
				assertFalse(questionHistory.get(i).isCorrectiveTrade());
			}
		}
		// because there is 1 corrective trade for P(E|D=d2) at position 1, there should be a reciprocal for P(D|E=e2) at position 1
		questionHistory = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(4, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			if (i == 1) {
				assertTrue(questionHistory.get(i).isCorrectiveTrade());
			} else {
				assertFalse(questionHistory.get(i).isCorrectiveTrade());
			}
		}
		// no corrective trade for D given F
		questionHistory = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(3, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			assertFalse(questionHistory.get(i).isCorrectiveTrade());
		}
		questionHistory = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(4, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0DL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			assertFalse(questionHistory.get(i).isCorrectiveTrade());
		}
		
		
		// no corrective trade for F
		questionHistory = engine.getQuestionHistory(0x0FL, null, null);
		assertEquals(3, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			assertFalse(questionHistory.get(i).isCorrectiveTrade());
		}
		
		// no corrective trade for F conditioned to D
		questionHistory = engine.getQuestionHistory(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(2, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			assertFalse(questionHistory.get(i).isCorrectiveTrade());
		}
		questionHistory = engine.getQuestionHistory(0x0FL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(3, questionHistory.size());
		for (int i = 0; i < questionHistory.size(); i++) {
			if (!(questionHistory.get(i) instanceof StructureChangeNetworkAction)
					&& !(questionHistory.get(i).getQuestionId().longValue() != 0x0FL)) {
				assertNotNull(questionHistory.get(i).getUserId());
			}
			assertFalse(questionHistory.get(i).isCorrectiveTrade());
		}
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		List<Float> probList = engine.getProbList(0x0D, null, null);
		assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0E, null, null);
		assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0F, null, null);
		assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		ArrayList<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		ArrayList<Integer> assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		
		// check that min-q of Joe is 14.5454545...
		float minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
		assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		float cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check that final min-q of Eric is 35.7393...
		minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
		assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
		assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertTrue("Obtained cash = " + cash, minCash < cash);
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
		assertEquals(minCash, cash, ASSET_ERROR_MARGIN);

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * This method checks whether the {@link RebuildNetworkAction#execute()} is 
	 * correctly using {@link RebuildNetworkAction#addActionIntoSetOfQuestionsToFullyConnect(Set, NetworkAction)}
	 * in order to fully connect questions which were once traded 
	 * (i.e. connect the traded questions with their assumptions and also the assumptions each other,
	 * in order to guarantee clique stability).
	 */
	public final void testCliqueStability() {
		
		// backup old config
		boolean backup = engine.isToFullyConnectNodesInCliquesOnRebuild();
		// make sure the feature is on
		engine.setToFullyConnectNodesInCliquesOnRebuild(true);
		
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setDefaultInitialAssetTableValue(1000);
		
		// Very simple case: 1 -> 0 <- 2
		engine.addQuestion(null, new Date(), 1L, 3, null);		// node 1 will have only 3 states, because it will be used in trades
		// other nodes will have from 2 to 7 states
		engine.addQuestion(null, new Date(), 0L, 2+(int)Math.round(Math.random()*5), null);		
		int numStatesOfQuestion2 = 2+(int)Math.round(Math.random()*5);	// store how many states question 2 has, because it will be used in trades
		engine.addQuestion(null, new Date(), 2L, numStatesOfQuestion2, null);		
		engine.addQuestionAssumption(null, new Date(), 0L , Collections.singletonList(1L), null);
		engine.addQuestionAssumption(null, new Date(), 0L , Collections.singletonList(2L), null);
		
		// add a trade P(1|2) = [.7,.1,.2]
		List<Float> newValues = new ArrayList<Float>(3);
		newValues.add(.7f);  newValues.add(.1f); newValues.add(.2f);
		assertFalse( engine.addTrade( null, new Date(), 
				"User 666 trades P(1|2) = [.7,.1,.2]", 666L, 1L, 
				newValues, Collections.singletonList(2L), 
				Collections.singletonList((int)(numStatesOfQuestion2*Math.random())), false).isEmpty() );
		
		// change structure to: 1 -> 0 <- 2 -> 3
		engine.addQuestion(null, new Date(), 3L, 2+(int)Math.round(Math.random()*5), null);	
		engine.addQuestionAssumption(null, new Date(), 3L , Collections.singletonList(2L), null);
		
		// check that 1 and 2 are explicitly connected
		if (!engine.isToAddArcsWithoutReboot()) {
			assertTrue( engine.getProbabilisticNetwork().getNode("1").getParents().contains(engine.getProbabilisticNetwork().getNode("2"))
					|| engine.getProbabilisticNetwork().getNode("2").getParents().contains(engine.getProbabilisticNetwork().getNode("1")));
		}
		
		// make sure that 1 and 2 are in same clique
		Collection<INode> nodes = new ArrayList<INode>();
		nodes.add(engine.getProbabilisticNetwork().getNode("1"));
		nodes.add(engine.getProbabilisticNetwork().getNode("2"));
		// simply check that there is a clique containing both nodes
		assertNotNull(engine.getProbabilisticNetwork().getJunctionTree().getCliquesContainingAllNodes(nodes, 1));
		assertFalse(engine.getProbabilisticNetwork().getJunctionTree().getCliquesContainingAllNodes(nodes, 1).isEmpty());
		
		// restore old config
		engine.setToFullyConnectNodesInCliquesOnRebuild(backup);
	}
	
	/**
	 * This method does the same test of {@link #testCliqueStability()}, but for a single transaction
	 */
	public final void testCliqueStabilitySingleTransaction() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// backup old config
		boolean backup = engine.isToFullyConnectNodesInCliquesOnRebuild();
		// make sure the feature is on
		engine.setToFullyConnectNodesInCliquesOnRebuild(true);
		
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setDefaultInitialAssetTableValue(1000);
		
		// start transaction
		long transactionKey = engine.startNetworkActions();
		
		// Very simple case: 1 -> 0 <- 2
		engine.addQuestion(transactionKey, new Date(), 1L, 3, null);		// node 1 will have only 3 states, because it will be used in trades
		// other nodes will have from 2 to 7 states
		engine.addQuestion(transactionKey, new Date(), 0L, 2+(int)Math.round(Math.random()*5), null);		
		int numStatesOfQuestion2 = 2+(int)Math.round(Math.random()*5);	// store how many states question 2 has, because it will be used in trades
		engine.addQuestion(transactionKey, new Date(), 2L, numStatesOfQuestion2, null);		
		engine.addQuestionAssumption(transactionKey, new Date(), 0L , Collections.singletonList(1L), null);
		engine.addQuestionAssumption(transactionKey, new Date(), 0L , Collections.singletonList(2L), null);
		
		// add a trade P(1|2) = [.7,.1,.2]
		List<Float> newValues = new ArrayList<Float>(3);
		newValues.add(.7f);  newValues.add(.1f); newValues.add(.2f);
		assertTrue( engine.addTrade( transactionKey, new Date(), 
				"User 666 trades P(1|2) = [.7,.1,.2]", 666L, 1L, 
				newValues, Collections.singletonList(2L), 
				Collections.singletonList((int)(numStatesOfQuestion2*Math.random())), false).isEmpty() );
		
		// change structure to: 1 -> 0 <- 2 <- [3,4]	9
		engine.addQuestion(transactionKey, new Date(), 3L, 2+(int)Math.round(Math.random()*5), null);	
		engine.addQuestionAssumption(transactionKey, new Date(), 2L , Collections.singletonList(3L), null);
		engine.addQuestion(transactionKey, new Date(), 4L, 2+(int)Math.round(Math.random()*5), null);	
		engine.addQuestionAssumption(transactionKey, new Date(), 2L , Collections.singletonList(4L), null);
		
		// trade on 2|3=0 just in order to have a position
		newValues = new ArrayList<Float>(numStatesOfQuestion2);
		newValues.add(.7f);  
		for (int i = 1; i < numStatesOfQuestion2; i++) {
			newValues.add((float) (.3 / (numStatesOfQuestion2-1)));
		}
		assertTrue( engine.addTrade( transactionKey, new Date(), 
				"User 666 trades P(2|3=0) = [.7,[uniform]]", 666L, 2L, 
				newValues, Collections.singletonList(3L), 
				Collections.singletonList(0), true).isEmpty() );
		
		// add a balancing trade of 2 | [3,4]
		List<Long> assumptionIds = new ArrayList<Long>(2);
		assumptionIds.add(3L);
		assumptionIds.add(9L);
		List<Integer> assumedStates = new ArrayList<Integer>(2);
		assumedStates.add(0);
		assumedStates.add(0);
		engine.addQuestion(transactionKey, new Date(), 9L, 2+(int)Math.round(Math.random()*5), null);	
		engine.doBalanceTrade(transactionKey, new Date(), "666 balances 2 | [3=0,9=0]", 666, 2, assumptionIds, assumedStates);
		
		// commit transaction
		engine.commitNetworkActions(transactionKey);
		
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(2L, Collections.singletonList(0x03L), Collections.singletonList(0));
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 2L)) {
				assertNotNull(qe.getUserId());
			}
		}
		assertTrue(questionHistory.size() > 1);
		questionHistory = engine.getQuestionHistory(2L, null, null);
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId().longValue() != 2L)) {
				assertNotNull(qe.getUserId());
			}
		}
		assertTrue(questionHistory.size() > 1);
		
		// check that 1 and 2 are explicitly connected
		assertTrue( engine.getProbabilisticNetwork().getNode("1").getParents().contains(engine.getProbabilisticNetwork().getNode("2"))
				|| engine.getProbabilisticNetwork().getNode("2").getParents().contains(engine.getProbabilisticNetwork().getNode("1")));
		
		// check that 3 and 1 are explicitly connected
		assertTrue( engine.getProbabilisticNetwork().getNode("3").getParents().contains(engine.getProbabilisticNetwork().getNode("9"))
				|| engine.getProbabilisticNetwork().getNode("9").getParents().contains(engine.getProbabilisticNetwork().getNode("3")));
		
		// restore old config
		engine.setToFullyConnectNodesInCliquesOnRebuild(backup);
		

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Checks if we can add and resolve questions in a single transaction
	 */
	public final void testAddResolveQuestionSingleTransaction() {
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.setDefaultInitialAssetTableValue(1000);
		
		// start transaction
		long transactionKey = engine.startNetworkActions();
		// create 0 -> 1
		engine.addQuestion(transactionKey, new Date(1), 0, 3, null);
		engine.addQuestion(transactionKey, new Date(2), 1, 3, null);
		engine.addQuestionAssumption(transactionKey, new Date(3), 1, Collections.singletonList(0L), null);
		// set P(1|0=2) = [.2,.2,.8]
		List<Float> newValues = new ArrayList<Float>(3);
		newValues.add(.1f);
		newValues.add(.1f);
		newValues.add(.8f);
		engine.addTrade(transactionKey, new Date(4), "User 0 sets P(1|0=2) = [.1,.1,.8]", 0, 1L, newValues, 
				Collections.singletonList(0L), Collections.singletonList(2), false);
		// resolve question 0
		engine.resolveQuestion(transactionKey, new Date(5), 0, 2);
		engine.commitNetworkActions(transactionKey);
		
		// check that question 0 resolved
		List<Float> probList = engine.getProbList(0, null, null);
		assertEquals(3, probList.size());
		assertEquals(0f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(0f, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(1f, probList.get(2), PROB_ERROR_MARGIN);
		

		// check that propagation to question 1 was OK
		probList = engine.getProbList(1, null, null);
		assertEquals(3, probList.size());
		assertEquals(.1f, probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(.1f, probList.get(1), PROB_ERROR_MARGIN);
		assertEquals(.8f, probList.get(2), PROB_ERROR_MARGIN);
		
	}
	
	/**
	 * Checks that the probabilities reported by corrective tradees are of
	 * the queried question.
	 * 
	 */
	public final void testCorrectiveTradeHistoryProbListSize() {
		engine.setDefaultInitialAssetTableValue(1000);
		engine.setCurrentCurrencyConstant(100);
		engine.setCurrentLogBase(2);
		engine.initialize();
		
		// create nodes 1313(2states) <- 666(3states) -> 999(5states)
		engine.addQuestion(null, new Date(), 1313L, 2, null);
		engine.addQuestion(null, new Date(), 666L, 3, null);
		engine.addQuestion(null, new Date(), 999L, 5, null);
		engine.addQuestionAssumption(null, new Date(), 1313L, Collections.singletonList(666L), null);
		engine.addQuestionAssumption(null, new Date(), 999L, Collections.singletonList(666L), null);
		
		// do some trades which will generate corrective trades
		
		List<Float> oldValues = new ArrayList<Float>();
		List<Float> newValues = new ArrayList<Float>();
		oldValues.add(.3f);
		oldValues.add(.7f);
		newValues.add(.6f);
		newValues.add(.4f);
		engine.addTrade(null, new Date(), 
				"P(1313|666 = 0) = [.3,.7] -> [.6, .4]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				1313L, oldValues, newValues, 
				Collections.singletonList(666L), Collections.singletonList(0), 
				false
		);
		
		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.7f);
		oldValues.add(.3f);
		newValues.add(.5f);
		newValues.add(.5f);
		engine.addTrade(null, new Date(), 
				"P(1313|666 = 1) = [.7,.3] -> [.5, .5]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				1313L, oldValues, newValues, 
				Collections.singletonList(666L), Collections.singletonList(1), 
				false
		);
		
		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.2f);
		oldValues.add(.8f);
		newValues.add(.8f);
		newValues.add(.2f);
		engine.addTrade(null, new Date(), 
				"P(1313|666 = 2) = [.2,.8] -> [.8, .2]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				1313L, oldValues, newValues, 
				Collections.singletonList(666L), Collections.singletonList(2), 
				false
		);
		
		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.1f);
		oldValues.add(.1f);
		oldValues.add(.1f);
		oldValues.add(.1f);
		oldValues.add(.6f);
		newValues.add(.2f);
		newValues.add(.2f);
		newValues.add(.2f);
		newValues.add(.2f);
		newValues.add(.2f);
		engine.addTrade(null, new Date(), 
				"P(999|666 = 0) = [.1,.1,.1,.1,.6] -> [.2,.2,.2,.2,.2]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				999L, oldValues, newValues, 
				Collections.singletonList(666L), Collections.singletonList(0), 
				false
		);
		
		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.1f);
		oldValues.add(.2f);
		oldValues.add(.3f);
		oldValues.add(.2f);
		oldValues.add(.2f);
		newValues.add(.4f);
		newValues.add(.3f);
		newValues.add(.2f);
		newValues.add(.05f);
		newValues.add(.05f);
		engine.addTrade(null, new Date(), 
				"P(999|666 = 1) = [.1,.2,.3,.2,.2] -> [.4,.3,.2,.05,.05]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				999L, oldValues, newValues, 
				Collections.singletonList(666L), Collections.singletonList(1), 
				false
		);
		
		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.4f);
		oldValues.add(.3f);
		oldValues.add(.2f);
		oldValues.add(.05f);
		oldValues.add(.05f);
		newValues.add(.25f);
		newValues.add(.2f);
		newValues.add(.1f);
		newValues.add(.2f);
		newValues.add(.25f);
		engine.addTrade(null, new Date(), 
				"P(999|666 = 2) = [.4,.3,.2,.05,.05] -> [.25,.2,.1,.2,.25]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				999L, oldValues, newValues, 
				Collections.singletonList(666L), Collections.singletonList(2), 
				false
		);
		
		// also add some trades that will generate indirect changes in cliques

		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.3f);
		oldValues.add(.3f);
		oldValues.add(.2f);
		oldValues.add(.1f);
		oldValues.add(.1f);
		newValues.add(.2f);
		newValues.add(.2f);
		newValues.add(.2f);
		newValues.add(.2f);
		newValues.add(.2f);
		engine.addTrade(null, new Date(), 
				"P(999) = [.3,.3,.2,.1,.1] -> [.2,.2,.2,.2,.2]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				999L, oldValues, newValues, 
				null, null, 
				false
		);
		
		oldValues = new ArrayList<Float>();
		newValues = new ArrayList<Float>();
		oldValues.add(.5f);
		oldValues.add(.5f);
		newValues.add(.1f);
		newValues.add(.9f);
		engine.addTrade(null, new Date(), 
				"P(1313) = [.5,.5] -> [.1, .9]", 
				(long)(Math.random() * (Long.MAX_VALUE - 1)), // random user
				1313L, oldValues, newValues, 
				null, null, 
				false
		);
		
		
		// this list is used just in order to obtain the size of the questions
		Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
		
		// assert that the size of probabilities in the history is still consistent
		// question 1313
		List<QuestionEvent> history = engine.getQuestionHistory(1313L, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 1313L)) {
				assertNotNull(questionEvent.getUserId());
			}
			// check the size of probability list
			assertEquals(probLists.get(1313L).size(), questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(probLists.get(1313L).size(), questionEvent.getOldValues().size());
			}
		}
		// question 666
		history = engine.getQuestionHistory(666L, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 666L)) {
				assertNotNull(questionEvent.getUserId());
			}
			// check the size of probability list
			assertEquals(probLists.get(666L).size(), questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(probLists.get(666L).size(), questionEvent.getOldValues().size());
			}
		}
		// question 999
		history = engine.getQuestionHistory(999L, null, null);
		for (QuestionEvent questionEvent : history) {
			if (!(questionEvent instanceof StructureChangeNetworkAction)
					&& !(questionEvent.getQuestionId().longValue() != 999L)) {
				assertNotNull(questionEvent.getUserId());
			}
			// check the size of probability list
			assertEquals(probLists.get(999L).size(), questionEvent.getNewValues().size());
			if (questionEvent.getOldValues() != null) {
				assertEquals(probLists.get(999L).size(), questionEvent.getOldValues().size());
			}
		}
		
		// do the same check for conditional probabilities for all possible combinations of assumptions
		Long questionId = 1313L;
		Long assumptionId = 666L;
		for (int i = 0; i < probLists.get(assumptionId).size(); i++) {
			history = engine.getQuestionHistory(
					questionId, 
					Collections.singletonList(assumptionId), 
					Collections.singletonList((int)(Math.random()*probLists.get(assumptionId).size()))
					);
			for (QuestionEvent questionEvent : history) {
				if (!(questionEvent instanceof StructureChangeNetworkAction)
						&& !(questionEvent.getQuestionId().longValue() != questionId)) {
					assertNotNull(questionEvent.getUserId());
				}
				// check the size of probability list
				assertEquals(probLists.get(questionId).size(), questionEvent.getNewValues().size());
				if (questionEvent.getOldValues() != null) {
					assertEquals(probLists.get(questionId).size(), questionEvent.getOldValues().size());
				}
			}
		}

		questionId = 666L;
		assumptionId = 999L;
		for (int i = 0; i < probLists.get(assumptionId).size(); i++) {
			history = engine.getQuestionHistory(
					questionId, 
					Collections.singletonList(assumptionId), 
					Collections.singletonList((int)(Math.random()*probLists.get(assumptionId).size()))
					);
			for (QuestionEvent questionEvent : history) {
				if (!(questionEvent instanceof StructureChangeNetworkAction)
						&& !(questionEvent.getQuestionId() != questionId)) {
					assertNotNull(questionEvent.getUserId());
				}
				// check the size of probability list
				assertEquals(probLists.get(questionId).size(), questionEvent.getNewValues().size());
				if (questionEvent.getOldValues() != null) {
					assertEquals(probLists.get(questionId).size(), questionEvent.getOldValues().size());
				}
			}
		}

		questionId = 999L;
		assumptionId = 666L;
		for (int i = 0; i < probLists.get(assumptionId).size(); i++) {
			history = engine.getQuestionHistory(
					questionId, 
					Collections.singletonList(assumptionId), 
					Collections.singletonList((int)(Math.random()*probLists.get(assumptionId).size()))
					);
			for (QuestionEvent questionEvent : history) {
				if (!(questionEvent instanceof StructureChangeNetworkAction)
						&& !(questionEvent.getQuestionId() != questionId)) {
					assertNotNull(questionEvent.getUserId());
				}
				// check the size of probability list
				assertEquals(probLists.get(questionId).size(), questionEvent.getNewValues().size());
				if (questionEvent.getOldValues() != null) {
					assertEquals(probLists.get(questionId).size(), questionEvent.getOldValues().size());
				}
			}
		}

		questionId = 666L;
		assumptionId = 1313L;
		for (int i = 0; i < probLists.get(assumptionId).size(); i++) {
			history = engine.getQuestionHistory(
					questionId, 
					Collections.singletonList(assumptionId), 
					Collections.singletonList((int)(Math.random()*probLists.get(assumptionId).size()))
					);
			for (QuestionEvent questionEvent : history) {
				if (!(questionEvent instanceof StructureChangeNetworkAction)
						&& !(questionEvent.getQuestionId() != questionId)) {
					assertNotNull(questionEvent.getUserId());
				}
				// check the size of probability list
				assertEquals(probLists.get(questionId).size(), questionEvent.getNewValues().size());
				if (questionEvent.getOldValues() != null) {
					assertEquals(probLists.get(questionId).size(), questionEvent.getOldValues().size());
				}
			}
		}
	}
	
	/**
	 * Check whether we can use resolved questions as arguments of the following methods:
	 * {@link MarkovEngineInterface#getAssetsIfStates(long, long, List, List)}
	 * {@link MarkovEngineInterface#getProbList(long, List, List)}
	 * {@link MarkovEngineInterface#getProbLists(List, List, List)}
	 * {@link MarkovEngineInterface#scoreUserEv(long, List, List)}
	 * {@link MarkovEngineInterface#scoreUserQuestionEv(long, Long, List, List)}
	 * {@link MarkovEngineInterface#scoreUserQuestionEvStates(long, long, List, List)}
	 * {@link MarkovEngineInterface#getCash(long, List, List)}
	 */
	public final void testResolvedQuestionAsArgument() {
		// generate the DEF network
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap );
		
		// check that I can call the tested method with no problems now
		
		// first, test methods which does not depend on users
		
		// {@link MarkovEngineInterface#getProbList(long, List, List)}
		// different clique
		List<Float> probList = engine.getProbList(0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertNotNull(probList);
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		// same clique
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) > 0 &&probList.get(1) > 0);
		assertTrue(probList.get(0) < 1 &&probList.get(1) < 1);
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		
		// {@link MarkovEngineInterface#getProbLists(List, List, List)}
		// this method can test different cliques and same cliques at once
		Map<Long, List<Float>> probLists = engine.getProbLists(null, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0FL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		probLists = engine.getProbLists(null, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0FL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		probLists = engine.getProbLists(null, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= (-PROB_ERROR_MARGIN) &&probList.get(1) >= (-PROB_ERROR_MARGIN));
			assertTrue(probList.get(0) <= (1+PROB_ERROR_MARGIN) &&probList.get(1) <= (1+PROB_ERROR_MARGIN));
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		probLists = engine.getProbLists(null, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		List<Long> allQuestions = new ArrayList<Long>(3);
		allQuestions.add(0x0DL);
		allQuestions.add(0x0EL);
		allQuestions.add(0x0FL);
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0FL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0EL), Collections.singletonList(1));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0FL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= (-PROB_ERROR_MARGIN) &&probList.get(1) >= (-PROB_ERROR_MARGIN));
			assertTrue(probList.get(0) <= (1+PROB_ERROR_MARGIN) &&probList.get(1) <= (1+PROB_ERROR_MARGIN));
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		List<Long> outOfCliqueAssumptions = new ArrayList<Long>();
		outOfCliqueAssumptions.add(0x0EL);
		outOfCliqueAssumptions.add(0x0FL);
		List<Integer> outOfCliqueAssumptionsStates = new ArrayList<Integer>();
		outOfCliqueAssumptionsStates.add(1);
		outOfCliqueAssumptionsStates.add(1);
		probLists = engine.getProbLists(allQuestions, outOfCliqueAssumptions, outOfCliqueAssumptionsStates);
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// then, test methods which depends on users
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			for (String userName : userNameToIDMap.keySet()) {
				// {@link MarkovEngineInterface#getAssetsIfStates(long, long, List, List)}
				// in this case, the node must be in the same clique
				List<Float> assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				
				// {@link MarkovEngineInterface#scoreUserEv(long, List, List)}
				float score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertTrue(score > 0);
				score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0EL), Collections.singletonList(1));
				assertTrue(score > 0);
				
				// {@link MarkovEngineInterface#scoreUserQuestionEv(long, Long, List, List)}
				// different cliques
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertTrue(score > 0);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assertTrue(score > 0);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
				assertTrue(score > 0);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
				assertTrue(score > 0);
				// same clique
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertTrue(score > 0);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assertTrue(score > 0);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
				assertTrue(score > 0);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
				assertTrue(score > 0);
				
				// {@link MarkovEngineInterface#scoreUserQuestionEvStates(long, long, List, List)}
				// different clique
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				// same clique
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
				assertNotNull(assets);
				assertEquals(2, assets.size());
				assertTrue(assets.get(0) > 0 && assets.get(1) > 0);
				
			}
		}
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(1));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, 0x0EL, null, null).get(1));
		}

		// settle/resolve question E on state 1 (so that assuming state 0 will be invalid)
		engine.resolveQuestion(null, new Date(), 0x0EL, 1);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check the methods after settlement
		
		// first, test methods which does not depend on users
		
		// {@link MarkovEngineInterface#getProbList(long, List, List)}
		// different clique
		// obtaining the probability of resolved question should return [0,1]
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertNotNull(probList);
		assertEquals(2, probList.size());
		assertEquals(0 , probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(1 , probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0 , probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(1 , probList.get(1), PROB_ERROR_MARGIN);
		
		// prob of other questions assuming resolved questions with incompatible state is NaN
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(Float.NaN, probList.get(0));
		assertEquals(Float.NaN, probList.get(1));
		
		// probability of other questions assuming resolved question will be the same without the assumption, if the assumed state is compatible with settled state
		probList = engine.getProbList(0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		List<Float> probListIgnoringResolvedAssumption = engine.getProbList(0x0FL, null, null);
		assertEquals(probListIgnoringResolvedAssumption.size(), probList.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probListIgnoringResolvedAssumption.get(i), probList.get(i), PROB_ERROR_MARGIN);
		}
		
		// same clique
		
		// prob of other questions assuming resolved questions with incompatible state is NaN
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(Float.NaN, probList.get(0));
		assertEquals(Float.NaN, probList.get(1));
		
		// probability of other questions assuming resolved question will be the same without the assumption, if the assumed state is compatible with settled state
		probList = engine.getProbList(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
		probListIgnoringResolvedAssumption = engine.getProbList(0x0DL, null, null);
		assertEquals(probListIgnoringResolvedAssumption.size(), probList.size());
		for (int i = 0; i < probList.size(); i++) {
			assertEquals(probListIgnoringResolvedAssumption.get(i), probList.get(i), PROB_ERROR_MARGIN);
		}
		
		// obtaining the probability of resolved question should return [0,1]
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
		assertEquals(2, probList.size());
		assertEquals(0 , probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(1 , probList.get(1), PROB_ERROR_MARGIN);
		probList = engine.getProbList(0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
		assertEquals(2, probList.size());
		assertEquals(0 , probList.get(0), PROB_ERROR_MARGIN);
		assertEquals(1 , probList.get(1), PROB_ERROR_MARGIN);
		
		// {@link MarkovEngineInterface#getProbLists(List, List, List)}
		// this method can test different cliques and same cliques at once
		
		// prob of other questions assuming resolved questions with incompatible state is NaN
		probLists = engine.getProbLists(null, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(2, probLists.size());
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertEquals(Float.NaN, probList.get(0));
			assertEquals(Float.NaN, probList.get(1));
		}
		
		probLists = engine.getProbLists(null, Collections.singletonList(0x0EL), Collections.singletonList(1));
		Map<Long, List<Float>> probListsIgnoringResolvedAssumption = engine.getProbLists(null, null, null);
		assertEquals(probListsIgnoringResolvedAssumption.size(), probLists.size());
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			probListIgnoringResolvedAssumption = probListsIgnoringResolvedAssumption.get(key);
			assertEquals(probListIgnoringResolvedAssumption.size(), probList.size());
			for (int i = 0; i < probList.size(); i++) {
				assertEquals(probListIgnoringResolvedAssumption.get(i), probList.get(i), PROB_ERROR_MARGIN);
			}
		}
		
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0EL), Collections.singletonList(0));
		assertEquals(3, probLists.size());
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertEquals(Float.NaN, probList.get(0));
			assertEquals(Float.NaN, probList.get(1));
		}
		
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0EL), Collections.singletonList(1));
		probListsIgnoringResolvedAssumption = engine.getProbLists(allQuestions, null, null);
		assertEquals(probListsIgnoringResolvedAssumption.size(), probLists.size());
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			probListIgnoringResolvedAssumption = probListsIgnoringResolvedAssumption.get(key);
			assertEquals(probListIgnoringResolvedAssumption.size(), probList.size());
			for (int i = 0; i < probList.size(); i++) {
				assertEquals(probListIgnoringResolvedAssumption.get(i), probList.get(i), PROB_ERROR_MARGIN);
			}
		}
		
		// obtaining the probability of remaining questions
		probLists = engine.getProbLists(null, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(2, probLists.size());
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		// prob of resolved question should be [0,1]
		probLists = engine.getProbLists(Collections.singletonList(0x0EL), Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(0, probLists.get(0x0EL).get(0), PROB_ERROR_MARGIN);
		assertEquals(1, probLists.get(0x0EL).get(1), PROB_ERROR_MARGIN);
		
		probLists = engine.getProbLists(null, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(2, probLists.size());
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= (1+PROB_ERROR_MARGIN) &&probList.get(1) <= (1+PROB_ERROR_MARGIN));
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		}
		// prob of resolved question should be [0,1]
		probLists = engine.getProbLists(Collections.singletonList(0x0EL), Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(0, probLists.get(0x0EL).get(0), PROB_ERROR_MARGIN);
		assertEquals(1, probLists.get(0x0EL).get(1), PROB_ERROR_MARGIN);
		
		// prob of node conditioned to itself should be [0,1]
		probLists = engine.getProbLists(Collections.singletonList(0x0FL), Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(1, probLists.get(0x0FL).get(0), PROB_ERROR_MARGIN);
		assertEquals(0, probLists.get(0x0FL).get(1), PROB_ERROR_MARGIN);
		
		probLists = engine.getProbLists(Collections.singletonList(0x0FL), Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(0, probLists.get(0x0FL).get(0), PROB_ERROR_MARGIN);
		assertEquals(1, probLists.get(0x0FL).get(1), PROB_ERROR_MARGIN);
		
		
		// obtaining the probability of remaining questions
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0FL), Collections.singletonList(0));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= 1 &&probList.get(1) <= 1);
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
			if (key.longValue() == 0x0EL) {
				// prob of resolved question should be [0,1]
				assertEquals(0, probLists.get(0x0EL).get(0), PROB_ERROR_MARGIN);
				assertEquals(1, probLists.get(0x0EL).get(1), PROB_ERROR_MARGIN);
			}
		}
		
		probLists = engine.getProbLists(allQuestions, Collections.singletonList(0x0FL), Collections.singletonList(1));
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= (1+PROB_ERROR_MARGIN) &&probList.get(1) <= (1+PROB_ERROR_MARGIN));
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
			if (key.longValue() == 0x0EL) {
				// prob of resolved question should be [0,1]
				assertEquals(0, probLists.get(0x0EL).get(0), PROB_ERROR_MARGIN);
				assertEquals(1, probLists.get(0x0EL).get(1), PROB_ERROR_MARGIN);
			}
		}
		
		// method should also support multiple assumptions which are outside the clique
		probLists = engine.getProbLists(allQuestions, outOfCliqueAssumptions, outOfCliqueAssumptionsStates);
		assertEquals(3, probLists.size());
		assertTrue(probLists.containsKey(0x0EL));
		for (Long key : probLists.keySet()) {
			probList = probLists.get(key);
			assertEquals(2, probList.size());
			assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
			assertTrue(probList.get(0) <= (1+PROB_ERROR_MARGIN) &&probList.get(1) <= (1+PROB_ERROR_MARGIN));
			assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
			if (key.longValue() == 0x0EL) {
				// prob of resolved question should be [0,1]
				assertEquals(0, probLists.get(0x0EL).get(0), PROB_ERROR_MARGIN);
				assertEquals(1, probLists.get(0x0EL).get(1), PROB_ERROR_MARGIN);
			}
		}
		probList = engine.getProbList(0x0DL, outOfCliqueAssumptions, outOfCliqueAssumptionsStates);
		assertEquals(2, probList.size());
		assertTrue(probList.get(0) >= 0 &&probList.get(1) >= 0);
		assertTrue(probList.get(0) <= (1+PROB_ERROR_MARGIN) &&probList.get(1) <= (1+PROB_ERROR_MARGIN));
		assertEquals(1 , probList.get(0) + probList.get(1), PROB_ERROR_MARGIN);
		
		// then, test methods which depends on users
		if (!engine.isToAddArcsOnlyToProbabilisticNetwork()) {
			for (String userName : userNameToIDMap.keySet()) {
				// {@link MarkovEngineInterface#getAssetsIfStates(long, long, List, List)}
				// in this case, the node must be in the same clique
				List<Float> assets = null;
				try {
					// assets of resolved node is not well defined
					assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
					fail();
				} catch (RuntimeException e) {
					// OK
				}
				try {
					// assets of resolved node is not well defined
					assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
					fail();
				} catch (RuntimeException e) {
					// OK
				}
				// assets with assumption incompatible with settlement is NaN
				assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(Float.NaN, assets.get(1));
				
				// if assumption is compatible, then it must be the same as ignoring the resolved assumption
				assets = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				List<Float> assetsIgnoringAssumption = engine.getAssetsIfStates(userNameToIDMap.get(userName), 0x0DL, null, null);
				assertEquals(assetsIgnoringAssumption.size(), assets.size());
				for (int i = 0; i < assets.size(); i++) {
					assertEquals(assetsIgnoringAssumption.get(i), assets.get(i), ASSET_ERROR_MARGIN);
				}
				
				// {@link MarkovEngineInterface#scoreUserEv(long, List, List)}
				float score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(Float.NaN, score);
				score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0EL), Collections.singletonList(1));
				float scoreIgnoringIncompatibleState = engine.scoreUserEv(userNameToIDMap.get(userName), null, null);
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				
				// {@link MarkovEngineInterface#scoreUserQuestionEv(long, Long, List, List)}
				// different cliques
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(Float.NaN, score);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				scoreIgnoringIncompatibleState = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0FL, null, null);
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				
				// score question EV of resolved question should be equals to the conditional expected assets regardless of settled question
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
				scoreIgnoringIncompatibleState = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0FL), Collections.singletonList(0));
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
				scoreIgnoringIncompatibleState = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0FL), Collections.singletonList(1));
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				
				// same clique
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(Float.NaN, score);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				scoreIgnoringIncompatibleState = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0DL, null, null);
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				
				// score question EV of resolved question should be equals to the conditional expected assets regardless of settled question
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
				scoreIgnoringIncompatibleState = engine.scoreUserEv(userNameToIDMap.get(userName),  Collections.singletonList(0x0DL), Collections.singletonList(0));
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				score = engine.scoreUserQuestionEv(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
				scoreIgnoringIncompatibleState = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0DL), Collections.singletonList(1));
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				
				// {@link MarkovEngineInterface#scoreUserQuestionEvStates(long, long, List, List)}
				
				// different clique
				
				// assets with assumption incompatible with settlement is NaN
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(Float.NaN, assets.get(1));
				
				// if assumption is compatible, then it must be the same as ignoring the resolved assumption
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0FL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assetsIgnoringAssumption = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0FL, null, null);
				assertEquals(assetsIgnoringAssumption.size(), assets.size());
				for (int i = 0; i < assets.size(); i++) {
					assertEquals(assetsIgnoringAssumption.get(i), assets.get(i), ASSET_ERROR_MARGIN);
				}
				
				// score of resolved question will be NaN for the incompatible state, and the global conditional expected assets for the compatible state
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(0));
				score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0FL), Collections.singletonList(0));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(score, assets.get(1));
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0FL), Collections.singletonList(1));
				score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0FL), Collections.singletonList(1));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(score, assets.get(1));
				
				// same clique
				
				// assets with assumption incompatible with settlement is NaN
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(Float.NaN, assets.get(1));
				
				// if assumption is compatible, then it must be the same as ignoring the resolved assumption
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(1));
				assetsIgnoringAssumption = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0DL, null, null);
				assertEquals(assetsIgnoringAssumption.size(), assets.size());
				for (int i = 0; i < assets.size(); i++) {
					assertEquals(assetsIgnoringAssumption.get(i), assets.get(i), ASSET_ERROR_MARGIN);
				}
				
				// score of resolved question will be NaN for the incompatible state, and the global conditional expected assets for the compatible state
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(0));
				score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0DL), Collections.singletonList(0));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(score, assets.get(1));
				assets = engine.scoreUserQuestionEvStates(userNameToIDMap.get(userName), 0x0EL, Collections.singletonList(0x0DL), Collections.singletonList(1));
				score = engine.scoreUserEv(userNameToIDMap.get(userName), Collections.singletonList(0x0DL), Collections.singletonList(1));
				assertEquals(2, assets.size());
				assertEquals(Float.NaN, assets.get(0));
				assertEquals(score, assets.get(1));
				
				// {@link MarkovEngineInterface#getCash(long, List, List)}
				score = engine.getCash(userNameToIDMap.get(userName), Collections.singletonList(0x0EL), Collections.singletonList(0));
				assertEquals(Float.NaN, score);
				score = engine.getCash(userNameToIDMap.get(userName), Collections.singletonList(0x0EL), Collections.singletonList(1));
				scoreIgnoringIncompatibleState = engine.getCash(userNameToIDMap.get(userName), null, null);
				assertEquals(scoreIgnoringIncompatibleState, score, ASSET_ERROR_MARGIN);
				
			}
		}
	}
	
	public final void testConditionalHistorySingleTransaction() {
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		engine.setToStoreOnlyCliqueChangeHistory(true);
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0EL), Collections.singletonList(0));
		for (QuestionEvent qe : questionHistory) {
			if (!(qe instanceof StructureChangeNetworkAction)
					&& !(qe.getQuestionId() != 0x0DL)) {
				assertNotNull(qe.getUserId());
			}
		}
		if (engine.isToTraceHistory()) {
			assertTrue(questionHistory.size() > 1);
			questionHistory = engine.getQuestionHistory(0x0DL, Collections.singletonList(0x0FL), Collections.singletonList(0));
			for (QuestionEvent qe : questionHistory) {
				if (!(qe instanceof StructureChangeNetworkAction)
						&& !(qe.getQuestionId() != 0x0DL)) {
					assertNotNull(qe.getUserId());
				}
			}
			assertTrue(questionHistory.size() > 1);
		}
	}
	
	/**
	 * Tests {@link ScoreSummary#getCashContributionPerResolvedQuestion()}
	 * of {@link MarkovEngineImpl#getScoreSummaryObject(long, Long, List, List)},
	 * and respective entry in {@link MarkovEngineImpl#getScoreSummary(long, Long, List, List)}
	 */
	public final void testScoreSummayGetCashContributionPerResolvedQuestion() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		engine.setToStoreCashBeforeResolveQuestion(true);
		
		// create DEF net and do some trades
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		
		// store the cash of all users before resolving question
		Map<Long, Float> userCashBeforeResolving1stQuestion = new HashMap<Long, Float>();
		for (Long userId : userNameToIDMap.values()) {
			userCashBeforeResolving1stQuestion.put(userId, engine.getCash(userId, null, null));
		}
		
		// randomly decide which question to resolve
		long resolvedQuestionID1 = (Math.random() < .3)?0x0DL:((Math.random() < .5)?0x0EL:0x0FL);
		int settledState1 =  (Math.random() < .5)?0:1;
		
		// get the expected score per node to be resolved for each user
		Map<Long, Float>  expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, resolvedQuestionID1, null, null).get(settledState1));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, resolvedQuestionID1, null, null).get(settledState1));
		}

		// resolve question
		engine.resolveQuestion(null, new Date(), resolvedQuestionID1,settledState1);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check that the summary of cash contribution per resolved question is consistent with the cash before and after resolution
		Map<Long, Float> contributionOfFirstSettlement = new HashMap<Long, Float>();	// store what was cash before - after, so that we can compare later
		for (Long userId : userNameToIDMap.values()) {
			// this is the main method to test
			ScoreSummary scoreSummaryObject = engine.getScoreSummaryObject(userId, null, null, null);
			// the same method, but filtered exactly by the resolved question
			ScoreSummary scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null);
			
			// obtain current cash
			float currentCash = engine.getCash(userId, null, null);
			
			// store current contribution, which is the current cash minus cash before resolution
			contributionOfFirstSettlement.put(userId, currentCash - userCashBeforeResolving1stQuestion.get(userId));
			
			// check that only 1 question has resolved so far
			if (Math.abs(contributionOfFirstSettlement.get(userId)) >= PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				// check that resolved question is resolvedQuestionID1
				assertEquals(resolvedQuestionID1, scoreSummaryObject.getCashContributionPerResolvedQuestion().keySet().iterator().next().longValue());
				assertEquals(resolvedQuestionID1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().keySet().iterator().next().longValue());
				assertNotNull(scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1));
				assertNotNull(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1));
				// check that contribution obtained from score summary equals to current cash minus cash before resolution
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
				
				float sum = userCashBeforeResolving1stQuestion.get(userId);
				for (Float gain : scoreSummaryObject.getCashContributionPerResolvedQuestion().values()) {
					sum += gain;
				}
				assertEquals("User = " + userId, currentCash, sum, ASSET_ERROR_MARGIN);
			} else {
				assertTrue( scoreSummaryObject.getCashContributionPerResolvedQuestion().isEmpty());
				assertTrue( scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().isEmpty());
			}
			
			// test cash before resolution
			// only 1 question resolved so far
			assertEquals(1, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			// check content
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(currentCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1) == null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)),
					PROB_ERROR_MARGIN);
			assertEquals(currentCash, 
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)),
					PROB_ERROR_MARGIN);
			
			// TODO also check deprecated methods
//			// this is a deprecated method, but we still need to test it
//			List<Properties> scoreSummary = engine.getScoreSummary(userId, null, null, null);
//			// the same method, but filtered exactly by the resolved question
//			List<Properties> scoreSummaryFilteredByQuestion = engine.getScoreSummary(userId, resolvedQuestionID1, null, null);
		}
		
		// store the cash of all users before resolving next question
		HashMap<Long, Float> userCashBeforeResolving2ndQuestion = new HashMap<Long, Float>();
		for (Long userId : userNameToIDMap.values()) {
			userCashBeforeResolving2ndQuestion.put(userId, engine.getCash(userId, null, null));
		}
		
		// randomly decide another question to resolve
		long resolvedQuestionID2 = (Math.random() < .3)?0x0DL:((Math.random() < .5)?0x0EL:0x0FL);
		while(resolvedQuestionID1 == resolvedQuestionID2) {
			resolvedQuestionID2 = (Math.random() < .3)?0x0DL:((Math.random() < .5)?0x0EL:0x0FL);
		}
		
		int settledState2 = (Math.random() < .5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, resolvedQuestionID2, null, null).get(settledState2));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, resolvedQuestionID2, null, null).get(settledState2));
		}

		// resolve new question
		engine.resolveQuestion(null, new Date(), resolvedQuestionID2, settledState2);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check that the summary of cash contribution per resolved question is consistent with the cash before and after resolution
		Map<Long, Float> contributionOfSecondSettlement = new HashMap<Long, Float>();	// store what was cash before - after, so that we can compare later
		for (Long userId : userNameToIDMap.values()) {
			// obtain current cash
			float currentCash = engine.getCash(userId, null, null);
			
			// store last contribution, which is the current cash minus cash before last resolution
			contributionOfSecondSettlement.put(userId, currentCash - userCashBeforeResolving2ndQuestion.get(userId));
			
			// this is the main method to test
			ScoreSummary scoreSummaryObject = engine.getScoreSummaryObject(userId, null, null, null);
			
			// calculate how many gains the user had
			int numGains = 0;
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			
			// check that 2 questions have resolved so far
			assertEquals(numGains, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
			
			// check that resolved question contains questions resolved so far and check that contribution obtained from score summary equals to current cash minus cash before resolution, for all considered questions
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID1));
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			}
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID2));
				assertNotNull(scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2));
				assertEquals(contributionOfSecondSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			}
			

			// test cash before resolution
			assertEquals(2, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(userCashBeforeResolving2ndQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			assertEquals(currentCash, 
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1))
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)),
					PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)),
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),
					PROB_ERROR_MARGIN);
			
			
			
			// the same method, but filtered exactly by the resolved question
			
			// if we filtered by question ID, then there can only be 1 question. Check it
			ScoreSummary scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null);
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID1));
				assertFalse(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID2));
				assertNotNull(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1));
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			} else {
				assertFalse(engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null).getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID1));
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			
			// filter by the other question too
			scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID2, null, null);
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertFalse(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID1));
				assertTrue(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID2));
				assertNotNull(scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2));
				assertEquals(contributionOfSecondSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			} else {
				assertFalse(engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null).getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID2));
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving2ndQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			
			// check consistency about sum of gains
			float sum = userCashBeforeResolving1stQuestion.get(userId);
			for (Float gain : scoreSummaryObject.getCashContributionPerResolvedQuestion().values()) {
				sum += gain;
			}
			assertEquals("User = " + userId, currentCash, sum, ASSET_ERROR_MARGIN);
			
			// TODO also check deprecated methods
			
//			// this is a deprecated method, but we still need to test it
//			List<Properties> scoreSummary = engine.getScoreSummary(userId, null, null, null);
//			// the same method, but filtered exactly by the resolved question
//			List<Properties> scoreSummaryFilteredByQuestion = engine.getScoreSummary(userId, resolvedQuestionID1, null, null);
		}
		
		// store the cash of all users before resolving next question
		HashMap<Long, Float> userCashBeforeResolving3rdQuestion = new HashMap<Long, Float>();
		for (Long userId : userNameToIDMap.values()) {
			userCashBeforeResolving3rdQuestion.put(userId, engine.getCash(userId, null, null));
		}
		
		// decide last question to resolve, which must be different from the previous questions
		long resolvedQuestionID3 = 0x0DL;
		while(resolvedQuestionID1 == resolvedQuestionID3 || resolvedQuestionID2 == resolvedQuestionID3) {
			resolvedQuestionID3++;
		}
		assertTrue(0x0DL <= resolvedQuestionID3 && resolvedQuestionID3 <= 0x0FL);
		
		int settledState3 = (Math.random() < .5)?0:1;
		// get the expected score per node to be resolved for each user
		expectedScorePerUsers = new HashMap<Long, Float>();
		for (Long userId : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, resolvedQuestionID3, null, null).get(settledState3));
		}
		for (Long userId : engine.getUninitializedUserToAssetMap().keySet()) {
			// store the expected score of the state to be resolved
			expectedScorePerUsers.put(userId, engine.scoreUserQuestionEvStates(userId, resolvedQuestionID3, null, null).get(settledState3));
		}
		
		// resolve new question
		engine.resolveQuestion(null, new Date(), resolvedQuestionID3, settledState3);
		// check that the expected before resolve question is the current score
		for (Long userId : expectedScorePerUsers.keySet()) {
			assertEquals("User=" + userId, expectedScorePerUsers.get(userId), engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
		}
		
		// check that the summary of cash contribution per resolved question is consistent with the cash before and after resolution
		Map<Long, Float> contributionOfThirdSettlement = new HashMap<Long, Float>();	// store what was cash before - after, so that we can compare later
		for (Long userId : userNameToIDMap.values()) {
			// obtain current cash
			float currentCash = engine.getCash(userId, null, null);
			
			// store last contribution, which is the current cash minus cash before last resolution
			contributionOfThirdSettlement.put(userId, currentCash - userCashBeforeResolving3rdQuestion.get(userId));
			
			// this is the main method to test
			ScoreSummary scoreSummaryObject = engine.getScoreSummaryObject(userId, null, null, null);
			
			// calculate how many gains the user had
			int numGains = 0;
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			if (Math.abs(contributionOfThirdSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			
			// check that 3 (all) questions have resolved so far
			assertEquals(numGains, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
			
			// check that resolved question contains questions resolved so far and check that contribution obtained from score summary equals to current cash minus cash before resolution, for all considered questions
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID1));
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			}
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID2));
				assertNotNull(scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2));
				assertEquals(contributionOfSecondSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			}
			if (Math.abs(contributionOfThirdSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID3));
				assertNotNull(scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3));
				assertEquals(contributionOfThirdSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			}
			
			// test cash before resolution
			assertEquals(3, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(userCashBeforeResolving2ndQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			assertEquals(userCashBeforeResolving3rdQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			assertEquals(currentCash, 
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1))
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2))
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3)),
					PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)),
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),
					PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)),
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),
					PROB_ERROR_MARGIN);
			
			
			// the same method, but filtered exactly by the resolved question
			// if we filtered by question ID, then there can only be 1 question. Check it
			ScoreSummary scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null);
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			} else {
				assertTrue(engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null).getCashContributionPerResolvedQuestion().isEmpty());
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			
			
			// check next question
			scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID2, null, null);
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				assertEquals(contributionOfSecondSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			} else {
				assertTrue(engine.getScoreSummaryObject(userId, resolvedQuestionID2, null, null).getCashContributionPerResolvedQuestion().isEmpty());
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving2ndQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			
			// check next question
			scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID3, null, null);
			if (Math.abs(contributionOfThirdSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				assertEquals(contributionOfThirdSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			} else {
				assertTrue(engine.getScoreSummaryObject(userId, resolvedQuestionID3, null, null).getCashContributionPerResolvedQuestion().isEmpty());
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving3rdQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			
			
			// check consistency about sum of gains
			float sum = userCashBeforeResolving1stQuestion.get(userId);
			for (Float gain : scoreSummaryObject.getCashContributionPerResolvedQuestion().values()) {
				sum += gain;
			}
			assertEquals("User = " + userId, currentCash, sum, ASSET_ERROR_MARGIN);
			
			// TODO also check deprecated methods
			
//			// this is a deprecated method, but we still need to test it
//			List<Properties> scoreSummary = engine.getScoreSummary(userId, null, null, null);
//			// the same method, but filtered exactly by the resolved question
//			List<Properties> scoreSummaryFilteredByQuestion = engine.getScoreSummary(userId, resolvedQuestionID1, null, null);
		}
		
		// check scoreSummaryObject.getCashContributionPerResolvedQuestion() and scoreSummaryObject.userCashBeforeResolving3rdQuestion() for uninitialized users
		// create an uninitialized user
		long user = Long.MAX_VALUE;
		float initialCash = 666f;
		engine.addCash(null, new Date(), Long.MAX_VALUE, initialCash , "Forced creation of an uninitialized user by adding 666 cash to user" + user);
		
		// test cash before resolution of uninitialized users
		ScoreSummary scoreSummaryObject = engine.getScoreSummaryObject(user, null, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
//		assertEquals(initialCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
//		assertEquals(initialCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
//		assertEquals(initialCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		// check filtered ones
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID1, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
//		assertEquals(initialCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID2, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
//		assertEquals(initialCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID3, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
//		assertEquals(initialCash, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
		
		// test cash before resolution of a user never used
		user--;
		scoreSummaryObject = engine.getScoreSummaryObject(user, null, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
//		assertEquals(0f, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
//		assertEquals(0f, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
//		assertEquals(0f, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		// check filtered ones
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID1, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
//		assertEquals(0f, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID2, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
//		assertEquals(0f, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID3, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
//		assertEquals(0f, scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
		
		
		
		// do the same test when resolving all nodes in 1 transaction
		// create DEF net and do some trades
		engine.initialize();	// reset
		userNameToIDMap = new HashMap<String, Long>();
		this.createDEFNetIn1Transaction(userNameToIDMap);
		
		long transactionKey = engine.startNetworkActions();
		engine.resolveQuestion(transactionKey, new Date(), resolvedQuestionID1, settledState1);
		engine.resolveQuestion(transactionKey, new Date(), resolvedQuestionID2, settledState2);
		engine.resolveQuestion(transactionKey, new Date(), resolvedQuestionID3, settledState3);
		engine.commitNetworkActions(transactionKey);
		
		
		for (Long userId : userNameToIDMap.values()) {
			// obtain current cash
			float currentCash = engine.getCash(userId, null, null);
			
			// this is the main method to test
			scoreSummaryObject = engine.getScoreSummaryObject(userId, null, null, null);
			
			// calculate how many gains the user had
			int numGains = 0;
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			if (Math.abs(contributionOfThirdSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				numGains++;
			}
			
			// check that 3 (all) questions have resolved so far
			assertEquals(numGains, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
			
			// check that resolved question contains questions resolved so far and check that contribution obtained from score summary equals to current cash minus cash before resolution, for all considered questions
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID1));
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			}
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID2));
				assertNotNull(scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2));
				assertEquals(contributionOfSecondSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			}
			if (Math.abs(contributionOfThirdSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertTrue(scoreSummaryObject.getCashContributionPerResolvedQuestion().containsKey(resolvedQuestionID3));
				assertNotNull(scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3));
				assertEquals(contributionOfThirdSettlement.get(userId), scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			}
			
			// test cash before resolution
			assertEquals(3, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(userCashBeforeResolving2ndQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			assertEquals(userCashBeforeResolving3rdQuestion.get(userId), scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			assertEquals(currentCash, 
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1))
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2))
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3)),
					PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1)),
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),
					PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2) 
					+ ((scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)==null)?0:scoreSummaryObject.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2)),
					scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),
					PROB_ERROR_MARGIN);
			
			
			// the same method, but filtered exactly by the resolved question
			// if we filtered by question ID, then there can only be 1 question. Check it
			ScoreSummary scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null);
			if (Math.abs(contributionOfFirstSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				assertEquals(contributionOfFirstSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			} else {
				assertTrue(engine.getScoreSummaryObject(userId, resolvedQuestionID1, null, null).getCashContributionPerResolvedQuestion().isEmpty());
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving1stQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID1), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID1),PROB_ERROR_MARGIN);
			
			
			// check next question
			scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID2, null, null);
			if (Math.abs(contributionOfSecondSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				assertEquals(contributionOfSecondSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			} else {
				assertTrue(engine.getScoreSummaryObject(userId, resolvedQuestionID2, null, null).getCashContributionPerResolvedQuestion().isEmpty());
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving2ndQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID2), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID2),PROB_ERROR_MARGIN);
			
			// check next question
			scoreSummaryObjectFilteredByQuestion = engine.getScoreSummaryObject(userId, resolvedQuestionID3, null, null);
			if (Math.abs(contributionOfThirdSettlement.get(userId)) > PROB_ERROR_MARGIN) {
				assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().size());
				assertEquals(contributionOfThirdSettlement.get(userId), scoreSummaryObjectFilteredByQuestion.getCashContributionPerResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			} else {
				assertTrue(engine.getScoreSummaryObject(userId, resolvedQuestionID3, null, null).getCashContributionPerResolvedQuestion().isEmpty());
			}
			// test cash before resolution
			assertEquals(1, scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().size());
			assertEquals(userCashBeforeResolving3rdQuestion.get(userId), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			assertEquals(scoreSummaryObject.getCashBeforeResolvedQuestion().get(resolvedQuestionID3), scoreSummaryObjectFilteredByQuestion.getCashBeforeResolvedQuestion().get(resolvedQuestionID3),PROB_ERROR_MARGIN);
			
			
			// check consistency about sum of gains
			float sum = userCashBeforeResolving1stQuestion.get(userId);
			for (Float gain : scoreSummaryObject.getCashContributionPerResolvedQuestion().values()) {
				sum += gain;
			}
			assertEquals("User = " + userId, currentCash, sum, ASSET_ERROR_MARGIN);
			
			// TODO also check deprecated methods
			
//			// this is a deprecated method, but we still need to test it
//			List<Properties> scoreSummary = engine.getScoreSummary(userId, null, null, null);
//			// the same method, but filtered exactly by the resolved question
//			List<Properties> scoreSummaryFilteredByQuestion = engine.getScoreSummary(userId, resolvedQuestionID1, null, null);
		}
		
		// check scoreSummaryObject.getCashContributionPerResolvedQuestion() and scoreSummaryObject.userCashBeforeResolving3rdQuestion() for uninitialized users
		// create an uninitialized user
		user = Long.MAX_VALUE;
		initialCash = 666f;
		engine.addCash(null, new Date(), Long.MAX_VALUE, initialCash , "Forced creation of an uninitialized user by adding 666 cash to user" + user);
		
		// test cash before resolution of uninitialized users
		scoreSummaryObject = engine.getScoreSummaryObject(user, null, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		// check filtered ones
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID1, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID2, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID3, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		
		// test cash before resolution of a user never used
		user--;
		scoreSummaryObject = engine.getScoreSummaryObject(user, null, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		// check filtered ones
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID1, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID2, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());
		scoreSummaryObject = engine.getScoreSummaryObject(user, resolvedQuestionID3, null, null);
		assertEquals(0, scoreSummaryObject.getCashBeforeResolvedQuestion().size());
		assertEquals(0, scoreSummaryObject.getCashContributionPerResolvedQuestion().size());

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);	
	}
	
	
	/**
	 * Verifies the behavior of balancing trades when 10 variables are present in the same clique.
	 * A network with 30 variables, comprised of 3 subnets of 10 variables with 2 states, fully connected (so, there will be
	 * 3 Disconnected cliques with 10 variables).
	 */
	public final void testBalanceTrade10Vars() {
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		boolean isToAddArcsWithoutReboot = engine.isToAddArcsWithoutReboot();
		boolean isToTraceHistory = engine.isToTraceHistory();
		engine.setToAddArcsOnlyToProbabilisticNetwork(false);
		engine.setToAddArcsWithoutReboot(false);
		engine.setToTraceHistory(true);
		
		// set up engine
		engine.setDefaultInitialAssetTableValue(1000f);
		engine.initialize();
		
		// generate the 30 nodes
		long transactionKey = engine.startNetworkActions();
		for (int i = 0; i < 30; i++) {
			engine.addQuestion(transactionKey, new Date(i), (long)i, 2, null);
		}
		// fully connect 10 by 10
		for (int i = 0; i < 3; i++) {
			for (int j = 10*i; j < 10*i+9; j++) {
				List<Long> parentQuestionIds = Collections.singletonList((long)j);
				for (int k = j+1; k < 10*i+10; k++) {
					engine.addQuestionAssumption(transactionKey, new Date(), (long)k, parentQuestionIds, null);
				}
			}
		}
		
		// commit the transaction
		engine.commitNetworkActions(transactionKey);
		
		// check that the generated network is correct
		assertEquals(3, engine.getQuestionAssumptionGroups().size());
		assertEquals(30, engine.getProbLists(null, null, null).size());
		for (Entry<Long, List<Float>> entry : engine.getProbLists(null, null, null).entrySet()) {
			for (Float prob : entry.getValue()) {
				assertEquals(0.5f, prob, PROB_ERROR_MARGIN); 
			}
		}
		// check low level consistency too
		assertEquals(3, engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getJunctionTree().getCliques().size());
		for (Clique clique : engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getJunctionTree().getCliques()) {
			assertEquals(10, clique.getNodesList().size());
		}
		for (Separator sep : engine.getDefaultInferenceAlgorithm().getRelatedProbabilisticNetwork().getJunctionTree().getSeparators()) {
			assertEquals(0, sep.getNodes().size());
		}
		
		// assert that initial asset is 1000
		assertEquals(1000, engine.getCash(Long.MAX_VALUE, null, null), PROB_ERROR_MARGIN);
		
		long seed = new Date().getTime();
		Random random = new Random(seed );
		System.out.println("seed = " + seed);
		
		// make trades in all 3 cliques
		for (int i = 0; i < 3; i++) {
			for (int j = 10*i; j < 10*i+9; j++) {
				List<Long> assumptionIds = Collections.singletonList((long)j);
				for (int k = j+1; k < 10*i+10; k++) {
					
					// specify the assumptions of the trade
					List<Integer> assumedStates = Collections.singletonList(0);
					
					// randomly generate trade value accordingly to trade limit
					List<Float> limits = engine.getEditLimits(Long.MAX_VALUE, k, 0, assumptionIds, assumedStates);
					float prob = limits.get(0) + (limits.get(1)-limits.get(0))*random.nextFloat(); // randomly pick a value between the edit limit
					List<Float> newValues = new ArrayList<Float>();
					newValues.add(prob); newValues.add(1-prob);	
					if (Math.abs(limits.get(1) - limits.get(0)) > PROB_ERROR_MARGIN) {
						// only make trade if there can be a trade
						engine.addTrade(null, new Date(), "", Long.MAX_VALUE, k, newValues, assumptionIds, assumedStates, false);
					}
					
					
					// another trade on another state of the same assumption
					assumedStates = Collections.singletonList(1);
					limits = engine.getEditLimits(Long.MAX_VALUE, k, 0, assumptionIds, assumedStates);
					prob = limits.get(0) + (limits.get(1)-limits.get(0))*random.nextFloat(); // randomly pick a value between the edit limit
					newValues = new ArrayList<Float>();
					newValues.add(prob); newValues.add(1-prob);	
					if (Math.abs(limits.get(1) - limits.get(0)) > PROB_ERROR_MARGIN) {
						// only make trade if there can be a trade
						engine.addTrade(null, new Date(), "", Long.MAX_VALUE, k, newValues, assumptionIds, assumedStates, false);
					}
				}
			}
		}
		
		assertTrue(engine.getCash(Long.MAX_VALUE, null, null) > 0);
		
		// balance all questions
		for (int i = 0; i < 30; i++) {
			long before = System.currentTimeMillis();
			engine.doBalanceTrade(null, new Date(), "Balance", Long.MAX_VALUE, i, null, null);
			System.out.println("Time (ms) spent to balance question " + i + " = " + (System.currentTimeMillis() - before));
			List<Float> assetsIfStates = engine.getAssetsIfStates(Long.MAX_VALUE, i, null, null);
			for (Float asset : assetsIfStates) {
				assertEquals(assetsIfStates.get(0), asset, 1);
			}
		}
		
		assertEquals(1000, engine.getCash(Long.MAX_VALUE, null, null), 1);
		
		for (int i = 0; i < 30; i++) {
			List<Float> assetsIfStates = engine.getAssetsIfStates(Long.MAX_VALUE, i, null, null);
			for (Float asset : assetsIfStates) {
				assertEquals(assetsIfStates.get(0), asset, 1);
			}
		}

		
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
		engine.setToAddArcsWithoutReboot(isToAddArcsWithoutReboot);
		engine.setToTraceHistory(isToTraceHistory);
	}
	
	/**
	 * Test method for {@link MarkovEngineImpl#exportState()}
	 * and {@link MarkovEngineImpl#importState(String)}
	 * for 2000 vars and randomly created arcs (max 10 parents)
	 */
	public final void testExportImport2000Vars() {
		int numNodes = 2000;	// total quantity of nodes in the network
		int maxNumStates = 5;	// how many states a node can have at most. The minimum is expected to be 2, but this var should not be set to 2
		int maxNumParents = 10;	// maximum number of parents per node 
		float probAddArcs = .00065f;	// what is the probability to add arcs. The higher, more arcs are likely to be created.
		float probTrade = .05f;	// how many nodes will be traded
		boolean isToMakeAllTrades = true;	// if false, trades will be cancelled if they are taking too much time
		float probAddAssumption = .15f;	// what is the probability to add assumptions in trades. The higher, more assumptions are likely to be used.
		long seed = 1370447826016L;//new Date().getTime();
		Random random = new Random(seed);
		float probTradeBeforeArcs = 0.05f;
		
		
		// backup config
		boolean isToAddArcsOnlyToProbabilisticNetwork = engine.isToAddArcsOnlyToProbabilisticNetwork();
		if (!isToAddArcsOnlyToProbabilisticNetwork) {
			engine.setToAddArcsOnlyToProbabilisticNetwork(true);
		}
		
		System.out.println("[testExportImport2000Vars] Random seed = " + seed);
		
		
		// create the nodes
		long transactionKey = engine.startNetworkActions();
		for (int i = 0; i < numNodes; i++) {
			// random quantity of states: from 2 to ( 2 + (4-1) ) = 5
			engine.addQuestion(transactionKey, new Date(), i, 2+random.nextInt(maxNumStates-2), null);
		}
		engine.commitNetworkActions(transactionKey);
		
		// vetor representing how many parents a node has
		int[] numParentsPerNode = new int[numNodes];
		// initialize vector
		for (int i = 0; i < numParentsPerNode.length; i++) {
			numParentsPerNode[i] = 0;
		}
		
		// this map will store what was traded before adding arcs, for later comparison
		Map<Long, List<Float>> tradedProbs = new HashMap<Long, List<Float>>();
		
		// create arcs randomly
		transactionKey = engine.startNetworkActions();
		for (int i = 0; i < numNodes-1; i++) {
			// generate trade before adding arcs
			if (random.nextFloat() < probTradeBeforeArcs) {
				ProbabilisticNode node = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode(Long.toString(i));
				// the trade to be performed
				List<Float> newValues = new ArrayList<Float>(node.getStatesSize());
				float sumForNormalization = 0f;
				for (int j = 0; j < node.getStatesSize(); j++) {
					newValues.add(random.nextFloat());
					sumForNormalization += newValues.get(j);
				}
				// normalize the newValues
				for (int j = 0; j < newValues.size(); j++) {
					newValues.set(j, newValues.get(j)/sumForNormalization);
				}
				
				// run trade
				engine.addTrade(
							null, 
							new Date(), 
							"P(" + i + ") = " + newValues, 
							0, 
							i, 
							newValues, 
							null, 
							null, 
							true
						);
				tradedProbs.put((long) i, newValues);
			}
			for (int j = i+1; j < numNodes; j++) {
				if (random.nextFloat() > probAddArcs) {
					continue;	// only create arcs with probability probAddArcs
				}
				// check if number of parents reached maximum
				if (numParentsPerNode[j] < maxNumParents) {
					engine.addQuestionAssumption(transactionKey, new Date(), j, Collections.singletonList((long)i), null);
					numParentsPerNode[j]++;
				}
			}
		}
		numParentsPerNode = null;	// try disposing it, because it won't be used anymore
		engine.commitNetworkActions(transactionKey);
		
		
		System.out.println(engine.getNetStatistics().toString());
		System.out.println("seed = " + seed);
		
		// check that the marginals matches traded probs
		for (Entry<Long, List<Float>> entry : engine.getProbLists(null, null, null).entrySet()) {
			List<Float> probBefore = tradedProbs.get(entry.getKey());
			if (probBefore != null) {
				assertEquals(probBefore.size(), entry.getValue().size());
				for (int j = 0; j < probBefore.size(); j++) {
					assertEquals(probBefore.get(j), entry.getValue().get(j), PROB_ERROR_MARGIN);
				}
			}
		}
		
		// make trades on all variables
		for (long questionId = 0; questionId < numNodes; questionId++) {
			ProbabilisticNode node = (ProbabilisticNode) engine.getProbabilisticNetwork().getNode(Long.toString(questionId));
			assertNotNull(node);
			
			if (!node.getParentNodes().isEmpty()) {
				if (random.nextFloat() > probTrade) {
					continue;
				}
			}
			// the trade to be performed
			List<Float> newValues = new ArrayList<Float>(node.getStatesSize());
			float sumForNormalization = 0f;
			for (int i = 0; i < node.getStatesSize(); i++) {
				newValues.add(random.nextFloat());
				sumForNormalization += newValues.get(i);
			}
			// normalize the newValues
			for (int i = 0; i < newValues.size(); i++) {
				newValues.set(i, newValues.get(i)/sumForNormalization);
			}
			
			List<Long> assumptionIds = new ArrayList<Long>(node.getParentNodes().size());
			List<Integer> assumedStates = new ArrayList<Integer>(node.getParentNodes().size());
			
			// randomly select assumptions
			for (INode parent : node.getParentNodes()) {
				// use prob to add assumption
				if (random.nextFloat() < probAddAssumption) {
					assumptionIds.add(Long.parseLong(parent.getName()));
					assumedStates.add(random.nextInt(parent.getStatesSize()));	// random state from 0 to parent.getStatesSize()-1
				}
			}
			
			long time = System.currentTimeMillis();
			engine.addTrade(
					null, 
					new Date(), 
					"P(" + questionId + " | " + assumptionIds + "=" + assumedStates+") = " + newValues, 
					0, 
					questionId, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					true
				);
			if (!isToMakeAllTrades && System.currentTimeMillis() - time >= 1000) {
				// do not add more trades if it is more than 1s
				break;
			}
			if (!isToMakeAllTrades && System.currentTimeMillis() - time >= 100) {
				// trade on less questions if its more than half second
				probTrade = probTrade/2;
			}
		}
		
		// settle some question which has 2 or more parents
		for (int i = 0; i < engine.getProbabilisticNetwork().getNodes().size();i++) {
			Node node = engine.getProbabilisticNetwork().getNodes().get(i);
			if (node.getParentNodes() != null && node.getParentNodes().size() >= 2 && !engine.getResolvedQuestions().containsKey(Long.parseLong(node.getName()))) {
				engine.resolveQuestion(null, new Date(), Long.parseLong(node.getName()), 0);
				i--;
			}
		}
		
		// backup network to check afterwards
		ProbabilisticNetwork cloneNet = null;
		try {
			cloneNet = (ProbabilisticNetwork) engine.getDefaultInferenceAlgorithm().clone(false).getNetwork(); // do not clone asset net
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
			fail();
		}	
		assertNotNull(cloneNet);
		
		engine.addCash(null, new Date(), 1L, 10, "Shall be ignored");
		
		
		System.out.println(engine.getNetStatistics().toString());
		System.out.println("seed = " + seed);
		// store network as a string
		long timeBefore = System.currentTimeMillis();
		String netAsString = engine.exportState();
		System.out.println("Time (ms) to export network = " + (System.currentTimeMillis() - timeBefore));
		System.out.println("seed = " + seed);
		
		assertNotNull(netAsString);
		assertFalse(netAsString.trim().isEmpty());
		
		System.out.println(netAsString);
		
		// load network from the obtained string
		timeBefore = System.currentTimeMillis();
		engine.importState(netAsString);
		System.out.println("Time (ms) to import network = " + (System.currentTimeMillis() - timeBefore));
		System.out.println("seed = " + seed);
		
		// check if the loaded network matches previous network
		assertNotNull(engine.getProbabilisticNetwork());
		assertNotNull(engine.getProbabilisticNetwork().getJunctionTree());
		assertNotNull(engine.getProbabilisticNetwork().getJunctionTree().getCliques());
		assertNotNull(engine.getProbabilisticNetwork().getJunctionTree().getSeparators());
		
		// check number of nodes and arcs
		assertEquals(cloneNet.getNodeCount(), engine.getProbabilisticNetwork().getNodeCount());
		assertEquals(cloneNet.getEdges().size(), engine.getProbabilisticNetwork().getEdges().size());
		
		// check parents and marginals
		for (Node oldNode : cloneNet.getNodes()) {
			Node newNode = engine.getProbabilisticNetwork().getNode(oldNode.getName());
			assertNotNull(oldNode + " not found.", newNode);
			// if number of parents matches and all parents in old node are included in parents of new node, then they are equal
			assertEquals(oldNode.getParentNodes().size(), newNode.getParentNodes().size());
			for (INode oldParent : oldNode.getParentNodes()) {
				assertTrue(oldParent + " is supposed to be a parent of " + newNode, newNode.getParentNodes().contains(oldParent));
			}
			// check that number of states are the same
			assertEquals(oldNode.getName(), oldNode.getStatesSize(), newNode.getStatesSize());
			// at least, check if marginals are the same
			for (int i = 0; i < oldNode.getStatesSize(); i++) {
				assertEquals(oldNode.getName(), ((ProbabilisticNode)oldNode).getMarginalAt(i), ((ProbabilisticNode)newNode).getMarginalAt(i), PROB_ERROR_MARGIN);
			}
		}
		
		// Note: cliques and separators are not mandatory to be precisely equal, because they are built by heuristics
		
		
		// restore backup 
		engine.setToAddArcsOnlyToProbabilisticNetwork(isToAddArcsOnlyToProbabilisticNetwork);
	}
	
}
