/**
 * 
 */
package edu.gmu.ace.daggre;

import java.io.File;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import junit.framework.TestCase;
import unbbayes.io.NetIO;
import unbbayes.prs.Graph;
import unbbayes.prs.INode;
import unbbayes.prs.Network;
import unbbayes.prs.Node;
import unbbayes.prs.bn.IRandomVariable;
import unbbayes.prs.bn.PotentialTable;
import unbbayes.prs.bn.ProbabilisticNetwork;
import unbbayes.prs.bn.inference.extension.AssetAwareInferenceAlgorithm;
import unbbayes.prs.bn.inference.extension.ZeroAssetsException;
import unbbayes.prs.exception.InvalidParentException;
import unbbayes.util.Debug;
import edu.gmu.ace.daggre.MarkovEngineImpl.BalanceTradeNetworkAction;
import edu.gmu.ace.daggre.MarkovEngineImpl.InexistingQuestionException;
import edu.gmu.ace.daggre.MarkovEngineImpl.ProbabilityAndAssetTablesMemento;
import edu.gmu.ace.daggre.ScoreSummary.SummaryContribution;

/**
 * @author Shou Matsumoto
 *
 */
public class MarkovEngineBruteForceTest extends TestCase {

	/** Error margin used when comparing 2 probability values */
	public static final float PROB_ERROR_MARGIN = 0.0001f;
	
	/** How many digits in the fractional portion of the probabilities generated by {@link #generateEdit(Long, int, int, List, List, FivePointTestType)} */
	public static final long PROB_FRACTIONAL_DIGITS = 4;
	
	/** If true, {@link #PROB_FRACTIONAL_DIGITS} will be used to round the edits. */
	private static boolean isToRoundEdit = true;

	/** Error margin used when comparing 2 probability values. {@link CPTBruteForceMarkovEngine} have less precision. */
	public static final float RELAXED_PROB_ERROR_MARGIN = 0.0005f;
	
	/** Error margin used when comparing 2 asset (score) values */
	public static final float ASSET_ERROR_MARGIN = 1f;	

	/** Error margin used when comparing 2 asset (score) values. {@link CPTBruteForceMarkovEngine} have less precision.*/
	public static final float ASSET_ERROR_MARGIN_CPT_BRUTE_FORC = 5f;

	private static final int MAX_USER_NUM = 10;

	private static final double MAX_CASH_TO_ADD = 200;

	/** What questions were added during a void iteration (iteration which is cancelled because a trade is impossible) */
	private List<Integer> addedQuestionsStateSizeInVoidIteration = null;
	
	/** Number of states of questions added during a void iteration (iteration which is cancelled because a trade is impossible) */
	private List<Long> addedQuestionsInVoidIteration = null;

	
	private List<MarkovEngineImpl> engines;

	/** This value indicates how many test iterations (5-point tests) will be performed by default*/
	private static int howManyTradesToTest = 1000;


	private enum FivePointTestType {BELOW_LIMIT, ON_LOWER_LIMIT, BETWEEN_LIMITS, ON_UPPER_LIMIT, ABOVE_LIMIT}; 
	
	/** File names to be used in {@link #testFiles()} and {@link #testFilesWithResolution()}  */
	private static String[] fileNames = {"disconnected.net" , "fullyConnected.net", "fullyDisconnected.net"};
//	private static String[] fileNames = {"disconnected.net" };
//	private static String[] fileNames = {"fullyConnected.net"};
//	private static String[] fileNames = {"fullyDisconnected.net"};

	/** File name to be used in {@link #testFilesWithResolutionSingleEngine()} */
	private static String fileNameToUseInTestFilesWithResolutionSingleEngine = "bn20_tw5_max41_bn20_tw10_max31.net";
	
	/** If true, the 4-points which causes 0 or negative assets in a 5-point test will be run. */
	private static  boolean isToRun5PointTestInStructureTest = true;

	/** {@link #tracer} will pring node names starting with this prefix */
	public static final String NODE_NAME_PREFIX = "N";

	/** This program will enter in a loop at this iteration number. Use with care. Set to negative if you don't want this program to stop at the iteration */
	private static final int iterationToDebug = -154;

	/** this object will group the data to be printed out in {@link #testFilesWithResolution()} */
	private Tracer tracer = null;

	/** Probability to revert trades */
	private static float probToRevert = 0f;

	/** probability to resolve a question */
	private static float probResolve = 0.03f;//0.1f;

	/** probability to balance a trade */
	private static float probToBalance = 0.03f;

	/** probability to add cash */
	private static float probToAddCash = .2f;

	/** If true, some test results and test specifications will be printed out by {@link #tracer} */
	private static boolean isToTrace = true;

	/** This is the probability that if trade is chosen to be {@link FivePointTestType#BETWEEN_LIMITS}, it is very close to the limits */
	private static float probNearEditLimitBias = 0.6f;

	/** This is the probability that {@link #runRandomTest(Network, List, List)} will not choose {@link FivePointTestType#BETWEEN_LIMITS} to trade */
	private static float probTradeOutsideLimit = 0.0f;

	/** If true, cash on edit limit will also be tested and continued, besides of the 5 point test. */
	private boolean isToCheckAssetsPreciselyOnLimit = false;

	/** If true, assets and probabilities before and after {@link #createNode(Long, Network, List, List, List, Collection)} will be compared */
	private boolean isToCompareValuesBeforeAndAfterCreateNode = true;//false;

	/** If true, {@link MarkovEngineImpl#doBalanceTrade(Long, Date, String, long, long, List, List)} of 
	 * {@link #runRandomTestSingleEngine(Network, List)} will balance the question entirely (consider all possible assumptions) */
	private static boolean isToForceBalanceQuestionEntirely = true;

	/** If true, {@link #testFilesWithResolutionSingleEngine()} will call {@link #createNodesInMarkovBlanket(Long, Network, List, List, List, Collection)}
	 * instead of {@link #createNode(Long, Network, List, List, List, Collection)} */
	private static boolean isToAlwaysCreateMarkovBlanket = false;//true;

//	/** Potentials of cliques containing these nodes will be printed in {@link #createNode(Long, Network, List, List, List, Collection)}*/
//	private static long[] nodesToTraceCliquePotentials = null;//{26L,38L};	// null;

	/** If false, consistency assertion in 5 point test will be skipped (this is useful if your objective is only to print test traces) */
	private static boolean isToAssertConsistencyIn5PointTest = true;

	/** Maximum quantity of nodes to be alive in this test. If the quantity of nods reaches this value, no new nodes will be created */
	private static int maxLiveNodes = 10;

	/** This is the index of {@link #engines} to be used as the sole engine to be run in {@link #testFilesWithResolutionSingleEngine()}.
	 * Negative values will be interpreted as "the last element in the list" */
	private static int indexOfEngineToUseInTestFilesWithResolutionSingleEngine = -1;

	/** If false, infinite assets will not be compared */
	private static boolean isToCompareInfiniteExpectedScore = true;

	/** If {@link #generateEdit(Long, int, int, List, List, FivePointTestType, Long, List, List)} generates a big edit,
	 * the edit will not set the probabilities to less than 0+{@link #probDistanceFromDeterministicValues} or 1-{@link #probDistanceFromDeterministicValues}.
	 * @see #minProbDiffOfBigEdit
	 * @see #probBigEdit
	 *  */
	private static float probDistanceFromDeterministicValues = 0.005f;//0f;

	/** This value is considered to be a big change in probability
	 * @see #probBigEdit */
	private static float minProbDiffOfBigEdit = .6f;//0f;

	/** Prob of {@link #generateEdit(Long, int, int, List, List, FivePointTestType, Long, List, List)} to make a change a big change in current prob
	* @see #minProbDiffOfBigEdit */
	private static float probBigEdit = .4f;//0f;


	/** If the program iterated more than this quantity in order to generate the edit, it considers that it could not generate a consistent edit */
	private static int maxIterationToGenerateEdit = 50;
	
	/** If the program iterated more than this quantity in order to choose the question to edit, the test will fail */
	private static int maxIterationToSelectQuestion = 1000/maxLiveNodes;

	/** If true, the cash will be tested after a balance trade */
	private static boolean isToCheckCashAfterBalance = false;

	/** if true, the 1st engine in {@link #engines} will contain all nodes from {@link #fileNames} from the beginning. */
	private static boolean isToSet1stEngineToContainAllNodes = true;

	/** If there are less than this number of questions, questions will not be resolved */
	private static int minAliveQuestionNumber = 0;

	private static long seed = new Date().getTime();
	/** Random number generator, with seed */
	private static Random random = new Random(seed);

	/** 
	 * If true, {@link #do5PointTest(Map, Long, int, List, Long, List, List, FivePointTestType, Map, boolean, Collection, boolean)} will check
	 * whether cash went to negative without error margin, if {@link FivePointTestType} is {@link FivePointTestType#BETWEEN_LIMITS}.
	 */
	private static boolean isStrictlyNonNegativeCash = false;

	/**If true, {@link #generateEdit(Long, int, int, List, List, FivePointTestType, Long, List, List)} will randomize
	 * trades close to the edit limits*/
	private static boolean isToRandomizeTradeCloseToEdit = true;//false;

	/** {@link #generateEdit(Long, int, int, List, List, FivePointTestType, Long, List, List)} will attempt to generate edits
	 * which exceeds or equals to this value of difference compared to current probability */
	private static float probDiffToConsiderSufficientChange = 0.01f;
	
	/** If false, edit limit will be set to the default [0, 1] */
	private static boolean isToCalculateEditLimit = true;

	/** This is just a counter of how many edits went to the branch of edits close to limits */
	private static int numEditsCloseToLimits = 0;

	/** If the number of live questions reaches this number, the test suite will start to resolve questions with probability {@link #probResolve} */
	private static int minNumQuestionToTriggerResolveQuestion = 10; //0;
	
	
	/** Class used to trace data which will be printed out */
	protected class Tracer {
		private int iterationNumber = 0;
		private long userId = -1;
		private float addedCash = 0f;
		private boolean isToResolveQuestion = false;
		private boolean isToRevertTrade = false;
		private List<Long> addedQuestions = new ArrayList<Long>();
		private List<Integer> addedQuestionsStateSize = new ArrayList<Integer>();
		private Long targetQuestion = -1L;
		private int targetState = -1;
		private List<Long> assumptionIds = new ArrayList<Long>();
		private List<Integer> assumedStates = new ArrayList<Integer>();
		private List<Float> editLimit = new ArrayList<Float>();
		private List<Float> targetProb = new ArrayList<Float>();
		private Map<Long, List<Float>> probLists = new HashMap<Long, List<Float>>();
		private Map<Long, List<Float>> probListsAfterResolution = new HashMap<Long, List<Float>>();
		private Map<Long, List<Float>> probListsAfterRevert = new HashMap<Long, List<Float>>();
		private List<UserScoreAndCash> userScoreAndCash = new ArrayList<MarkovEngineBruteForceTest.UserScoreAndCash>();
		private List<UserScoreAndCash> userScoreAndCashAfterResolution = new ArrayList<MarkovEngineBruteForceTest.UserScoreAndCash>();
		private List<UserScoreAndCash> userScoreAndCashAfterRevert = new ArrayList<MarkovEngineBruteForceTest.UserScoreAndCash>();
		private List<TradeSpecification> balanceTradeSpecification = new ArrayList<TradeSpecification>();
		private int resolvedState = -1;
		private int iterationNumberRevertTrade = 0;
		
		/* (non-Javadoc)
		 * @see java.lang.Object#toString()
		 */
		public String toString() {
			// to be used to limit float to 4 faction digits
			DecimalFormat nf = new DecimalFormat();
			nf.setMaximumFractionDigits(4);
			nf.setMinimumFractionDigits(0);
			nf.setGroupingUsed(false);
			
			// separator of iterations
			String out = ((iterationNumber>0)?"###===":"");
			
			out += "\n";
			
//			The first line always shows basic information for the current iteration. And there is one line containing exactly '###===' between iterations.
//			Iteration#
//			How many questions added into the model (0 means no question added)
//			User ID
//			Amount of cash aadding to the user (0 means no adding cash)
//			Transaction ID (0:regular trade; 1:balance trade which can be represented in 1 trade; 2:balance trade which can be represented in 2 trades; 3:balance trade which can be represented in 3 trades; ... so on)
//			Whether or not resolving a question (0: no resolving question; 1: resolving a question)
//			Whether or not we do revert trade in this iteration (0: no revert trade; 1: revert trade)
			out+= iterationNumber + " " + addedQuestions.size() + " " + userId + " " + nf.format(addedCash) + " " 
					+ balanceTradeSpecification.size() + " " + (isToResolveQuestion?"1 ":"0 ") +  (isToRevertTrade?"1":"0");
			
			out += "\n";
			
			// added questions
			if (addedQuestions != null && !addedQuestions.isEmpty()) {
				for (Long questionId : addedQuestions) {
					out += NODE_NAME_PREFIX + questionId + " ";
				}
				out += "\n";
				for (Integer size : addedQuestionsStateSize) {
					out += size + " ";
				}
				out += "\n";
			}
			
			
			// treat normal trades and balance trades equally
			List<TradeSpecification> trades = balanceTradeSpecification;
			if (trades == null || trades.isEmpty()) {
				// normal trade
				if (targetProb.isEmpty()) {
					assertFalse(targetProb.isEmpty());
				}
				trades = (List)Collections.singletonList(new TradeSpecificationImpl(userId, targetQuestion, targetProb, assumptionIds, assumedStates));
			} 
			
			for (TradeSpecification spec : trades) {
				// (target var. and its state, and the last number means how many assumption)
				out += NODE_NAME_PREFIX + spec.getQuestionId() + " " + targetState + " " + spec.getAssumptionIds().size();
				out += "\n";
				
				// assumptions
				if (spec.getAssumptionIds() != null && !spec.getAssumptionIds().isEmpty()) {
					for (Long assumptionId : spec.getAssumptionIds()) {
						out += NODE_NAME_PREFIX+assumptionId + " ";
					}
					out += "\n";
					// assumed states
					for (Integer state : spec.getAssumedStates()) {
						out += state + " ";
					}
					
					out += "\n";
				}
				
				if (balanceTradeSpecification == null || balanceTradeSpecification.isEmpty()) {
					// normal trade needs edit limits
					for (Float limit : editLimit) {
						out += nf.format(limit) + " ";
					}
					out += "\n";
				}
				
				// (target prob. vector)
				if (spec.getProbabilities() == null || spec.getProbabilities().isEmpty()) {
					throw new RuntimeException("Probability was set to empty");
				}
				if (balanceTradeSpecification != null && !balanceTradeSpecification.isEmpty()) {
					// print without using number format (print full precision)
					for (Float prob : spec.getProbabilities()) {
						out += prob + " ";
					}
				} else {
					// print with normal precision (use number format)
					for (Float prob : spec.getProbabilities()) {
						out += nf.format(prob) + " ";
					}
				}
				out += "\n";
			}
			
			// (marginal prob. vector in whatever order)
			for (Long questionId : probLists.keySet()) {
				out += NODE_NAME_PREFIX + questionId + " " + probLists.get(questionId).size();
				out += "\n";
				for (Float prob : probLists.get(questionId)) {
					out += nf.format(prob) + " ";
				}
				out += "\n";
			}
			
			// (all active users scoreEV, cash in whatever order)
			for (UserScoreAndCash scoreCash : userScoreAndCash) {
				out += scoreCash.userId + " " + nf.format(scoreCash.score) + " "+ nf.format(scoreCash.cash);
				out += "\n";
			}
			
			// resolve question
			if (isToResolveQuestion) {
				out += NODE_NAME_PREFIX + targetQuestion;
				out += "\n";
				out += resolvedState;
				out += "\n";
				
				// prob after resolution
				for (Long questionId : probListsAfterResolution.keySet()) {
					out += NODE_NAME_PREFIX + questionId + " " + probListsAfterResolution.get(questionId).size();
					out += "\n";
					for (Float prob : probListsAfterResolution.get(questionId)) {
						out += nf.format(prob) + " ";
					}
					out += "\n";
				}
				// (all active users scoreEV, cash in whatever order)
				for (UserScoreAndCash scoreCash : userScoreAndCashAfterResolution) {
					out += scoreCash.userId + " " + nf.format(scoreCash.score) + " "+ nf.format(scoreCash.cash);
					out += "\n";
				}
			}
			
			// revert trade
			if (isToRevertTrade) {
				out += iterationNumberRevertTrade;
				out += "\n";
				
				// (all active users scoreEV, cash in whatever order)
				for (UserScoreAndCash scoreCash : userScoreAndCashAfterRevert) {
					out += scoreCash.userId + " " + nf.format(scoreCash.score) + " "+ nf.format(scoreCash.cash);
					out += "\n";
				}
				// prob after revert
				for (Long questionId : probListsAfterRevert.keySet()) {
					out += NODE_NAME_PREFIX + questionId + " " + probListsAfterRevert.get(questionId).size();
					out += "\n";
					for (Float prob : probListsAfterRevert.get(questionId)) {
						out += nf.format(prob) + " ";
					}
					out += "\n";
				}
				
			}
			
			return out;
		}

		/**
		 * @return the iterationNumber
		 */
		public int getIterationNumber() {
			return iterationNumber;
		}

		/**
		 * @param iterationNumber the iterationNumber to set
		 */
		public void setIterationNumber(int iterationNumber) {
			this.iterationNumber = iterationNumber;
		}

		/**
		 * @return the userId
		 */
		public long getUserId() {
			return userId;
		}

		/**
		 * @param userId the userId to set
		 */
		public void setUserId(long userId) {
			this.userId = userId;
		}

		/**
		 * @return the addedCash
		 */
		public float getAddedCash() {
			return addedCash;
		}

		/**
		 * @param addedCash the addedCash to set
		 */
		public void setAddedCash(float addedCash) {
			this.addedCash = addedCash;
		}

		/**
		 * @return the isToResolveQuestion
		 */
		public boolean isToResolveQuestion() {
			return isToResolveQuestion;
		}

		/**
		 * @param isToResolveQuestion the isToResolveQuestion to set
		 */
		public void setToResolveQuestion(boolean isToResolveQuestion) {
			this.isToResolveQuestion = isToResolveQuestion;
		}

		/**
		 * @return the isToRevertTrade
		 */
		public boolean isToRevertTrade() {
			return isToRevertTrade;
		}

		/**
		 * @param isToRevertTrade the isToRevertTrade to set
		 */
		public void setToRevertTrade(boolean isToRevertTrade) {
			this.isToRevertTrade = isToRevertTrade;
		}

		/**
		 * @return the addedQuestions
		 */
		public List<Long> getAddedQuestions() {
			return addedQuestions;
		}

		/**
		 * @param addedQuestions the addedQuestions to set
		 */
		public void setAddedQuestions(List<Long> addedQuestions) {
			this.addedQuestions = addedQuestions;
		}

		/**
		 * @return the addedQuestionsStateSize
		 */
		public List<Integer> getAddedQuestionsStateSize() {
			return addedQuestionsStateSize;
		}

		/**
		 * @param addedQuestionsStateSize the addedQuestionsStateSize to set
		 */
		public void setAddedQuestionsStateSize(List<Integer> addedQuestionsStateSize) {
			this.addedQuestionsStateSize = addedQuestionsStateSize;
		}

		/**
		 * @return the targetQuestion
		 */
		public Long getQuestionId() {
			return targetQuestion;
		}

		/**
		 * @param targetQuestion the targetQuestion to set
		 */
		public void setQuestionId(Long targetQuestion) {
			this.targetQuestion = targetQuestion;
		}

		/**
		 * @return the targetState
		 */
		public int getTargetState() {
			return targetState;
		}

		/**
		 * @param targetState the targetState to set
		 */
		public void setTargetState(int targetState) {
			this.targetState = targetState;
		}

		/**
		 * @return the assumptionIds
		 */
		public List<Long> getAssumptionIds() {
			return assumptionIds;
		}

		/**
		 * @param assumptionIds the assumptionIds to set
		 */
		public void setAssumptionIds(List<Long> assumptionIds) {
			this.assumptionIds = assumptionIds;
		}

		/**
		 * @return the assumedStates
		 */
		public List<Integer> getAssumedStates() {
			return assumedStates;
		}

		/**
		 * @param assumedStates the assumedStates to set
		 */
		public void setAssumedStates(List<Integer> assumedStates) {
			this.assumedStates = assumedStates;
		}

		/**
		 * @return the editLimit
		 */
		public List<Float> getEditLimit() {
			return editLimit;
		}

		/**
		 * @param editLimit the editLimit to set
		 */
		public void setEditLimit(List<Float> editLimit) {
			this.editLimit = editLimit;
		}

		/**
		 * @return the targetProb
		 */
		public List<Float> getTargetProb() {
			return targetProb;
		}

		/**
		 * @param targetProb the targetProb to set
		 */
		public void setTargetProb(List<Float> targetProb) {
			this.targetProb = targetProb;
		}

		/**
		 * @return the probLists
		 */
		public Map<Long, List<Float>> getProbLists() {
			return probLists;
		}

		/**
		 * @param probLists the probLists to set
		 */
		public void setProbLists(Map<Long, List<Float>> probLists) {
			this.probLists = probLists;
		}

		/**
		 * @return the probListsAfterResolution
		 */
		public Map<Long, List<Float>> getProbListsAfterResolution() {
			return probListsAfterResolution;
		}

		/**
		 * @param probListsAfterResolution the probListsAfterResolution to set
		 */
		public void setProbListsAfterResolution(
				Map<Long, List<Float>> probListsAfterResolution) {
			this.probListsAfterResolution = probListsAfterResolution;
		}

		/**
		 * @return the probListsAfterRevert
		 */
		public Map<Long, List<Float>> getProbListsAfterRevert() {
			return probListsAfterRevert;
		}

		/**
		 * @param probListsAfterRevert the probListsAfterRevert to set
		 */
		public void setProbListsAfterRevert(Map<Long, List<Float>> probListsAfterRevert) {
			this.probListsAfterRevert = probListsAfterRevert;
		}

		/**
		 * @return the userScoreAndCash
		 */
		public List<UserScoreAndCash> getUserScoreAndCash() {
			return userScoreAndCash;
		}

		/**
		 * @param userScoreAndCash the userScoreAndCash to set
		 */
		public void setUserScoreAndCash(List<UserScoreAndCash> userScoreAndCash) {
			this.userScoreAndCash = userScoreAndCash;
		}

		/**
		 * @return the userScoreAndCashAfterResolution
		 */
		public List<UserScoreAndCash> getUserScoreAndCashAfterResolution() {
			return userScoreAndCashAfterResolution;
		}

		/**
		 * @param userScoreAndCashAfterResolution the userScoreAndCashAfterResolution to set
		 */
		public void setUserScoreAndCashAfterResolution(
				List<UserScoreAndCash> userScoreAndCashAfterResolution) {
			this.userScoreAndCashAfterResolution = userScoreAndCashAfterResolution;
		}

		/**
		 * @return the userScoreAndCashAfterRevert
		 */
		public List<UserScoreAndCash> getUserScoreAndCashAfterRevert() {
			return userScoreAndCashAfterRevert;
		}

		/**
		 * @param userScoreAndCashAfterRevert the userScoreAndCashAfterRevert to set
		 */
		public void setUserScoreAndCashAfterRevert(
				List<UserScoreAndCash> userScoreAndCashAfterRevert) {
			this.userScoreAndCashAfterRevert = userScoreAndCashAfterRevert;
		}

		/**
		 * @return the balanceTradeSpecification
		 */
		public List<TradeSpecification> getBalanceTradeSpecification() {
			return balanceTradeSpecification;
		}

		/**
		 * @param balanceTradeSpecification the balanceTradeSpecification to set
		 */
		public void setBalanceTradeSpecification(
				List<TradeSpecification> balanceTradeSpecification) {
			this.balanceTradeSpecification = balanceTradeSpecification;
		}


		/**
		 * @return the resolvedState
		 */
		public int getResolvedState() {
			return resolvedState;
		}

		/**
		 * @param resolvedState the resolvedState to set
		 */
		public void setResolvedState(int resolvedState) {
			this.resolvedState = resolvedState;
		}

		/**
		 * @return the iterationNumberRevertTrade
		 */
		public int getIterationNumberRevertTrade() {
			return iterationNumberRevertTrade;
		}

		/**
		 * @param iterationNumberRevertTrade the iterationNumberRevertTrade to set
		 */
		public void setIterationNumberRevertTrade(int iterationNumberRevertTrade) {
			this.iterationNumberRevertTrade = iterationNumberRevertTrade;
		}
	}
	
	/** Triple storing user's score and cash */
	protected class UserScoreAndCash {
		public Long userId = -1L;
		public float score = Float.NaN;
		public float cash = Float.NaN;
		public UserScoreAndCash(Long userId, float score, float cash) {
			super();
			this.userId = userId;
			this.score = score;
			this.cash = cash;
		}
	}
	

	
	/**
	 * @param name
	 */
	public MarkovEngineBruteForceTest(String name) {
		super(name);
	}

	/* (non-Javadoc)
	 * @see junit.framework.TestCase#setUp()
	 */
	protected void setUp() throws Exception {
		super.setUp();
		engines = new ArrayList<MarkovEngineImpl>();
		
		engines.add(BruteForceMarkovEngine.getInstance(2f, 100f, 100f));
//		engines.add((MarkovEngineImpl) MarkovEngineImpl.getInstance(2f, 100f, 100f));
//		engines.get(engines.size()-1).setToDeleteResolvedNode(false);
		
		
//		engines.add(CPTBruteForceMarkovEngine.getInstance(2f, 100f, 100f));
		engines.add((MarkovEngineImpl) MarkovEngineImpl.getInstance(2f, 100f, 100f));
//		engines.add((MarkovEngineImpl) MarkovEngineImpl.getInstance(2f, 100f, 100f, false, true));

		
		// add another engine which does not delete nodes when resolved
//		engines.add((MarkovEngineImpl) MarkovEngineImpl.getInstance(2f, 100f, 100f));
//		engines.get(engines.size()-1).setToDeleteResolvedNode(false);
//		engines.get(engines.size()-1).setToObtainProbabilityOfResolvedQuestions(true);
		engines.get(engines.size()-1).setToThrowExceptionOnInvalidAssumptions(true);
		engines.get(engines.size()-1).setToCompareProbOnRebuild(true);
		
		for (MarkovEngineInterface engine : engines) {
			engine.initialize();
		}
	}

	/* (non-Javadoc)
	 * @see junit.framework.TestCase#tearDown()
	 */
	protected void tearDown() throws Exception {
		super.tearDown();
	}
	
	/** Obtains a list of states of the assumptions randomly */
	private List<Integer> getRandomAssumptionStates(List<Long> assumptionIds) {
		List<Integer> ret = new ArrayList<Integer>(assumptionIds.size());
		for (Long questionId : assumptionIds) {
			ret.add((int)(random.nextDouble() * engines.get(0).getProbabilisticNetwork().getNode(questionId.toString()).getStatesSize()));
		}
		return ret;
	}

	/** Obtains a list of assumptions randomly. It uses the 1st engine in {@link #engines} to obtain the nodes and clique structure.
	 * @param uncommittedTransactionKeyMap */
	private List<Long> getRandomAssumptions(Long questionId, Map<MarkovEngineImpl, Long> uncommittedTransactionKeyMap, boolean isToCompareAssumptionGroups) {
		List<List<Long>> questionAssumptionGroups = engines.get(0).getQuestionAssumptionGroups();
		for (List<Long> list : questionAssumptionGroups) {
			// make sure empty cliques are not counted
			assertFalse(questionAssumptionGroups.toString(), list.isEmpty());
		}
		if ( isToCompareAssumptionGroups ) {
			// check that all engines are returning the same assumption groups.
			for (int i = 0; i < engines.size(); i++) {
				if (uncommittedTransactionKeyMap != null && uncommittedTransactionKeyMap.containsKey(engines.get(i))) {
					continue;
				}
				assertEquals(engines.get(i).toString(), questionAssumptionGroups, engines.get(i).getQuestionAssumptionGroups());
			}
		}
		List<List<Long>> groupsNotContainingQuestion = new ArrayList<List<Long>>();
		for (List<Long> group : questionAssumptionGroups) {
			if (!group.contains(questionId)) {
				groupsNotContainingQuestion.add(group);
			}
		}
		questionAssumptionGroups.removeAll(groupsNotContainingQuestion);
		List<Long> randomGroup = questionAssumptionGroups.get((int) (random.nextDouble() * questionAssumptionGroups.size()));
		assertNotNull(randomGroup);
		assertFalse(randomGroup.isEmpty());
		randomGroup.remove(questionId);
		int numToRemove = 0;
		if (randomGroup.size() > 2) {
			//If the clique size is bigger than 3 (including mainNode), the size of assumption set has to be at least 2.
			// how many nodes to remove
			numToRemove = (int)(random.nextDouble() * (randomGroup.size() - 2));
		} else  {	// randomGroup.size() == 0, 1 or 2
			// how many nodes to remove
			numToRemove = (int)(random.nextDouble() * (randomGroup.size()));
		}
		for (int i = 0; i < numToRemove; i++) {
			randomGroup.remove((int)(random.nextDouble() * randomGroup.size()));
		}
		return randomGroup;
	}
	
	/** Obtains a list of questions randomly. How many random given states depends on network size. We choose floor(0.3*numberOfVariablesInTheNet). */
	private List<Long> getRandomQuestionsForConditionalAssets(Long questionToIgnore, List<Long> availableQuestions) {
		
		// quantity of questions to pick from questionsToNumberOfStatesMap
		int quantityOfQuestions = (int) (0.3*availableQuestions.size()); // floor(0.3*numberOfVariablesInTheNet)
		List<Long> ret = new ArrayList<Long>(quantityOfQuestions);	// value to be returned
		
		// do not pick questionToIgnore
		availableQuestions.remove(questionToIgnore);
		
		// pick question from availableQuestions until it fills quantityOfQuestions
		do {
			Long id = availableQuestions.get((int) (random.nextDouble()*availableQuestions.size()));
			ret.add(id);
			availableQuestions.remove(id);
		} while (ret.size() < quantityOfQuestions);
		
		return ret;
	}
	
	/** generate an edit which conforms with one of the 5-point test type 
	 * @param editLimits : if null, [0,1] will be used.
	 * @return null if it iterated for {@value #maxIterationToGenerateEdit} and could not generate consistent edit*/
	private List<Float> generateEdit(Long questionId, int totalNumStates, int stateToConsider, 
			List<Float> editLimits, List<Float> priorProb, FivePointTestType type,
			 Long userId, List<Long> assumptionIds, List<Integer> assumedStates) {
		// if no edit limit was passed, consider [0,1]
		if (editLimits == null) {
			editLimits = new ArrayList<Float>(totalNumStates);
			editLimits.add(0f);
			editLimits.add(1f);
		}
		boolean isCloseToEdit = false;
		List<Float> ret = null;
		double probOfStateToConsider = Double.NaN;
		double sum = 0;
		int iteration = 0;
		for (; iteration < maxIterationToGenerateEdit ; iteration++) {
			isCloseToEdit = false;
			sum = 0;
			switch (type) {
			case BELOW_LIMIT:
				probOfStateToConsider = editLimits.get(0) * 0.8d; 
				break;
			case ON_LOWER_LIMIT:
				probOfStateToConsider = editLimits.get(0);
				break;
			case BETWEEN_LIMITS:
				assertFalse(editLimits.toString() + " cannot have values between them when precision is " + PROB_FRACTIONAL_DIGITS + " fractional digits.", 
						Math.round( (editLimits.get(1) - editLimits.get(0)) * Math.pow(10, PROB_FRACTIONAL_DIGITS) ) <= 1);
				for (; iteration < maxIterationToGenerateEdit; iteration++) {
					isCloseToEdit = false;
					double delta = ((editLimits.get(1) - editLimits.get(0))*random.nextDouble());
					if (random.nextDouble() < getBias()) {
						isCloseToEdit = true;
						// get either a low delta (close to lower bound) or high delta (close to upper bound)
						if (random.nextDouble() < .5) {
							// low delta  
							if (isToRandomizeTradeCloseToEdit) {
								// from 0.5% to 10% of delta
								delta = (editLimits.get(1) - editLimits.get(0))*(.005 + (random.nextDouble()*0.095));
							} else {
								// exactly 0.5% of delta
								delta = (editLimits.get(1) - editLimits.get(0))*.005;
							}
							// fix delta if it is smaller than the round precision
							if (isToRoundEdit() && delta < Math.pow(10, -PROB_FRACTIONAL_DIGITS)) {
								// set min delta as the round precision
								delta = Math.pow(10, -PROB_FRACTIONAL_DIGITS);
							}
						} else {
							// high delta 
							if (isToRandomizeTradeCloseToEdit ) {
								// from 90% to 99.5% of delta
								delta = (editLimits.get(1) - editLimits.get(0))*(.9 + (random.nextDouble()*0.095));
							} else {
								// exactly 99.5% of delta
								delta = (editLimits.get(1) - editLimits.get(0))*.995;
							}
							// fix delta if it is smaller than the round precision
							if (isToRoundEdit() && ((editLimits.get(1) - editLimits.get(0))-delta) < Math.pow(10, -PROB_FRACTIONAL_DIGITS)) {
								// set min delta as the round precision
								delta = (editLimits.get(1) - editLimits.get(0)) - Math.pow(10, -PROB_FRACTIONAL_DIGITS);
							}
						}
						probOfStateToConsider = editLimits.get(0) + delta;
					} else if (random.nextDouble() < probBigEdit) {
						// make the probability to change drastically from current prob
						List<Float> probList = engines.get(engines.size()-1).getProbList(questionId, assumptionIds, assumedStates);
						if (probList.get(stateToConsider) < .5f) {
							// change is greater if we move towards 1
							probOfStateToConsider = probList.get(stateToConsider) + minProbDiffOfBigEdit  + (random.nextDouble()*(1-probList.get(stateToConsider)-minProbDiffOfBigEdit));
						} else {
							// change is greater if we move towards 0
							probOfStateToConsider = probList.get(stateToConsider) - minProbDiffOfBigEdit - (random.nextDouble()*(probList.get(stateToConsider)-minProbDiffOfBigEdit));
						}
					}
					if (isToRoundEdit()) {
						// round to the PROB_FRACTIONAL_DIGITSth digit
						probOfStateToConsider = Math.round(probOfStateToConsider*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS);
					}
					if (probOfStateToConsider >= 1) {
						probOfStateToConsider = 1-probDistanceFromDeterministicValues;
					} else if (probOfStateToConsider <= 0) {
						probOfStateToConsider = probDistanceFromDeterministicValues;
					}
					if (!(probOfStateToConsider <= editLimits.get(0) || probOfStateToConsider >= editLimits.get(1))) {
						break;
					}
				}
				break;
			case ON_UPPER_LIMIT:
				probOfStateToConsider = editLimits.get(1);
				break;
			case ABOVE_LIMIT:
				probOfStateToConsider = editLimits.get(1) + ((1 - editLimits.get(1)) * 0.2f);
				break;
			}
			// check if we are still within the allowed quantity of loops
			if (iteration >= maxIterationToGenerateEdit) {
				return null;
			}
			if (isToRoundEdit()) {
				// round to the PROB_FRACTIONAL_DIGITSth digit
				probOfStateToConsider = Math.round(probOfStateToConsider*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS);
			}
			
			/*
			 * The probability of other states are:
			 * p*(1-P0)/(1-p0)
			 * Where p is the prior probability of the state,
			 * P0 is probOfStateToConsider (posterior prob), and
			 * p0 is the prior probability of stateToConsider 
			 */
			ret = new ArrayList<Float>(totalNumStates);
			for (int i = 0; i < totalNumStates; i++) {
				if (i == stateToConsider) {
					sum += probOfStateToConsider;
					ret.add((float) probOfStateToConsider);
				} else {
					// p*(1-P0)/(1-p0)
					double val = (float) (priorProb.get(i) * (1d - probOfStateToConsider) / (1d - priorProb.get(stateToConsider)));
					if (isToRoundEdit()) {
						// round to the PROB_FRACTIONAL_DIGITSth digit
						val = Math.round(val*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS);
					}
					sum += val;
					ret.add((float) val);
				}
			}
			
			// make sure all edits are between limits
			if (type == FivePointTestType.BETWEEN_LIMITS && !isAllStatesWithinEditLimit(engines.get(engines.size()-1), ret, questionId, userId, assumptionIds, assumedStates)) {
				continue;
			}
			
			// make sure the edit will change the probability considerably
			if (!hasConsiderableProbChange(ret, questionId, assumptionIds, assumedStates)) {
				continue;
			}
			
			// guarantee that the produced values are consistent
			if (!(Math.abs(sum - 1d) > 0.00005)) {
//				if (type == FivePointTestType.BETWEEN_LIMITS
//						&& (ret.get(stateToConsider) <= editLimits.get(0)|| ret.get(stateToConsider) >= editLimits.get(1)) ) {
//					// make sure the change did not make the new values to be come out of the limit
//					continue;
//				}
				break;	
			} else {
				// distribute the difference proportionally.
				double delta = 1d - sum;
				for (int i = 0; i < ret.size(); i++) {
					double val = ret.get(i) + ret.get(i)*delta;
					val = Math.round(val*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS);
					ret.set(i, (float) val);
				}
				// check consistency again
//				if (type == FivePointTestType.BETWEEN_LIMITS
//						&& (ret.get(stateToConsider) <= editLimits.get(0)|| ret.get(stateToConsider) >= editLimits.get(1)) ) {
//					// make sure the change did not make the new values to be come out of the limit
//					continue;
//				}
				// make sure all edits are between limits
				if (type == FivePointTestType.BETWEEN_LIMITS && !isAllStatesWithinEditLimit(engines.get(engines.size()-1), ret, questionId, userId, assumptionIds, assumedStates)) {
					continue;
				}
				// make sure the edit will change the probability considerably
				if (!hasConsiderableProbChange(ret, questionId, assumptionIds, assumedStates)) {
					continue;
				}
				sum = 0d;
				for (Float prob : ret) {
					sum += prob;
				}
				if ((Math.abs(sum - 1d) <= 0.00005)) {
					break;
				} else {
					// proportionally distributing and *rounding* did not solve. 
					// distribute equally to all states
					delta = 1d - sum;
					for (int i = 0; i < ret.size(); i++) {
						double val = ret.get(i) + delta/ret.size();
						val = Math.round(val*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS);
						ret.set(i, (float) val);
					}
					
					// check consistency again
					
					// make sure all edits are between limits
					if (type == FivePointTestType.BETWEEN_LIMITS && !isAllStatesWithinEditLimit(engines.get(engines.size()-1), ret, questionId, userId, assumptionIds, assumedStates)) {
						continue;
					}
					// make sure the edit will change the probability considerably
					if (!hasConsiderableProbChange(ret, questionId, assumptionIds, assumedStates)) {
						continue;
					}
					
					sum = 0d;
					for (Float prob : ret) {
						sum += prob;
					}
					if ((Math.abs(sum - 1d) <= 0.00005)) {
						break;
					} else {
						// distribute equally to all states did not solve either.
						// Just add the difference to smallest value, or subtract the difference from largest value,
						// so that we are more sure that probs don't exceed 1 or be below 0
						delta = 1d - sum;
						int indexToModify = 0;
						for (int i = 1; i < ret.size(); i++) {
							if (delta >= 0 && ret.get(i) < ret.get(indexToModify)) {
								// if delta is positive (sum is less than 1), then add to smallest
								indexToModify = i;
							} else if (delta < 0 && ret.get(i) > ret.get(indexToModify)) {
								// if delta is negative (sum is greater than 1), then add to largest
								indexToModify = i;
							}
							
						}
						// set the probability and round them again
						double val = ret.get(indexToModify) + delta;
						val = Math.round(val*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS);
						ret.set(indexToModify, (float) val);
						
						// check consistency again
						// make sure all edits are between limits
						if (type == FivePointTestType.BETWEEN_LIMITS && !isAllStatesWithinEditLimit(engines.get(engines.size()-1), ret, questionId, userId, assumptionIds, assumedStates)) {
							continue;
						}
						// make sure the edit will change the probability considerably
						if (!hasConsiderableProbChange(ret, questionId, assumptionIds, assumedStates)) {
							continue;
						}
						
						// check sum 
						sum = 0d;
						for (Float prob : ret) {
							sum += prob;
						}
						
						if ((Math.abs(sum - 1d) <= 0.00005)) {
							break;
						} else if (type == FivePointTestType.ON_LOWER_LIMIT || type == FivePointTestType.ON_UPPER_LIMIT) {
							throw new RuntimeException("Could not make " + ret + " sum up to 1");
						}
					}
				}
			}
		}
		
		if (iteration >= maxIterationToGenerateEdit) {
			// it could not generate a consistent edit. The caller shall try another set of inputs
			return null;
		}
		
		if (isCloseToEdit) {
			numEditsCloseToLimits++;
		}
		return ret;
	}
	
	/**
	 * Verifies whether the difference between the edit and current (conditional) probability
	 * is sufficiently large. 
	 * @param edit
	 * @param questionId
	 * @param assumptionIds
	 * @param assumedStates
	 * @return If the difference is greater than {@link MarkovEngineBruteForceTest#probDiffToConsiderSufficientChange},
	 * then returns true. False otherwise.
	 */
	protected boolean hasConsiderableProbChange(List<Float> edit, Long questionId,
			List<Long> assumptionIds, List<Integer> assumedStates) {
		
		List<Float> currentProb = engines.get(engines.size()-1).getProbList(questionId, assumptionIds, assumedStates);
		assertEquals("edit=" + edit + ", question=" + questionId + "assumption="+assumptionIds + ", states=" + assumedStates + ", current prob=" + currentProb, 
				edit.size(), currentProb.size());
		for (int i = 0; i < currentProb.size(); i++) {
			if (Math.abs(edit.get(i)-currentProb.get(i)) < probDiffToConsiderSufficientChange) {
				return false;
			}
		}
		
		return true;
	}

	/**
	 * Returns true if all values in edit are between {@link MarkovEngineInterface#getEditLimits(long, long, int, List, List)}
	 * @param me : the markov engine to be used to calculate the edit limits
	 * @param edit : the probabilities to be tested
	 * @param questionId : ID of the question whose edit will be used for a trade.
	 * @return true if all values in edit are between {@link MarkovEngineInterface#getEditLimits(long, long, int, List, List)}.
	 * False otherwise.
	 */
	protected boolean isAllStatesWithinEditLimit( MarkovEngineImpl me, List<Float> edit, Long questionId, Long userId,
			List<Long> assumptionIds, List<Integer> assumedStates) {
		List<Float> defaultEditLimits = new ArrayList<Float>(2);
		defaultEditLimits.add(0f); defaultEditLimits.add(1f);
		for (int i = 0; i < edit.size(); i++) {
			List<Float> editLimits = defaultEditLimits;
			if (isToCalculateEditLimit) {
				editLimits = me.getEditLimits(userId, questionId, i, assumptionIds, assumedStates);
			} 
			if (edit.get(i) <= editLimits.get(0) || edit.get(i) >= editLimits.get(1)) {
				return false;
			}
		}
		return true;
	}

	/** Execute the actual test given the point of test in the 5-point test 
	 * @param uncommittedTransactionsKeyMap : mapping of engines which were not committed yet, and its respective transaction key */
	private List<Float> do5PointTest(Map<Long,Integer> questionsToNumberOfStatesMap, Long questionId, int stateOfEditLimit, 
			List<Float> editLimits, Long userId, List<Long> assumptionsOfTrade, 
			List<Integer> statesOfAssumption, FivePointTestType pointWithin5PointTest, Map<MarkovEngineImpl, Long> uncommittedTransactionsKeyMap,
			boolean isToConsider1stEngineAsHavingAllNodes, Collection<Long> resolvedQuestions, boolean isToRevertTrade) {
		
		// value to be used in trade
		List<Float> newValues = this.generateEdit(
				questionId, 
				questionsToNumberOfStatesMap.get(questionId), 
				stateOfEditLimit, 
				editLimits, 
				engines.get(engines.size()-1).getProbList(questionId, assumptionsOfTrade, statesOfAssumption), 
				pointWithin5PointTest,
				userId,
				assumptionsOfTrade,
				statesOfAssumption
			);
		if (newValues == null) {
			// could not generate a new value
			throw new IllegalArgumentException("Could not generate edit from these input");
		}
		if (isToAssertConsistencyIn5PointTest ) {
			assertFalse(newValues.isEmpty());
			if (isToRoundEdit()) {
				for (Float prob : newValues) {
					assertEquals(newValues.toString(), 0, 
							((Math.round(prob*Math.pow(10, PROB_FRACTIONAL_DIGITS)) - prob*Math.pow(10, PROB_FRACTIONAL_DIGITS)))/Math.pow(10, PROB_FRACTIONAL_DIGITS), 
							PROB_ERROR_MARGIN);
				}
				float sum = 0;
				for (Float prob : newValues) {
					sum += prob;
				}
				if (Math.abs(1 - sum) > PROB_ERROR_MARGIN) {
					newValues.set(0, newValues.get(0)+(1 - sum));
				}
				assertEquals(newValues.toString(), 1, sum, PROB_ERROR_MARGIN);
			}
		}
		
		
		// we need the current state in order to revert trade, or in order to check if assets of other users were modified
		Map<MarkovEngineImpl, ProbabilityAndAssetTablesMemento> mementos = new HashMap<MarkovEngineImpl, MarkovEngineImpl.ProbabilityAndAssetTablesMemento>();
		
		
		// set up conditions for conditional cash and score
//		List<Long> assumptionIds = this.getRandomQuestionsForConditionalAssets(questionId, new ArrayList<Long>(questionsToNumberOfStatesMap.keySet()));
//		List<Integer> assumedStates = this.getRandomAssumptionStates(assumptionIds);
		List<Long> assumptionIds = assumptionsOfTrade;
		List<Integer> assumedStates = statesOfAssumption;
		
		// compare marginals before the trade
		Map<Long, List<Float>> probBeforeTrade = null;
		if (isToAssertConsistencyIn5PointTest ) {
			probBeforeTrade = engines.get(0).getProbLists(null, null, null);
		}
		// assert that minimum before trade are the same
		float minBeforeTrade = Float.NaN;
		if (isToAssertConsistencyIn5PointTest ) {
			minBeforeTrade = engines.get(0).getCash(userId, null, null);
		}
		float conditionalMinBeforeTrade = Float.NaN;
		if (isToAssertConsistencyIn5PointTest ) {
			conditionalMinBeforeTrade = engines.get(0).getCash(userId, assumptionIds, assumedStates);
		}
		
//		if (pointWithin5PointTest.equals(FivePointTestType.BETWEEN_LIMITS)) {
//			System.out.println("getProbLists(assumptionIds=null,assumedStates=null)="+probBeforeTrade);	
//			System.out.println("getCash(userId="+userId+",assumptionIds=null,assumedStates=null)="+minBeforeTrade);	
//			System.out.println("getCash(userId="+userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+conditionalMinBeforeTrade);	
//		}
		
		// this variable will hold the marginal probabilities after the trade
		Map<Long, List<Float>> marginals = null;
		float minimum = Float.NaN;	// cash after trade
		List<Float> scoreUserQuestionEvStatesAfterTrade = null;	// score per state after trade
		float score = Float.NaN;	// expected score after trade
		Date tradeOccurredWhen = new Date();	// when the trade has occurred
		
		// do trade in all engines
		for (int i = 0; i < engines.size(); i++) {
			
			MarkovEngineImpl engine = engines.get(i);
			
			// this var will be used posteriory for comparison
			List<Float> scoreUserQuestionEvStatesBeforeTrade = null;
			
			// do some consistency check before trade
			if (isToAssertConsistencyIn5PointTest ) {
				if (uncommittedTransactionsKeyMap == null || !uncommittedTransactionsKeyMap.containsKey(engine)) {
					mementos.put(engine, engine.getMemento());
					
					// compare marginals before the trade
					Map<Long, List<Float>> priorProbToCompare = engine.getProbLists(null, null, null);
					assertNotNull(engine.toString(), probBeforeTrade); assertNotNull(engine.toString(), priorProbToCompare);
					if (isToConsider1stEngineAsHavingAllNodes) {
						// 1st engine has more nodes than necessary
						assertTrue(engine.toString() + ", " + probBeforeTrade + ", " +priorProbToCompare, 
								probBeforeTrade.size() >= priorProbToCompare.size());
					} else {
						assertEquals(engine.toString(), probBeforeTrade.size(), priorProbToCompare.size());
					}
					// compare marginals
					for (Long id : priorProbToCompare.keySet()) {
						List<Float> marginal = probBeforeTrade.get(id);
						List<Float> marginalToCompare = priorProbToCompare.get(id);
						if (marginalToCompare != null) {
							assertEquals(engine.toString(), marginal.size(), marginalToCompare.size());
							for (int state = 0; state < marginal.size(); state++) {
								assertEquals(engine.toString() + ", question = " + id + ", state = " + state
										+ ", probBeforeTrade = "+probBeforeTrade + ", priorProbToCompare = "+priorProbToCompare,  
										marginal.get(state), 
										marginalToCompare.get(state), 
										((engine instanceof CPTBruteForceMarkovEngine)?RELAXED_PROB_ERROR_MARGIN:PROB_ERROR_MARGIN)
								);
							}
						} else if (!isToConsider1stEngineAsHavingAllNodes) {
							fail(engine.toString() + ", question = " + id );
						}
					}
				}
				// assert that minimum before trade are the same
				if (uncommittedTransactionsKeyMap == null || !uncommittedTransactionsKeyMap.containsKey(engine)) {
					if (Math.abs(minBeforeTrade - engine.getCash(userId, null, null)) >
					((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
						engines.get(0).getCash(userId, null, null);
						engine.getCash(userId, null, null);
					}
					assertEquals(engine.toString(), minBeforeTrade, engine.getCash(userId, null, null), 
							((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN));
					if (new ArrayList<Long>(resolvedQuestions).removeAll(assumptionIds)) {
						if (engine.isToDeleteResolvedNode()) {
							// if assumption was resolved and engine is set to delete resolved nodes, then it cannot find the assumption
							try {
								float cash = engine.getCash(userId, assumptionIds, assumedStates);
								fail(engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates + ", cash = "+cash);
							} catch (InexistingQuestionException e) {
								// OK
							}
						}
					} else {
						if (Math.abs(conditionalMinBeforeTrade - engine.getCash(userId, assumptionIds, assumedStates))
								> ((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
							engines.get(0).getCash(userId, assumptionIds, assumedStates);
							engine.getCash(userId, assumptionIds, assumedStates);
						}
						assertEquals(
								engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
								conditionalMinBeforeTrade, 
								engine.getCash(userId, assumptionIds, assumedStates), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN));
					}
					
					scoreUserQuestionEvStatesBeforeTrade = engine.scoreUserQuestionEvStates(userId, questionId, assumptionsOfTrade, statesOfAssumption);
					assertEquals(engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
							(int)questionsToNumberOfStatesMap.get(questionId), 
							(int)scoreUserQuestionEvStatesBeforeTrade.size()
					);
				}
				// check if the addTrade will throw exception when a user's cash goes below 0
				if (pointWithin5PointTest == FivePointTestType.ABOVE_LIMIT || pointWithin5PointTest == FivePointTestType.BELOW_LIMIT) {
					try {
						engine.addTrade(
								null, 
								new Date(), 
								"User " + userId + " trades on P(" + questionId + " | " + assumptionsOfTrade + " = " + statesOfAssumption + ") = " + newValues, 
								userId, 
								questionId, 
								newValues, 
								assumptionsOfTrade, 
								statesOfAssumption, 
								false	// do not allow negative assets
						);
						fail(engine.toString() + userId + ", question = " + questionId + " , assumption=" + assumptionIds+ "=" + assumedStates + ", newValues="+newValues);
					} catch (ZeroAssetsException e) {
						// it's expected to throw exception
						assertNotNull(engine.toString() + userId + ", question = " + questionId + " , assumption=" + assumptionIds+ "=" + assumedStates + ", newValues="+newValues,e);
					} catch (IllegalArgumentException e) {
						if (resolvedQuestions.contains(questionId) || new ArrayList<Long>(resolvedQuestions).removeAll(assumptionsOfTrade)) {
							// OK, because question was resolved previously
							continue;
						} else {
							// question was not resolved, but IllegalArgumentException was thrown
							e.printStackTrace();
							fail(e.getMessage() + engine + userId + ", question = " + questionId + " , assumption=" + assumptionIds+ "=" + assumedStates + ", newValues="+newValues);
						}
					}
				}
			}	// end of consistency check
			
			
			
			// get the conditional probability before the trade and compare with newValues to see if this trade is supposed to change something
			boolean hasChangedProb = false;	// this value will be used posteriorly to check if we should verify whether scores have also changed
			List<Float> condProbBeforeTrade = null;
			if (isToAssertConsistencyIn5PointTest ) {
				condProbBeforeTrade = engine.getProbList(questionId, assumptionIds, assumedStates);
				// just to make sure the size of the nodes did not change over time
				assertEquals(newValues + "," + condProbBeforeTrade, newValues.size(), condProbBeforeTrade.size());
				for (int state = 0; state < condProbBeforeTrade.size(); state++) {
					// check that the discrepancy is greater than the error margin
					if (Math.abs(newValues.get(state)-condProbBeforeTrade.get(state)) > PROB_ERROR_MARGIN) {
						hasChangedProb = true;	// mark the probability as changed
						break;
					}
				}
			}
			
			// reuse uncommitted transaction key or open new transaction
			Long transactionKey = null;
			if (uncommittedTransactionsKeyMap != null) {
				transactionKey = uncommittedTransactionsKeyMap.get(engine);
			}
			if (transactionKey == null) {
				transactionKey = engine.startNetworkActions();
				
			}
			List<Float> returnOfTrade = null;
			try {
				returnOfTrade = engine.addTrade(
						transactionKey, 
						tradeOccurredWhen, 
						"User " + userId + " trades on P(" + questionId + " | " + assumptionsOfTrade + " = " + statesOfAssumption + ") = " + newValues , 
						userId, 
						questionId, 
						newValues, 
						assumptionsOfTrade, 
						statesOfAssumption, 
						true		// allow negative, so that we can see that min went to negative
				);
				
			} catch (IllegalArgumentException e) {
				if (resolvedQuestions.contains(questionId) || new ArrayList<Long>(resolvedQuestions).removeAll(assumptionsOfTrade)) {
					// OK, because question was resolved previously
				} else {
					// question was not resolved, but IllegalArgumentException was thrown
					e.printStackTrace();
					fail(e.getMessage() + engine + userId + ", question = " + questionId + " , assumption=" + assumptionIds+ "=" + assumedStates + ", newValues="+newValues);
				}
			}
			if (uncommittedTransactionsKeyMap != null && uncommittedTransactionsKeyMap.containsKey(engine)) {
//				assertTrue( engine.toString() , returnOfTrade == null || returnOfTrade.isEmpty());
				// do not compare results of uncommitted engines here. They will be compared later when all trades are finished
				continue;
			} else {
				if (isToAssertConsistencyIn5PointTest ) {
					if (!(resolvedQuestions.contains(questionId) || new ArrayList<Long>(resolvedQuestions).removeAll(assumptionsOfTrade))) {
						assertFalse( engine.toString() ,  returnOfTrade.isEmpty());
					}
				}
				// commit transaction and compare results
				engine.commitNetworkActions(transactionKey);
//				if (nodesToTraceCliquePotentials != null) {
//					System.out.println("\nTrade: " + "User " + userId + " trades on P(" + questionId + " | " + assumptionsOfTrade + " = " + statesOfAssumption + ") = " + newValues);
//					try { System.out.print("38="+engines.get(0).getProbList(38L, null, null)); } catch (Exception e) {}
//					try { System.out.print("26="+engines.get(0).getProbList(26L, null, null));} catch (Exception e) {}
//					System.out.println();
//				}
			}
			
			// do some consistency check after trade
			if (isToAssertConsistencyIn5PointTest ) {
				scoreUserQuestionEvStatesAfterTrade = engine.scoreUserQuestionEvStates(userId, questionId, assumptionsOfTrade, statesOfAssumption);
				assertEquals(engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
						(int)questionsToNumberOfStatesMap.get(questionId), 
						(int)scoreUserQuestionEvStatesAfterTrade.size()
				);
				if (hasChangedProb) {
					boolean hasChangedScore = false;
					for (int j = 0; j < scoreUserQuestionEvStatesAfterTrade.size(); j++) {
//				float errorMargin = ASSET_ERROR_MARGIN;
						float errorMargin = PROB_ERROR_MARGIN;
						if (pointWithin5PointTest == FivePointTestType.BETWEEN_LIMITS) {
							errorMargin = 0f;
						}
						hasChangedScore = hasChangedScore 
						|| scoreUserQuestionEvStatesBeforeTrade.get(j) - errorMargin > scoreUserQuestionEvStatesAfterTrade.get(j)
						|| scoreUserQuestionEvStatesBeforeTrade.get(j) < scoreUserQuestionEvStatesAfterTrade.get(j)  - errorMargin;
					}
					assertTrue("["+ engines.indexOf(engine) + "]" + engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates
							+ ", old = " + scoreUserQuestionEvStatesBeforeTrade + ", new = " + scoreUserQuestionEvStatesAfterTrade, 
							hasChangedScore
					);
				}
				
				ScoreSummary scoreSummaryOrig= engines.get(0).getScoreSummaryObject(userId, questionId, assumptionIds, assumedStates);
				if (i == 0) {
					continue;
				}
				
				minimum = engines.get(0).getCash(userId, null, null);
				switch (pointWithin5PointTest) {
				case BELOW_LIMIT:
					if (minBeforeTrade > 0f) {
						if (minimum > 0) {
							minimum = engines.get(0).getCash(userId, null, null);
						}
						assertTrue("User=" + userId+"," + engine.toString()+ ", min = " + minimum, minimum < 0 + ASSET_ERROR_MARGIN);
					}
					break;
				case ON_LOWER_LIMIT:
					if (!isToCheckAssetsPreciselyOnLimit) {
						break;
					}
					if (minBeforeTrade > 0f) {
						if (Math.abs(minimum) > ((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
							minimum = engines.get(0).getCash(userId, null, null);
						}
						assertEquals("User=" + userId+"," + engines.indexOf(engine) + "-" +engine.toString(), 0f, minimum, 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN));
					}
					break;
				case BETWEEN_LIMITS:
					if (minBeforeTrade > 0f && isToCalculateEditLimit) {
						if (minimum+ASSET_ERROR_MARGIN < 0 || (isStrictlyNonNegativeCash && minimum < 0)) {
							minimum = engines.get(1).getCash(userId, null, null);
						}
						assertTrue("User=" + userId+"," + engine.toString()+ ", min = " + minimum, minimum >= (isStrictlyNonNegativeCash ?0:-ASSET_ERROR_MARGIN));
					}
					break;
				case ON_UPPER_LIMIT:
					if (!isToCheckAssetsPreciselyOnLimit) {
						break;
					}
					if (minBeforeTrade > 0f) {
						if (Math.abs(minimum) > ((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
							minimum = engines.get(0).getCash(userId, null, null);//engines.get(0).addCash(null, new Date(), userId, -minimum, "")
						}
						assertEquals("User=" + userId+"," + engines.indexOf(engine) + "-" +engine.toString(), 0f, minimum, 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN));
					}
					break;
				case ABOVE_LIMIT:
					if (minBeforeTrade > 0f) {
						if (minimum > 0) {
							minimum = engines.get(0).getCash(userId, null, null);
						}
						assertTrue("User=" + userId+"," + engine.toString()+ ", min = " + minimum, minimum < 0+ASSET_ERROR_MARGIN);
					}
					break;
				}
				
				// b.) marginal probability on individual variable.
				marginals = engines.get(0).getProbLists(null, null, null);
				Map<Long, List<Float>> marginalsToCompare = engine.getProbLists(null, null, null);
				assertNotNull(engine.toString(), marginalsToCompare);
				if (isToConsider1stEngineAsHavingAllNodes) {
					assertTrue(engine.toString() + ", " + marginals + marginalsToCompare, marginals.size() >= marginalsToCompare.size());
				} else {
					assertEquals(engine.toString(), marginals.size(), marginalsToCompare.size());
				}
				
				// compare marginals
				for (Long id : marginals.keySet()) {
					List<Float> marginal = marginals.get(id);
					List<Float> marginalToCompare = marginalsToCompare.get(id);
					if (marginalToCompare != null) {
						assertEquals(engine.toString(), marginal.size(), marginalToCompare.size());
						for (int state = 0; state < marginal.size(); state++) {
							assertEquals(engine.toString() + ", question = " + id + ", state = " + state,  
									marginal.get(state), 
									marginalToCompare.get(state), 
									RELAXED_PROB_ERROR_MARGIN
							);
						}
					} else if (!isToConsider1stEngineAsHavingAllNodes) {
						fail(engine.toString() + ", question = " + id);
					}
				}
				// c.) min-q values after a user confirms a trade.
				if (Math.abs(minimum - engine.getCash(userId, null, null)) >
				((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
					engines.get(0).getCash(userId, null, null);//minimum=engine.getCash(userId, null, null)
					engine.getCash(userId, null, null);//engine.addCash(null, new Date(), userId, -engine.getCash(userId, null, null), "")
				}
				assertEquals(engine.toString(), minimum, engine.getCash(userId, null, null), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN));
				// e.) The expected score.
				score = engine.scoreUserEv(userId, null, null);
				float scoreME0 = engines.get(0).scoreUserEv(userId, null, null);
				
				if (!Float.isInfinite(scoreME0) || isToCompareInfiniteExpectedScore ) {
					assertEquals(
							engine.toString(),
							scoreME0,
							score, 
							((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
					);
				} 
				// f. ) conditional min-q and expected score on randomly given states. How many random given states depends on network size. We choose floor(0.3*numberOfVariablesInTheNet).
				if (Math.abs(engines.get(0).getCash(userId, assumptionIds, assumedStates) - engine.getCash(userId, assumptionIds, assumedStates))
						> ((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
					engines.get(0).getCash(userId, assumptionIds, assumedStates);
					engine.getCash(userId, assumptionIds, assumedStates);
				}
				assertEquals("[" + engines.indexOf(engine) + "]" +
						engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
						engines.get(0).getCash(userId, assumptionIds, assumedStates), 
						engine.getCash(userId, assumptionIds, assumedStates), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
				);
				assertEquals(
						engine.toString() + userId + " , " + assumptionIds + assumedStates, 
						engines.get(0).scoreUserEv(userId, assumptionIds, assumedStates), 
						engine.scoreUserEv(userId, assumptionIds, assumedStates), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
				);
				
				// g.) An userfs asset table is not changed when other user makes edit.
				ProbabilityAndAssetTablesMemento posteriorMemento = engine.getMemento();	// get current status of the engine
				for (AssetAwareInferenceAlgorithm algorithm : mementos.get(engine).getAssetTableMap().keySet()) {
					if (algorithm.getAssetNetwork().getName().equals(Long.toString(userId))) {
						continue;	// do not compare assets of user who made the trade
					}
					// extract the asset tables
					Map<IRandomVariable, PotentialTable> previousAssets  = mementos.get(engine).getAssetTableMap().get(algorithm);
					Map<IRandomVariable, PotentialTable> posteriorAssets = posteriorMemento.getAssetTableMap().get(algorithm);
					// compare assets
					assertEquals(engine.toString(), previousAssets.size(), posteriorAssets.size());
					for (IRandomVariable key : previousAssets.keySet()) {
						PotentialTable previousTable = previousAssets.get(key);
						PotentialTable posteriorTable = posteriorAssets.get(key);
						assertEquals(engine.toString(), previousTable.tableSize(), posteriorTable.tableSize());
						for (int tableIndex = 0; tableIndex < previousTable.tableSize(); tableIndex++) {
							assertEquals(engine.toString(), previousTable.getValue(tableIndex), posteriorTable.getValue(tableIndex));
						}
					}
				}
				
				// b.) marginal probability on individual variable (with assumptions).
				Map<Long, List<Float>> condProbabilities = engines.get(0).getProbLists(null, assumptionIds, assumedStates);
				Map<Long, List<Float>> condProbToCompare = engine.getProbLists(null, assumptionIds, assumedStates);
				assertNotNull(engine.toString(), condProbToCompare);
				if (isToConsider1stEngineAsHavingAllNodes) {
					assertTrue(engine.toString()+"," +condProbabilities+condProbToCompare, condProbabilities.size() >= condProbToCompare.size());
				} else {
					assertEquals(engine.toString(), condProbabilities.size(), condProbToCompare.size());
				}
				
				// compare marginals with assumptions
				for (Long id : condProbabilities.keySet()) {
					List<Float> marginal = condProbabilities.get(id);
					List<Float> marginalToCompare = condProbToCompare.get(id);
					if (marginalToCompare != null) {
						assertEquals(engine.toString(), marginal.size(), marginalToCompare.size());
						for (int state = 0; state < marginal.size(); state++) {
							assertEquals(engine.toString() + ", question = " + id + ", state = " + state,  
									marginal.get(state), 
									marginalToCompare.get(state), 
									RELAXED_PROB_ERROR_MARGIN
							);
						}
					} else if (!isToConsider1stEngineAsHavingAllNodes) {
						fail(engine.toString() + ", question = " + id);
					}
				}
				
				ScoreSummary scoreSummaryObject = engine.getScoreSummaryObject(userId, null, assumptionIds, assumedStates);
				assertNotNull(scoreSummaryObject);
				assertEquals(
						engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
						engines.get(0).getCash(userId, assumptionIds, assumedStates), 
						scoreSummaryObject.getCash(), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
				);
				assertEquals(
						engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
						scoreSummaryOrig.getCash(), 
						scoreSummaryObject.getCash(), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
				);
				assertEquals(
						engine.toString() + userId + " , " + assumptionIds + assumedStates, 
						engines.get(0).scoreUserEv(userId, assumptionIds, assumedStates), 
						scoreSummaryObject.getScoreEV(), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
				);
				assertEquals(
						engine.toString() + userId + " , " + assumptionIds + assumedStates, 
						scoreSummaryOrig.getScoreEV(), 
						scoreSummaryObject.getScoreEV(), 
						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
				);
				float sumOfScoreComponents = 0f;
				if (engine.isToReturnEVComponentsAsScoreSummary()) {
					// the score summary contains clique potential * values in asset tables
					for (SummaryContribution contribution : scoreSummaryObject.getScoreComponents()) {
						sumOfScoreComponents += contribution.getContributionToScoreEV();
					}
					for (SummaryContribution contribution : scoreSummaryObject.getIntersectionScoreComponents()) {
						sumOfScoreComponents += contribution.getContributionToScoreEV();
					}
					assertFalse(engine.toString() + userId + " , " + assumptionIds + assumedStates, Float.isNaN(sumOfScoreComponents));
					assertEquals("["+ engines.indexOf(engine) + "]"+
							engine.toString() + userId + " , " + assumptionIds + assumedStates, 
							scoreSummaryObject.getScoreEV(), 
							sumOfScoreComponents, 
							((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
					);
				} else {
					// the score summary contains expected score per state
					List<Long> tradedQuestions = new ArrayList<Long>(engine.getTradedQuestions(userId)); // extract questions traded by the user
					if (engine.isToDeleteResolvedNode()) {
						tradedQuestions.removeAll(resolvedQuestions);	// ignore resolved questions, because they do not exist
					}
					for (int questionIndex = 0; questionIndex < tradedQuestions.size(); questionIndex++) {
						
						if (engine.isToDeleteResolvedNode() && resolvedQuestions.contains(tradedQuestions.get(questionIndex))) {
							// ignore this question if it was resolved
							continue;
						}
						
						sumOfScoreComponents = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
						
						for (int stateIndex = 0; stateIndex < condProbabilities.get(tradedQuestions.get(questionIndex)).size(); stateIndex++) {
							// assert that all questions in questionsInScoreComponent are in tradedQuestions, in the same ordering 
							List<Long> questionsInScoreComponent = new ArrayList<Long>();
							for (SummaryContribution contrib : scoreSummaryObject.getScoreComponents()) {
								if (!questionsInScoreComponent.contains(contrib.getQuestions().get(0))) {
									questionsInScoreComponent.add(contrib.getQuestions().get(0));
								}
							}
							assertEquals("["+ engines.indexOf(engine) + "]"
									+ engine.toString()+ " , " + assumptionIds + assumedStates
									+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex
									+", tradedQuestions="+tradedQuestions
									+", questionsInScoreComponent="+questionsInScoreComponent, 
									tradedQuestions.size(), questionsInScoreComponent.size());
							for (int j = 0; j < tradedQuestions.size(); j++) {
								assertEquals("["+ engines.indexOf(engine) + "]"
										+ engine.toString()+ " , " + assumptionIds + assumedStates
										+ ", user = " + userId + ", question = " + tradedQuestions.get(j), 
										tradedQuestions.get(j), questionsInScoreComponent.get(j));
							}
							
							// calculate the index in scoreComponent which is related to questionIndex and stateIndex.
							// this is <number of questions handled so far> * <number of states of such questions> + stateIndex
							int scoreComponentIndex = stateIndex;	
							for (int j = 0; j < tradedQuestions.size(); j++) {
								if (j == questionIndex) {
									break;
								}
								// the number of states of a question can be retrieved from the size of an entry in engine.getProbLists
								scoreComponentIndex += condProbabilities.get(tradedQuestions.get(j)).size();
							}
							
							// assert that getScoreComponents is related to current question
							assertEquals("["+ engines.indexOf(engine) + "]"
									+ engine.toString()+ " , " + assumptionIds + assumedStates
									+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
									1, scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getQuestions().size());
							if (!tradedQuestions.get(questionIndex).equals(scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getQuestions().get(0))) {
								engine.getTradedQuestions(userId);
								engine.getScoreSummaryObject(userId, questionId, assumptionIds, assumedStates);
							}
							assertEquals("["+ engines.indexOf(engine) + "]"
									+ engine.toString()+ " , " + assumptionIds + assumedStates
									+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
									tradedQuestions.get(questionIndex),
									scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getQuestions().get(0)
							);
							
							// assert that getScoreComponents is related to current state
							assertEquals("["+ engines.indexOf(engine) + "]"
									+ engine.toString()+ " , " + assumptionIds + assumedStates
									+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
									1, scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getStates().size() );
							assertEquals("["+ engines.indexOf(engine) + "]"
									+ engine.toString() + " , " + assumptionIds + assumedStates
									+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
									stateIndex,
									scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getStates().get(0).intValue()
							);
							
							// multiply marginal (of this state of this question) and expected score of this state of this question
							sumOfScoreComponents += condProbabilities.get(tradedQuestions.get(questionIndex)).get(stateIndex) // marginal
							* scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getContributionToScoreEV();	 // expected
						}
						
						// assert that, for each question, the sum of expected score per state multiplied by its marginal (w/ assumptions) will result in the total expected score
						// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
						assertEquals("["+ engines.indexOf(engine) + "]"
								+ engine.toString()+ " , " + assumptionIds + assumedStates
								+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex), 
								scoreSummaryObject.getScoreEV(), sumOfScoreComponents, ASSET_ERROR_MARGIN);
					}
				}
			}	// end of consistency check after trade
			
			
		}
//		if (pointWithin5PointTest.equals(FivePointTestType.BETWEEN_LIMITS)) {
//			System.out.println("addTrade(occurredWhen="+tradeOccurredWhen+",userId="+userId+",questionId="+questionId+",newValues="+newValues
//					+",assumptionIds="+assumptionsOfTrade+",assumedStates="+statesOfAssumption+")");
//			System.out.println("getProbLists(assumptionIds=null,assumedStates=null)="+marginals);	
//			System.out.println("getCash(userId="+userId+",assumptionIds=null,assumedStates=null)="+minimum);
//			System.out.println("getCash(userId="+userId+",assumptionIds="+assumptionsOfTrade+",assumedStates="+statesOfAssumption+")="+engines.get(0).getCash(userId, assumptionsOfTrade, statesOfAssumption));
//			System.out.println("scoreUserEv(userId="+userId+",assumptionIds=null,assumedStates=null)="+score);
//		}
		// revert trades if this was not supposedly a valid trade
		if (isToRevertTrade) {
			for (MarkovEngineImpl engine : mementos.keySet()) {
				engine.restoreMemento(mementos.get(engine));	// revert last trade
				engine.getExecutedActions().remove(engine.getExecutedActions().size()-1);
			}
		}
		return newValues;
	}
	
	

	/** This is a common portion for each test case, regardless of the network. It assumes the {@link #engines} was filled with nodes and edges already 
	 * @param uncommittedTransactionKeyMap : mapping from engine to transaction key to be used in trades 
	 * @param userIDs */
	private void runTestAssumingInitializedNetwork(Map<Long,Integer> questionsToNumberOfStatesMap, Map<MarkovEngineImpl, Long> uncommittedTransactionKeyMap, List<Long> userIDs) {
		
		assertNotNull(userIDs);
		assertFalse(userIDs.isEmpty());
		
		// make sure initial cash and expected score are 1000
		for (MarkovEngineImpl engine : engines) {
			if (engine.isToUseQValues()) {
				engine.setDefaultInitialAssetTableValue((float) engine.getQValuesFromScore(1000f));
			} else {
				engine.setDefaultInitialAssetTableValue(1000f);
			}
			if (uncommittedTransactionKeyMap.containsKey(engine)) {
				// do not test engines in transactionKeyMap, because they were not committed yet
				continue;
			}
			for (Long userId : userIDs) {
				assertEquals(engine.toString(), 1000f, engine.getCash(userId, null, null), ASSET_ERROR_MARGIN);
				assertEquals(engine.toString(), 1000f, engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
			}
		}
		
		// Make sure getProbLists can list up all available questions, and initial marginal probabilities are the same for all engines
		Map<Long, List<Float>> probabilities = engines.get(0).getProbLists(null, null, null);
		assertEquals(questionsToNumberOfStatesMap.size(), probabilities.keySet().size());
		assertTrue(probabilities + " != " + questionsToNumberOfStatesMap, probabilities.keySet().containsAll(questionsToNumberOfStatesMap.keySet()));
		for (int i = 1; i < engines.size(); i++) {
			if (uncommittedTransactionKeyMap.containsKey(engines.get(i))) {
				// do not test engines in transactionKeyMap, because they were not committed yet
				continue;
			}
			// make sure all engines are retrieving the same questions
			Map<Long, List<Float>> probabilitiesOfOtherEngines = engines.get(i).getProbLists(null, null, null);
			assertEquals(engines.get(i).toString(), probabilities.size(), probabilitiesOfOtherEngines.size());
			assertEquals(engines.get(i).toString(), questionsToNumberOfStatesMap.size(), probabilitiesOfOtherEngines.size());
			// if size is same and contains all, then the lists are equal (regardless of size).
			assertTrue(engines.get(i).toString() + ", " + questionsToNumberOfStatesMap, probabilitiesOfOtherEngines.keySet().containsAll(questionsToNumberOfStatesMap.keySet()));
			// also, make sure that probabilities are initialized equally
			for (Long id : probabilities.keySet()) {
				List<Float> probOfQuestion = probabilities.get(id);
				List<Float> probOfQuestionOfOtherEngines = probabilitiesOfOtherEngines.get(id);
				assertEquals(engines.get(i).toString() + ", ID = " + id, probabilities.size(), probabilitiesOfOtherEngines.size());
				for (int j = 0; j < probOfQuestion.size(); j++) {
					assertEquals(
							engines.get(i).toString() + ", ID = " + id, 
							probOfQuestion.get(j), 
							probOfQuestionOfOtherEngines.get(j), 
							PROB_ERROR_MARGIN
					);
				}
			}
		}
		
		
		// actually run the tests
		for (int iteration = 0; iteration < getHowManyTradesToTest(); iteration++) {
			// (1) Randomly choose one user; 
			long userId = userIDs.get((int) (random.nextDouble() * userIDs.size()));
			
			// (2) Randomly choose one node, 
			List<Long> listOfQuestions = new ArrayList<Long>(questionsToNumberOfStatesMap.keySet());
			Long questionId = listOfQuestions.get((int) (random.nextDouble() * listOfQuestions.size()));
			// state to consider when obtaining the limits of edit
			int stateOfEditLimit = this.getRandomAssumptionStates(Collections.singletonList(questionId)).get(0);
			
			// randomly choose assumption set in the same clique of the node. 
			List<Long> assumptionIds = this.getRandomAssumptions(questionId, uncommittedTransactionKeyMap, true);
			List<Integer> assumedStates = this.getRandomAssumptionStates(assumptionIds);
			
			// obtain the bounds for the 5-point test
			List<Float> editLimits = engines.get(0).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
			for (int i = 1; i < engines.size(); i++) {
				if (uncommittedTransactionKeyMap.containsKey(engines.get(i))) {
					// do not test engines in transactionKeyMap, because they were not committed yet
					continue;
				}
				List<Float> editLimitsOfOtherEngine = engines.get(i).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
				assertEquals(engines.get(i).toString(), editLimits.size(), editLimitsOfOtherEngine.size());
				for (int j = 0; j < editLimits.size(); j++) {
					assertEquals(engines.get(i).toString() + ", user=" + userId + ", question=" + questionId 
							+", state=" + stateOfEditLimit + "," +  assumptionIds + "=" + assumedStates, 
							editLimits.get(j), editLimitsOfOtherEngine.get(j), 
							((engines.get(i) instanceof CPTBruteForceMarkovEngine)?RELAXED_PROB_ERROR_MARGIN:PROB_ERROR_MARGIN));
				}
			}
			
			
			System.out.println("[Iteration " + iteration + ", question=" + questionId + ", state=" + stateOfEditLimit + 
					", limit="+ editLimits + ", user="  +userId + ", assumptions: " + assumptionIds + "=" + assumedStates+"]");
			
			// a.) 5-point min-q values test regarding the edit bound; expect to see corresponding q<1, =1, >1 respectively.
			
			if (uncommittedTransactionKeyMap.isEmpty()) {	// only do these tests if we are not comparing the cases which runs all trades in 1 transaction or multiple transactions
				// (1) the probability close to but smaller than the lower bound; last boolean is true because we want to undo this trade
				this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.BELOW_LIMIT, uncommittedTransactionKeyMap, false, (Set)Collections.emptySet(), true);
				
				// (2) the probability exactly on the lower bound;last boolean is true because we want to undo this trade
				this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_LOWER_LIMIT, uncommittedTransactionKeyMap, false, (Set)Collections.emptySet(), true);
				
				// (4) the probability exactly on the upper bound; last boolean is true because we want to undo this trade
				this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_UPPER_LIMIT, uncommittedTransactionKeyMap, false, (Set)Collections.emptySet(), true);
				
				// (5) the probability close to but bigger than the upper bound; last boolean is true because we want to undo this trade
				this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ABOVE_LIMIT, uncommittedTransactionKeyMap, false, (Set)Collections.emptySet(), true);
			}
			
			// (3) random probability in between the bound; last boolean is false because we don't want to undo this trade
			this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.BETWEEN_LIMITS, uncommittedTransactionKeyMap, false, (Set)Collections.emptySet(), false);
		}	// end of for : iteration
	}


	

	/**
	 * Test method for 
	 * {@link edu.gmu.ace.daggre.MarkovEngineImpl#addTrade(long, java.util.Date, long, long, long, java.util.List, java.util.List, java.util.List, java.util.List, java.lang.Boolean)},
	 * {@link MarkovEngineImpl#getCash(long, List, List)}, 
	 * {@link MarkovEngineImpl#getEditLimits(long, long, int, List, List)},
	 * {@link MarkovEngineImpl#getProbList(long, List, List)},
	 * {@link MarkovEngineImpl#getAssetsIfStates(long, long, List, List)}.
	 * The tested data is equivalent to the one in 
	 * https://docs.google.com/document/d/179XTjD5Edj8xDBvfrAP7aDtvgDJlXbSDQQR-TlM5stw/edit.
	 * <br/>
	 * The DEF net looks like the following.		<br/>
	 * Note: uniform distribution for all nodes.	<br/>
	 * D--->F										<br/>
	 * | 											<br/>
	 * V  											<br/>
	 * E											<br/>
	 * 
	 * The sequence is:<br/>
	 * <br/>
	 * There are two cliques {D, E}, and {D, F}, initial asset tables have q-value as 100 in every cell. <br/>
	 *	Current marginal probabilities are:	<br/>
	 *	Variables    D             E              F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.5 0.5]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Trade-1: Tom would like to make a bet on E=e1, that has current probability as 0.5. First of all, we need to calculate Tomfs edit limit (in this case, there is no assumption):	<br/> 
	 *	Given E=e1, min-q1 = 100	<br/>
	 *	Given E~=e1, min-q2 = 100	<br/>
	 *	From Equation (1), edit interval is [0.005, 0.995].	<br/> 
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55 (current)	<br/>
	 *	<br/>	
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.55 0.45]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Tomfs min-q is 90, at the following 4 min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     1     2     1	<br/>
	 *	     1     2     2	<br/>
	 *	     2     2     1	<br/>
	 *	     2     2     2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-2: Now Tom would like to make another conditional bet on E=e1 given D=d1 (current P(E=e1|D=d1) = 0.55). Again, let us calculate his edit limits first (in this case, we have assumed variable D=d1). And note that Tomfs asset tables are not the initial ones any more, but updated from last trade he did, now:	<br/> 
	 *	Given E=e1, and D=d1, min-q1 = 110	<br/>
	 *	Given E~=e1, and D=d1, min-q2 = 90	<br/>
	 *	From Equation (1), edit interval is [0.005, 0.995]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9 (current)	<br/>
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.725 0.275]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Tomfs min-q is 20, at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     1     2    1	<br/>
	 *	     1     2    2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-3: Joe came and intended to make a bet on E=e1 given D=d2 (current P(E=e1|D=d2) is 0.55). This will be his first edit, so he has initial asset tables before his trade.	<br/> 
	 *	Edit limit:	<br/>
	 *	Given E=e1, and D=d2, min-q1 = 100	<br/>
	 *	Given E~=e1, and D=d2, min-q2 = 100	<br/>
	 *	From Equation (1), edit interval is [0.0055, 0.9955]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4 (current)	<br/> 
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.65 0.35]   [0.5 0.5]	<br/>
	 *	<br/>	
	 *	Joefs min-q is 72.72727272727..., at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     1    1	<br/>
	 *	     2     1    2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-4: Now Amy is interested in changing P(F=f1|D=d1), which is currently 0.5. It will be her first edit, so she also has initial asset tables before the trade.	<br/> 
	 *	Edit limit:	<br/>
	 *	Given F=f1, and D=d1, min-q1 = 100	<br/>
	 *	Given F~=f1, and D=d1, min-q2 = 100	<br/>
 	 *	From Equation (1), edit interval is [0.005, 0.995]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3 (current)	<br/>
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.65 0.35]   [0.4 0.6]	<br/>
	 *	<br/>	
	 *	Amyfs min-q is 60, at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     1     1    1	<br/>
	 *	     1     2    1	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-5: Joe would like to trade again on P(F=f1|D=d2), which is currently 0.5.	<br/> 
	 *	Edit limit:	<br/>
	 *	Given F=f1, and D=d2, min-q1 = 72.727272727	<br/>
	 *	Given F~=f1, and D=d2, min-q2 = 72.727272727	<br/>
	 *	From Equation (1), edit interval is [0.006875, 0.993125]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5 0.5]   [0.65 0.35]   [0.2 0.8]	<br/>
	 *	<br/>	
	 *	Joefs min-q is 14.54545454546, at the following unique min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     1    1	<br/>
	 *	<br/>	
	 *	At this point, the model DEF reaches the status that has the same CPTs as the starting CPTs for the experimental model DEF we used in our AAAI 2012 paper.	<br/> 
	 *	<br/>	
	 *	From now on, we run test cases described in the paper.	<br/> 
	 *	<br/>	
	 *	Trade-6: Eric would like to trade on P(E=e1), which is currently 0.65.	<br/> 
	 *	To decide long or short, S(E=e1) = 10, S(E~=e1)=10, no difference because this will be Ericfs first trade.	<br/>
	 *	Edit limit:	<br/>
	 *	Given F=f1, and D=d2, min-q1 = 100	<br/>
	 *	Given F~=f1, and D=d2, min-q2 = 100	<br/>
	 *	From Equation (1), edit interval is [0.0065, 0.9965]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	Eric1:	P(E=e1) = 0.65 to 0.8 (current)	<br/>
	 *	<br/>	  
	 *	Variables   D              E                   F	<br/> 
	 *	Marginals   [0.5824, 0.4176]   [0.8, 0.2]   [0.2165, 0.7835]	<br/>
	 *	<br/>	
	 *	Ericfs expected score is S=10.1177.	<br/>
	 *	Ericfs min-q is 57.142857, at the following two min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     2    1	<br/>
	 *	     2     2    2	<br/>
	 *	<br/>	
	 *	<br/>	
	 *	Trade-7: Eric would like to make another edit. This time, he is interested on changing P(D=d1|F=f2), which is currently 0.52.	<br/> 
	 *	To decide long or short, S(D=d1, F=f2) = 10.36915, S(D~=d1, F=f2)=9.7669.	<br/>
	 *	Edit limit:	<br/>
	 *	Given D=d1, and F=f2 , min-q1 = 57.142857	<br/>
	 *	Given D~=d1, and F=f2, min-q2 = 57.142857	<br/>
	 *	From Equation (1), edit interval is [0.0091059, 0.9916058]	<br/>
	 *	- Verification successful: after substituting the limits into edit, we do get min-q to be 1.	<br/> 
	 *	<br/>	
	 *	Trading sequence:	<br/> 
	 *	Tom1:	P(E=e1) = 0.5  to 0.55	<br/>
	 *	Tom2:	P(E=e1|D=d1) = 0.55 to 0.9	<br/> 
	 *	Joe1:	P(E=e1|D=d2) = 0.55 to 0.4	<br/> 
	 *	Amy1:	P(F=f1|D=d1) = 0.5 to 0.3	<br/> 
	 *	Joe2:	P(F=f1|D=d2) = 0.5 to 0.1	<br/>
	 *	Eric1:	P(E=e1) = 0.65 to 0.8	<br/> 
	 *	Eric2:	P(D=d1|F=f2) = 0.52 to 0.7 (current)	<br/>
	 *	<br/>	  
	 *	Variables   D                            E                             F	<br/> 
	 *	Marginals   [0.7232, 0.2768]   [0.8509, 0.1491]   [0.2165, 0.7835]	<br/>
	 *	<br/>	
	 *	Ericfs expected score is now 10.31615.	<br/> 
	 *	Ericfs min-q is 35.7393, at the following unique min-states (found by min-asset-propagation):	<br/> 
	 *	     D    E    F	<br/>
	 *	     2     2    2	<br/>
	 *	<br/> 
	 *  The transaction is committed at each trade (trades are not committed at once).
	 */	
	public final void testBasicDEF() {
		
		// crate transaction for generating the DEF network
		assertNotNull(engines);
		assertFalse(engines.isEmpty());
		
		for (MarkovEngineImpl engine : engines) {
			engine.setCurrentCurrencyConstant((float)(10.0/Math.log(100)));
			engine.setCurrentLogBase((float)Math.E);
			if (engine.isToUseQValues()) {
				engine.setDefaultInitialAssetTableValue(1f);
			} else {
				engine.setDefaultInitialAssetTableValue(0f);
			}
		}
		
		long transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		for (MarkovEngineInterface engine : engines) {
			// create nodes D, E, F
			engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
			engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
			engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
			// create edge D->E 
			engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
			// create edge D->F
			engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
			// commit changes
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineInterface engine : engines) {
			try {
				List<Float> newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction " + engine.toString());
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		// check joint probability
		try {
			List<Long> questionIds = new ArrayList<Long>();
			questionIds.add(0x0DL);questionIds.add(0x0EL);questionIds.add(0x0FL);
			List<Integer> states = new ArrayList<Integer>();
			states.add(0); states.add(0); states.add(0); 
			for (int i = 0; i < 8; i++) {
				states.set(0, i%2);	states.set(0, (i/2)%2); states.set(2, (i/4)%2);
				float jointProbability = engines.get(0).getJointProbability(questionIds, states);
				for (int j = 1; j < engines.size(); j++) {
					assertEquals(engines.get(j)+ ", state = "+ i, jointProbability, engines.get(j).getJointProbability(questionIds, states), PROB_ERROR_MARGIN);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		// Let's use ID = 0 for the user Tom 
		Map<String, Long> userNameToIDMap = new HashMap<String, Long>();
		userNameToIDMap.put("Tom", (long)0);
		
		for (MarkovEngineImpl engine : engines) {
			// By default, cash is initialized as 0 (i.e. min-q = 1)
			assertEquals(engine.toString(), 0, engine.getCash(userNameToIDMap.get("Tom"), null, null), ASSET_ERROR_MARGIN);
			assertEquals(engine.toString(), 1, engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		}
		
		for (MarkovEngineImpl engine : engines) {
			// add 100 q-values to new users
			transactionKey = engine.startNetworkActions();
			assertTrue(engine.toString(), engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Tom"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
			engine.commitNetworkActions(transactionKey);
			// check that user's min-q value was changed to the correct value
			assertEquals(engine.toString(), 100, engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(engine.toString(), (engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Tom"), null, null)), ASSET_ERROR_MARGIN);
		}
		
		// Tom bets P(E=e1) = 0.5  to 0.55 (unconditional soft evidence in E)
		
		// check whether probability prior to edit is really 0.5
		List<Float> probList;
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(engine.toString(), 2 , probList.size());
			assertEquals(engine.toString(), 0.5f , probList.get(0) , PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.5f , probList.get(1) , PROB_ERROR_MARGIN);
		}
		
		// edit interval of P(E=e1) should be [0.005, 0.995]
		List<Float> editInterval = null;
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, null, null);
			assertNotNull(engine.toString(), editInterval);
			assertEquals(engine.toString(), 2, editInterval.size());
			assertEquals(engine.toString(), 0.005f, editInterval.get(0), PROB_ERROR_MARGIN );
			assertEquals(engine.toString(), 0.995f, editInterval.get(1), PROB_ERROR_MARGIN );
		}
		
		
		// do edit
		List<Float> newValues = new ArrayList<Float>(2);
		newValues.add(0.55f);		// P(E=e1) = 0.55
		newValues.add(0.45f);		// P(E=e2) = 1 - P(E=e1) = 0.45
		
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size(); i++) {
			assertEquals(engines.get(i).toString(), transactionKey,engines.get(i).startNetworkActions());
		}
		for (MarkovEngineImpl engine : engines) {
			assertEquals(engine.toString(), 2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Tom bets P(E=e1) = 0.5  to 0.55", 
					userNameToIDMap.get("Tom"), 
					0x0E, 	// question E
					newValues,
					null, 	// no assumptions
					null, 	// no states of the assumptions
					false	// do not allow negative
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction" + engine.toString());
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		// check that new marginal of E is [0.55 0.45], and the others have not changed (remains 50%)
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(engine.toString(), 0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.5f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(engine.toString(), 0.55f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.45f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(engine.toString(), 0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.5f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that Tom's min-q is 90 (and the cash is supposedly the log value of 90)
		float minCash = Float.NaN;	 
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null); // null means unconditional cash, which is supposedly the global minimum
			assertEquals(engine.toString(), (engine.getScoreFromQValues(90f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(engine.toString(), 90f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 and any values for D and F, by asserting that cash conditioned to such states are equals to the min
		// d, e, f are always going to be the assumption nodes in this test
		List<Long> assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		List<Integer> assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		float cash;
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue(engine.toString()+" Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue(engine.toString()+" Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check minimal condition of LPE: e2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(1));
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
			cash = engine.getCash(userNameToIDMap.get("Tom"), Collections.singletonList((long)0x0E), Collections.singletonList(0));
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// Tom bets P(E=e1|D=d1) = .55 -> .9
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.55, .45, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0E, assumptionIds, Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.55f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
			assertEquals(0.45f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
			probList = engine.getProbList(0x0E, assumptionIds, Collections.singletonList(1));
			assertEquals(2, probList.size());
			assertEquals(0.55f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
			assertEquals(0.45f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		}
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(E=e1|D=d1) should be [0.005, 0.995]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Tom"), 0x0E, 0, assumptionIds, assumedStates);	// (node == 0x0E && state == 0) == e1
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		

		
		// set P(E=e1|D=d1) = 0.9 and P(E=e2|D=d1) = 0.1
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size(); i++) {
			assertEquals(transactionKey,engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.9f);
		newValues.add(.1f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Tom bets P(E=e1|D=d1) = 0.9", 
					userNameToIDMap.get("Tom"), 
					0x0E, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		
		// check that new marginal of E is [0.725 0.275] (this is expected value), and the others have not changed (remains 50%)
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.725f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.275f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that min-q is 20
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d1, e2 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1 (not min)
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check minimal condition of LPE: d1, e2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(0);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// Let's create user Joe, ID = 1.
		userNameToIDMap.put("Joe", (long) 1);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		for (MarkovEngineImpl engine : engines) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size(); i++) {
			assertEquals(transactionKey,engines.get(i).startNetworkActions());
		}
		for (MarkovEngineImpl engine : engines) {
			assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Joe"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
			engine.commitNetworkActions(transactionKey);
		}
		// check that user's min-q value was changed to the correct value
		for (MarkovEngineImpl engine : engines) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Joe"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Joe"), null, null)), ASSET_ERROR_MARGIN);
		}

		// Joe bets P(E=e1|D=d2) = .55 -> .4
		
		// check whether probability prior to edit is really [e1d1, e2d1, e1d2, e2d2] = [.9, .1, .55, .45]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	// assumption = D
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0E, assumptionIds, Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.9f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d1)
			assertEquals(0.1f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d1)
			probList = engine.getProbList(0x0E, assumptionIds, Collections.singletonList(1));
			assertEquals(2, probList.size());
			assertEquals(0.55f , probList.get(0),PROB_ERROR_MARGIN );	// P(E=e1|D=d2)
			assertEquals(0.45f , probList.get(1),PROB_ERROR_MARGIN );	// P(E=e2|D=d2)
		}
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(E=e1|D=d2) should be [0.0055, 0.9955]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0E, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.0055f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9955f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// set P(E=e1|D=d2) = 0.4 and P(E=e2|D=d2) = 0.6
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size(); i++) {
			assertEquals(transactionKey,engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.4f);
		newValues.add(.6f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Joe bets P(E=e1|D=d2) = 0.4", 
					userNameToIDMap.get("Joe"), 
					0x0E, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction " + engine.getClass());
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		for (MarkovEngineImpl engine : engines) {
			// check that new marginal of E is [0.65 0.35] (this is expected value), and the others have not changed (remains 50%)
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that min-q is 72.727272...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
			assertEquals((engine.getScoreFromQValues(72.727272f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(72.727272f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d2, e1 and any value F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check minimal condition of LPE: d2, e1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0E);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(1);
		assumedStates.add(0);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		// check conditions that do not match LPE
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(0);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0E);
		assumedStates.clear();
		assumedStates.add(1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// Let's create user Amy, ID = 2.
		userNameToIDMap.put("Amy", (long) 2);
		
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		for (MarkovEngineImpl engine : engines) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		for (MarkovEngineImpl engine : engines) {
			assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Amy"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
			engine.commitNetworkActions(transactionKey);
		}
		// check that user's min-q value was changed to the correct value
		for (MarkovEngineImpl engine : engines) {
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Amy"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Amy"), null, null)), ASSET_ERROR_MARGIN);
		}

		// Amy bets P(F=f1|D=d1) = .5 -> .3
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.5, .5, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0F, assumptionIds, Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			probList = engine.getProbList(0x0F, assumptionIds, Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		}
		
		assumedStates.add(0);	// set d1 as assumed state
		
		// edit interval of P(F=f1|D=d1) should be [0.005, 0.995]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0F, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.005f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.995f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		
		// set P(F=f1|D=d1) = 0.3 and P(F=f2|D=d1) = 0.7  
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.3f);
		newValues.add(.7f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Amy bets P(F=f1|D=d1) = 0.3", 
					userNameToIDMap.get("Amy"), 
					0x0F, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.4 .6], and the others have not changed (remains 50%)
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.4f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.6f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that min-q is 60...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d1, f1 and any value E
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check minimal condition of LPE: d1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long)0x0D);
		assumptionIds.add((long)0x0F);
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);
		assumedStates.add(0);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		// check conditions that do not match LPE
		assumedStates.set(0,1);
		assumedStates.set(1,1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumedStates.set(0,0);
		assumedStates.set(1,1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumedStates.set(0,1);
		assumedStates.set(1,0);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0D);
		assumedStates.clear();
		assumedStates.add(1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		assumptionIds.clear();
		assumptionIds.add((long)0x0F);
		assumedStates.clear();
		assumedStates.add(1);
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// Joe bets P(F=f1|D=d2) = .5 -> .1
		
		// check whether probability prior to edit is really [f1d1, f2d1, f1d2, f2d2] = [.3, .7, .5, .5]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0D);	
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0F, assumptionIds, Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.3f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.7f , probList.get(1),PROB_ERROR_MARGIN );
			probList = engine.getProbList(0x0F, assumptionIds, Collections.singletonList(1));
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		}
		
		assumedStates.add(1);	// set d2 as assumed state
		
		// edit interval of P(F=f1|D=d2) should be [0.006875, 0.993125]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Joe"), 0x0F, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.006875f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.993125, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		
		// set P(F=f1|D=d2) = 0.1 and P(F=f2|D=d2) = 0.9
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.1f);
		newValues.add(.9f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Joe bets P(F=f1|D=d2) = 0.1", 
					userNameToIDMap.get("Joe"), 
					0x0F, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		
		// check that new marginal of E is still [0.65 0.35] (this is expected value), F is [.2 .8], and the others have not changed (remains 50%)
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.5f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.5f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.65f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.35f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.2f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.8f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check probabilities given assumptions outside the same clique
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0E, Collections.singletonList((long)0x0F), Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.775f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.225f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, Collections.singletonList((long)0x0F), Collections.singletonList(1));
			assertEquals(2, probList.size());
			assertEquals(0.6188f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.3813f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, Collections.singletonList((long)0x0E), Collections.singletonList(0));
			assertEquals(2, probList.size());
			assertEquals(0.2385f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.7615f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, Collections.singletonList((long)0x0E), Collections.singletonList(1));
			assertEquals(2, probList.size());
			assertEquals(0.1286f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.8714f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that min-q is 14.5454545...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains d2, e1, f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}


		// create new user Eric
		userNameToIDMap.put("Eric", (long) 3);
		// By default, cash is initialized as 0 (i.e. min-q = 1)
		for (MarkovEngineImpl engine : engines) {
			assertEquals(0, (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
			assertEquals(1, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
		}
		
		// add 100 q-values to new users
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		for (MarkovEngineImpl engine : engines) {
			assertTrue(engine.addCash(transactionKey, new Date(), userNameToIDMap.get("Eric"), engine.getScoreFromQValues(100f), "Initialize User's asset to 100"));
			engine.commitNetworkActions(transactionKey);
			// check that user's min-q value was changed to the correct value
			assertEquals(100, (engine.getQValuesFromScore(engine.getCash(userNameToIDMap.get("Eric"), null, null))), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(100)), (engine.getCash(userNameToIDMap.get("Eric"), null, null)), ASSET_ERROR_MARGIN);
		}

		
		// Eric bets P(E=e1) = .65 -> .8
		
		// check whether probability prior to edit is really = [.65, .35]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0E, assumptionIds, null);
			assertEquals(2, probList.size());
			assertEquals(0.65f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.35f , probList.get(1),PROB_ERROR_MARGIN );
		}
		
		
		// edit interval of P(E=e1) should be [0.0065, 0.9965]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0E, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.0065f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9965f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// set P(E=e1) = 0.8 and P(E=e2) = 0.2
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.8f);
		newValues.add(.2f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Eric bets P(E=e1) = 0.8", 
					userNameToIDMap.get("Eric"), 
					0x0E, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		for (MarkovEngineImpl engine : engines) {
			assertEquals(10.1177, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		}
		
		// check that new marginal of E is [0.8 0.2] (this is expected value), F is [0.2165, 0.7835], and D is [0.5824, 0.4176]
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.5824f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.4176f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.8f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.2f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that min-q is 57.142857...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
			assertEquals((engine.getScoreFromQValues(57.142857f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(57.142857f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE contains e2 and any D or F
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		
		
		// Eric bets  P(D=d1|F=f2) = 0.52 -> 0.7
		
		// check whether probability prior to edit is really [d1f2, d2f2] = [.52, .48]
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, assumptionIds, Collections.singletonList(1));
			assertEquals(2, probList.size());
			assertEquals(52f , Math.round(probList.get(0)*100),PROB_ERROR_MARGIN );
			assertEquals(48f , Math.round(probList.get(1)*100),PROB_ERROR_MARGIN );
		}
		
		assumedStates.add(1);	// set f2 as assumed state
		
		// edit interval of P(D=d1|F=f2) should be [0.0091059, 0.9916058]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		
		// set P(D=d1|F=f2) = 0.7 and P(D=d2|F=f2) = 0.3
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.7f);
		newValues.add(.3f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Eric bets P(D=d1|F=f2) = 0.7", 
					userNameToIDMap.get("Eric"), 
					0x0D, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}

		for (MarkovEngineImpl engine : engines) {
			assertEquals(10.31615, engine.scoreUserEv(userNameToIDMap.get("Eric"), null, null), PROB_ERROR_MARGIN);
		}
		
		
		// check that new marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		
		// check that min-q is 35.7393...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE is d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		

		// Eric makes a bet which makes his assets-q to go below 1, but the algorithm does not allow it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		
		// get history before transaction, so that we can make sure new transaction is not added into history
		for (MarkovEngineImpl engine : engines) {
			List<QuestionEvent> questionHistory = engine.getQuestionHistory(0x0DL, null, null);
			
			// check that final min-q of Tom is 20
			minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
			
			// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
			transactionKey = engine.startNetworkActions();
			newValues = new ArrayList<Float>();
			newValues.add(editInterval.get(0)/10);
			newValues.add(1-(editInterval.get(0)/10));
			assertNull(engine.addTrade(
					transactionKey, 
					new Date(), 
					"Eric bets P(D=d1|F=f2) = 0.7", 
					userNameToIDMap.get("Eric"), 
					0x0D, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					false	// do not allow negative assets
			));
			// this is supposedly going to commit empty transaction
			engine.commitNetworkActions(transactionKey);
			// make sure history was not changed
			assertEquals(questionHistory, engine.getQuestionHistory(0x0DL, null, null));
		}

		// check that final min-q of Tom is 20
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
			assertEquals(20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals((engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		
		// check that marginals have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		
		// check that min-q has not changed
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE has not changed - still d2, e2 and f2
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, e1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		

		// add question disconnected question C
		for (MarkovEngineImpl engine : engines) {
			transactionKey = engine.startNetworkActions();
			engine.addQuestion(transactionKey, new Date(), (long)0x0C, 2, null);
			engine.commitNetworkActions(transactionKey);
		}
		

		
		// check that probabilities and assets related to old node did not change
		
		// check that final marginal of E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(engine.toString(), 0.7232f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.2768f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(engine.toString(), 0.8509f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.1491f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(engine.toString(), 0.2165f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// set assumptions to D,E,F, so that we can use it to calculate conditional min-q (in order to test consistency of LPE)
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0E);		// 2nd node is E; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		// init list of states of the assumptions
		assumedStates = new ArrayList<Integer>();	
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// e1
		assumedStates.add(0);	// f1
		
		// check that final min-q of Tom is 20
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Tom"), null, null);
			assertEquals(engine.toString(), 20f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
			assertEquals(engine.toString(), (engine.getScoreFromQValues(20f)), (minCash), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Tom contains d1, e2 and any value F
		
		// check combination d1, e1, f1 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2 (not min)
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d2, e1, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2 (not min)
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Tom"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		
		// check that min-q of Amy is 60...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
			assertEquals((engine.getScoreFromQValues(60f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(60f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Amy contains d1, f1 and any value E
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		
		// check that min-q of Joe is 14.5454545...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Joe"), null, null);
			assertEquals((engine.getScoreFromQValues(14.5454545f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(14.5454545f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE of Joe contains d2, e1, f1
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Joe"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check that final min-q of Eric is 35.7393...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
			assertEquals((engine.getScoreFromQValues(35.7393f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(35.7393f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that final LPE of Eric is d2, e2 and f2
		
		// check combination d1, e1, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, e2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// e1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, e2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// e2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Eric"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		
		
		// Amy bets P(C=c1) = .5 -> .05
		
		// check whether probability of C prior to edit is really [.5, .5] no matter what combination of other nodes
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0C, null, null);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			probList = engine.getProbList(0x0C, null, null);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			probList = engine.getProbList(0x0C, null, null);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			assumptionIds = new ArrayList<Long>(3);	assumedStates = new ArrayList<Integer>(3);
			assumptionIds.add((long)0x0D);	assumptionIds.add((long)0x0E);
			assumedStates.add((random.nextDouble() < .5)?1:0); assumedStates.add((random.nextDouble() < .5)?1:0);
			probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			assumptionIds.set(0, (long)0x0D);	assumptionIds.set(1, (long)0x0F);
			assumedStates.set(0, (random.nextDouble() < .5)?1:0); assumedStates.set(1, (random.nextDouble() < .5)?1:0);
			probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			assumptionIds.set(0, (long)0x0E);	assumptionIds.set(1, (long)0x0F);
			assumedStates.set(0, (random.nextDouble() < .5)?1:0); assumedStates.set(1, (random.nextDouble() < .5)?1:0);
			probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
			assumptionIds.set(0, (long)0x0E);	assumptionIds.set(1, (long)0x0F); assumptionIds.add((long)0x0D); 
			assumedStates.set(0, (random.nextDouble() < .5)?1:0); assumedStates.set(1, (random.nextDouble() < .5)?1:0); assumedStates.add((random.nextDouble() < .5)?1:0);
			probList = engine.getProbList(0x0C, assumptionIds, assumedStates);
			assertEquals(2, probList.size());
			assertEquals(0.5f , probList.get(0),PROB_ERROR_MARGIN );
			assertEquals(0.5f , probList.get(1),PROB_ERROR_MARGIN );
		}
		
		// edit interval of P(C=c1) should be [0.0083, 0.9916667]
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Amy"), 0x0C, 0, null, null);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(engine.toString(), 0.0083f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(engine.toString(), 0.9916667f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		// set P(C=c1) = 0.05 and   P(C=c1) = 0.95
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(.05f);
		newValues.add(.95f);
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Amy bets P(C=c1) = 0.05", 
					userNameToIDMap.get("Amy"), 
					0x0C, 
					newValues, 
					null, 
					null, 
					false
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		
		// check that marginals of C is [.05,.95], and others have not changed: E is [0.8509, 0.1491], F is  [0.2165, 0.7835], and D is [0.7232, 0.2768]
		for (MarkovEngineImpl engine : engines) {
			probList = engine.getProbList(0x0C, null, null);
			assertEquals(0.05f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.95f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0D, null, null);
			assertEquals(0.7232f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.2768f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0E, null, null);
			assertEquals(0.8509f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.1491f, probList.get(1), PROB_ERROR_MARGIN);
			probList = engine.getProbList(0x0F, null, null);
			assertEquals(0.2165f, probList.get(0), PROB_ERROR_MARGIN);
			assertEquals(0.7835f, probList.get(1), PROB_ERROR_MARGIN);
		}
		
		// check that min-q is 6...
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Amy"), null, null);
			assertEquals((engine.getScoreFromQValues(6f)), (minCash), ASSET_ERROR_MARGIN);
			assertEquals(6f, (engine.getQValuesFromScore(minCash)), ASSET_ERROR_MARGIN);
		}
		
		// check that new LPE of Amy is independent of E
		for (MarkovEngineImpl engine : engines) {
			assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(0)), ASSET_ERROR_MARGIN);
			assertEquals(minCash, engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList(0x0EL), Collections.singletonList(1)), ASSET_ERROR_MARGIN);
		}
		
		// check that LPE is d1 c1 f1
		assumptionIds = new ArrayList<Long>();
		assumptionIds.add((long) 0x0D);		// 1st node is D; assumedStates must follow this order
		assumptionIds.add((long) 0x0C);		// 2nd node is C; assumedStates must follow this order
		assumptionIds.add((long) 0x0F);		// 3rd node is F; assumedStates must follow this order
		
		// check combination d1, c1, f1
		assumedStates = new ArrayList<Integer>();
		assumedStates.add(0);	// d1
		assumedStates.add(0);	// c1
		assumedStates.add(0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
		}
		
		// check combination d1, c1, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {		
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d1, c2, f1
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d1, c2, f2
		assumedStates.set(0, 0);	// d1
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, c1, f1 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check combination d2, c1, f2 
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 0);	// c1
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, c2, f1
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 0);	// f1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}

		// check combination d2, c2, f2
		assumedStates.set(0, 1);	// d2
		assumedStates.set(1, 1);	// c2
		assumedStates.set(2, 1);	// f2
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), assumptionIds, assumedStates);
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		
		// check incomplete condition of LPE: c1
		for (MarkovEngineImpl engine : engines) {
			cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(0));
			assertEquals(minCash, cash, ASSET_ERROR_MARGIN);
			cash = engine.getCash(userNameToIDMap.get("Amy"), Collections.singletonList((long)0x0C), Collections.singletonList(1));
			assertTrue("Obtained cash = " + cash, minCash < cash);
		}
		

		// Eric makes a bet which makes his assets-q to go below 1, and the algorithm allows it
		
		// extract allowed interval of P(D=d1|F=f2), so that we can an edit incompatible with such interval
		assumptionIds = new ArrayList<Long>();		
		assumedStates = new ArrayList<Integer>();
		assumptionIds.add((long) 0x0F);	
		assumedStates.add(1);	// set f2 as assumed state
		for (MarkovEngineImpl engine : engines) {
			editInterval = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0D, 0, assumptionIds, assumedStates);
			assertNotNull(editInterval);
			assertEquals(2, editInterval.size());
			assertEquals(0.0091059f, editInterval.get(0) ,PROB_ERROR_MARGIN);
			assertEquals(0.9916058f, editInterval.get(1) ,PROB_ERROR_MARGIN);
		}
		
		
		List<Float> editLimits;
		for (MarkovEngineImpl engine : engines) {
			editLimits = engine.getEditLimits(userNameToIDMap.get("Eric"), 0x0DL, 0, assumptionIds, assumedStates);
			assertEquals(2, editLimits.size());
			assertTrue(editLimits.toString() , editLimits.get(0) > 0);
			assertTrue(editLimits.toString() , editLimits.get(0) < 1);
			assertTrue(editLimits.toString() , editLimits.get(1) > 0);
			assertTrue(editLimits.toString() , editLimits.get(1) < 1);
			assertTrue(editLimits.toString() , editLimits.get(0) < 0.7 && 0.7 < editLimits.get(1));
		}
		// check joint probability
		try {
			List<Long> questionIds = new ArrayList<Long>();
			questionIds.add(0x0DL);questionIds.add(0x0EL);questionIds.add(0x0FL);
			List<Integer> states = new ArrayList<Integer>();
			states.add(0); states.add(0); states.add(0); 
			for (int i = 0; i < 8; i++) {
				states.set(0, i%2);	states.set(0, (i/2)%2); states.set(2, (i/4)%2);
				float jointProbability = engines.get(0).getJointProbability(questionIds, states);
				for (int j = 1; j < engines.size(); j++) {
					assertEquals(engines.get(j)+ ", state = "+ i, jointProbability, engines.get(j).getJointProbability(questionIds, states), PROB_ERROR_MARGIN);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		// set P(D=d1|F=f2) to a value lower (1/10) than the lower bound of edit interval
		transactionKey = engines.get(0).startNetworkActions();
		for (int i = 1; i < engines.size() ; i++) {
			assertEquals(engines.get(i).toString() ,transactionKey, engines.get(i).startNetworkActions());
		}
		newValues = new ArrayList<Float>();
		newValues.add(editInterval.get(0)/10);
		newValues.add(1-(editInterval.get(0)/10));
		for (MarkovEngineImpl engine : engines) {
			assertEquals(2, engine.addTrade(
					transactionKey, 
					new Date(), 
					"Eric bets P(D=d1|F=f2) = 0.7", 
					userNameToIDMap.get("Eric"), 
					0x0D, 
					newValues, 
					assumptionIds, 
					assumedStates, 
					true	// allow negative assets
			).size());
			engine.commitNetworkActions(transactionKey);
		}
		
		// cannot reuse same transaction key
		for (MarkovEngineImpl engine : engines) {
			try {
				newValues = new ArrayList<Float>(2);
				newValues.add(.9f);	newValues.add(.1f);
				engine.addTrade(transactionKey, new Date(), "To fail", Long.MAX_VALUE, (long)0x0D, newValues, null, null, false);
				fail("Should not allow to use commited transaction");
			} catch (IllegalArgumentException e) {
				assertNotNull(e);
			}
		}
		
		
		// check that cash is smaller or equal to 0
		for (MarkovEngineImpl engine : engines) {
			minCash = engine.getCash(userNameToIDMap.get("Eric"), null, null);
			assertTrue("Obtained unexpected cash = " + minCash, minCash <= 0);
		}
		// check joint probability
		try {
			List<Long> questionIds = new ArrayList<Long>();
			questionIds.add(0x0DL);questionIds.add(0x0EL);questionIds.add(0x0FL);
			List<Integer> states = new ArrayList<Integer>();
			states.add(0); states.add(0); states.add(0); 
			for (int i = 0; i < 8; i++) {
				states.set(0, i%2);	states.set(0, (i/2)%2); states.set(2, (i/4)%2);
				float jointProbability = engines.get(0).getJointProbability(questionIds, states);
				for (int j = 1; j < engines.size(); j++) {
					assertEquals(engines.get(j)+ ", state = "+ i, jointProbability, engines.get(j).getJointProbability(questionIds, states), PROB_ERROR_MARGIN);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
		// check min assets
		{
			assumptionIds = new ArrayList<Long>();
			assumptionIds.add(0x0DL);assumptionIds.add(0x0EL);assumptionIds.add(0x0FL);
			assumptionIds.add(0x0CL);
			assumedStates = new ArrayList<Integer>();
			assumedStates.add(0);assumedStates.add(0);assumedStates.add(0);
			assumedStates.add(0);
			for (int i = 0; i < 48; i++) {
				assumedStates.set(0,(i/1)%2);assumedStates.set(1,(i/2)%2);assumedStates.set(2,(i/4)%2);
				assumedStates.set(3,(i/8)%2);
				for (String user : userNameToIDMap.keySet()) {
					minCash = engines.get(0).getCash(userNameToIDMap.get(user), assumptionIds, assumedStates);
					for (int j = 1; j < engines.size(); j++) {
						assertEquals(engines.get(j) + ", index="+i + ", user=" + user, 
								minCash, engines.get(j).getCash(userNameToIDMap.get(user), assumptionIds, assumedStates), ASSET_ERROR_MARGIN);
					}
				}
			}
		} 
		
		
	}
	

	/**
	 * Performs the same of {@link #testFiles()}, but methods like
	 * {@link MarkovEngineInterface#addTrade(Long, Date, String, long, long, List, List, List, boolean)},
	 * {@link MarkovEngineInterface#addQuestionAssumption(Long, Date, long, List, List)},
	 * {@link MarkovEngineInterface#addCash(Long, Date, long, float, String)}
	 * {@link MarkovEngineInterface#resolveQuestion(Long, Date, long, int)}
	 * {@link MarkovEngineInterface#doBalanceTrade(Long, Date, String, long, long, List, List)}
	 * are also called.
	 */
	public final void testFilesWithResolution() {
		
		// most basic assertion
		assertNotNull(engines);
		assertFalse(engines.isEmpty());
		
		assertNotNull(getFileNames());
		assertFalse(getFileNames().length <= 0);
		
		NetIO io = new NetIO();
		
		Network network = null;
		for (String fileName : getFileNames()) {
			System.out.println("\n\n# Reading file " + fileName+", seed = " + seed +"\n\n");
			try {
				network = (Network) io.load(new File(getClass().getClassLoader().getResource(fileName).getFile()));
			} catch (Exception e) {
				e.printStackTrace();
				fail(e.getMessage());
			} 
			assertNotNull(network);
			
			// initialize all engines, so that they start with no garbage data
			for (MarkovEngineImpl engine : engines) {
				engine.initialize();
			}
			
			// these are the engines which will not have nodes randomly inserted (in order to compare with engines with nodes randomly inserted)
//			List<MarkovEngineInterface> enginesToStartWithAllNodes = (List)Collections.singletonList(engines.get(0));
			List<MarkovEngineInterface> enginesToStartWithAllNodes = new ArrayList<MarkovEngineInterface>(1);
			if (isToSet1stEngineToContainAllNodes) {
				enginesToStartWithAllNodes.add(engines.get(0));
			} else {
				for (MarkovEngineInterface me : engines) {
					if (me instanceof BruteForceMarkovEngine) {
						enginesToStartWithAllNodes.add(me);
					}
				}
			}
			
			for (MarkovEngineInterface engine : enginesToStartWithAllNodes) {
				long transactionKey = engine.startNetworkActions();
				// create nodes
				for (Node node : network.getNodes()) {
					engine.addQuestion(transactionKey, new Date(), Long.parseLong(node.getName()), node.getStatesSize(), null); // assume uniform distribution for all nodes 
				}
				// create edges 
				for (Node node : network.getNodes()) {
					List<Long> parentIds = new ArrayList<Long>();
					for (Node parent : node.getParents()) {
						parentIds.add(Long.parseLong(parent.getName()));
					}
					if (parentIds.isEmpty() && random.nextDouble() <= .5) {
						parentIds = null;
					}
					engine.addQuestionAssumption(transactionKey, new Date(), Long.parseLong(node.getName()), parentIds, null);	// cpd == null -> linear distro
				}
				// commit changes
				engine.commitNetworkActions(transactionKey);
			}
			
			this.runRandomTest(network, new ArrayList<Long>(), enginesToStartWithAllNodes);
		}
	}
	
	/**
	 * Performs the same of {@link #testFilesWithResolution(), but only
	 * 1 ME will be run (hence, no comparison is performed).
	 */
	public final void testFilesWithResolutionSingleEngine() {
		isToAssertConsistencyIn5PointTest = false;
		
		// most basic assertion
		assertNotNull(engines);
		assertFalse(engines.isEmpty());
		
		// force it to use only 1 engine
		MarkovEngineImpl engineToUse = null;
		if (indexOfEngineToUseInTestFilesWithResolutionSingleEngine >= 0) {
			engineToUse = engines.get(indexOfEngineToUseInTestFilesWithResolutionSingleEngine);
		} else {
			engineToUse = engines.get(engines.size()-1);
		}
		assertNotNull(engineToUse);
		engines.clear();
		engines.add(engineToUse);
		
		// make sure the files to test are OK
		assertNotNull(fileNameToUseInTestFilesWithResolutionSingleEngine);
		assertFalse(fileNameToUseInTestFilesWithResolutionSingleEngine.trim().length() <= 0);
		
		NetIO io = new NetIO();
		
		Network network = null;
		System.out.println("\n\n# Reading file " + fileNameToUseInTestFilesWithResolutionSingleEngine +", seed = " + seed +"\n\n");
		try {
			network = (Network) io.load(new File(getClass().getClassLoader().getResource(fileNameToUseInTestFilesWithResolutionSingleEngine).getFile()));
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		} 
		assertNotNull(network);
		
		// initialize all engines, so that they start with no garbage data
		engines.get(0).initialize();
		
		
		this.runRandomTestSingleEngine(network, new ArrayList<Long>());
	}
	
	/**
	 * Performs the same of {@link #runRandomTest(Network, List, List)},
	 * but it runs on only 1 engine, and does not perform comparison.
	 * @param network : the final network structure. This method will gradually
	 * add nodes and edges to the markov engines until the network structure in 
	 * the markov engine reaches this structure.
	 * @param userIDs : currently created users
	 */
	private void runRandomTestSingleEngine(Network network, List<Long> userIDs) {
		assertNotNull(engines);
		assertEquals(1,engines.size());
		engines.get(0).setToForceBalanceQuestionEntirely(isToForceBalanceQuestionEntirely);
		
		// this list stores which nodes were not created yet
		List<INode> nodesToCreate = new ArrayList<INode>(network.getNodes());
		
		// this variable will contain questions which were already resolved
		Set<Long> resolvedQuestions = new HashSet<Long>();
		
		assertNotNull(userIDs);
		
		Date dateTimeBeforeTrades = new Date();	// this variable will be used to revert trades
		int iterationToRevert = 0;
		
		// this boolean var will become true if the number of live questions is greater than minNumQuestionToTriggerResolveQuestion
		boolean isToResolveQuestion = false;	// if false, do not resolve question
		
		
		// generate questionsToNumberOfStatesMap, which stores how many states a question has
		Map<Long, Integer> questionsToNumberOfStatesMap = new HashMap<Long, Integer>();
		// track all possible questions in this list, before entering into the iterations.
		List<Long> listOfQuestions = new ArrayList<Long>(network.getNodeCount());
		for (Node node : network.getNodes()) {
			Long id = Long.parseLong(node.getName());
			listOfQuestions.add(id);
			questionsToNumberOfStatesMap.put(id, node.getStatesSize());
		}
		
		// actually run the tests (start iteration);
		for (int iteration = 0; iteration < getHowManyTradesToTest(); iteration++) {
//			if (nodesToTraceCliquePotentials != null) {
//				System.out.println("\nIteration " + iteration);
//			}
			// this is just a counter of how many iterations went to the branch of edits close to the bound
			int numIterationsCloseToBoundsBeforeIteration = numEditsCloseToLimits;
			if (iteration == iterationToDebug) {
				Debug.setDebug(true);
			}
			if (isToTrace()) {
				tracer = new Tracer();
				tracer.setIterationNumberRevertTrade(iterationToRevert);
				tracer.setIterationNumber(iteration);
				if (this.addedQuestionsInVoidIteration != null) {
					tracer.setAddedQuestions(addedQuestionsInVoidIteration);
					tracer.setAddedQuestionsStateSize(addedQuestionsStateSizeInVoidIteration);
					this.addedQuestionsInVoidIteration = null;
					this.addedQuestionsStateSizeInVoidIteration = null;
				}
			}
			
			// with 10% probability, store current date/time, so that we can use it to revert trades to this point
			if (random.nextDouble() <= .1) {
				dateTimeBeforeTrades = new Date();
				if (isToTrace()) {
					iterationToRevert = iteration;
					tracer.setIterationNumberRevertTrade(iterationToRevert);
				}
			}
			
			// (1) Randomly choose one user; create new one if necessary
			long userId = this.getRandomUser(userIDs, MAX_USER_NUM);
			if (isToTrace()) {
				tracer.setUserId(userId);
			}
			
			// assure listOfQuestions doesn't contain resolvedQuestions
			listOfQuestions.removeAll(resolvedQuestions);
			if (listOfQuestions.isEmpty()) {
				// there is no more question to trade (they are all resolved)
				System.out.println("\n\n# All questions were resolved. Total iterations="+(iteration));
				break;
			}
			
			// Randomly choose node to trade 
			Long questionId = null;
			int numAttemptsToChooseQuestion = 0;
			for (; numAttemptsToChooseQuestion < maxIterationToSelectQuestion; numAttemptsToChooseQuestion++) {
				questionId = listOfQuestions.get((int) (random.nextDouble() * listOfQuestions.size()));
				if (isToTrace()) {
					tracer.setQuestionId(questionId);
				}
				
				// check if the node exists or whether we should create the new node
				if (nodesToCreate.contains(network.getNode(questionId.toString()))) {
					if (engines.get(0).getProbabilisticNetwork().getNodeCount() < maxLiveNodes) {
						// can create new node without any problem
						if (isToAlwaysCreateMarkovBlanket ) {
							this.createNodesInMarkovBlanket(questionId, network, engines, (List)Collections.emptyList(), 
									nodesToCreate, resolvedQuestions);
						} else {
							this.createNode(questionId, network, engines, (List)Collections.emptyList(), 
									nodesToCreate, resolvedQuestions);
						}
						break;	// this question is OK to go now, because it was created
					} else {
						// cannot use this question, because it is a new node, but we cannot create more nodes due to max limit
						continue;	// try another random node
					}
				} else {
					// this question exists already
					break;
				}
			} 
			// 
			assertTrue("Attempts to choose question: " + numAttemptsToChooseQuestion + " out of " + maxIterationToSelectQuestion, numAttemptsToChooseQuestion < maxIterationToSelectQuestion);
			
			// randomly choose assumption set in the same clique of the node. 
			List<Long> assumptionIds = this.getRandomAssumptions(questionId, null, false);
			assumptionIds.removeAll(resolvedQuestions);
			List<Integer> assumedStates = this.getRandomAssumptionStates(assumptionIds);
			
			
			if (isToTrace()) {
				tracer.setAssumptionIds(new ArrayList<Long>(assumptionIds));
				tracer.setAssumedStates(new ArrayList<Integer>(assumedStates));
			}
			
			// check that the marginal  probability of this node can be changed
			for (Float p : engines.get(engines.size()-1).getProbList(questionId, null, null)) {
				// do not trade on nodes which is 0 or 1 (this may happen because of balance trade).
				if (p == 0f || p == 1f) {
					Debug.println(getClass(), "User " + userId + " cannot trade on question " + questionId 
							+ " given " + assumptionIds + "=" + assumedStates
							+ " because it has 0% or 100% prob");
					iteration--;
					if (isToTrace()) {
						if (tracer.getAddedCash() > 0f) {
							for (MarkovEngineImpl engine: engines) {
								engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
							}
						}
						addedQuestionsInVoidIteration = tracer.getAddedQuestions();
						addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
					}
					numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
					continue;
				}
			}
			
			// check that the conditional probability of this node can be changed
			for (Float p : engines.get(engines.size()-1).getProbList(questionId, assumptionIds, assumedStates)) {
				// do not trade on nodes which is 0 or 1 (this may happen because of balance trade).
				if (p == 0f || p == 1f) {
					Debug.println(getClass(), "User " + userId + " cannot trade on question " + questionId 
							+ " given " + assumptionIds + "=" + assumedStates
							+ " because it has 0% or 100% prob");
					iteration--;
					if (isToTrace()) {
						if (tracer.getAddedCash() > 0f) {
							for (MarkovEngineImpl engine: engines) {
								engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
							}
						}
						addedQuestionsInVoidIteration = tracer.getAddedQuestions();
						addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
					}
					numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
					continue;
				}
			}
			
			
			// if we have at least minNumQuestionToTriggerResolveQuestion live questions in last me, start resolving questions
			if (engines.get(engines.size()-1).getProbabilisticNetwork().getNodeCount() >= minNumQuestionToTriggerResolveQuestion) {
				isToResolveQuestion = true;
			}
			
			// state to consider when obtaining the limits of edit
			int stateOfEditLimit = this.getRandomAssumptionStates(Collections.singletonList(questionId)).get(0);
			if (isToTrace()) {
				tracer.setTargetState(stateOfEditLimit);
			}
			
			// Randomly add cash to the user
			if (random.nextDouble() < probToAddCash ) {
				float ammountToAdd = (float) (ASSET_ERROR_MARGIN + random.nextDouble() * MAX_CASH_TO_ADD);
				if (isToRoundEdit()) {
					// round ammountToAdd to PROB_FRACTIONAL_DIGITSth fractional digit
					ammountToAdd = (float) (Math.round(ammountToAdd*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS));
				}
				if (isToTrace()) {
					tracer.setAddedCash(ammountToAdd);
				}
				// add the cash
				engines.get(0).addCash(null, new Date(), userId, ammountToAdd, "Added " + ammountToAdd + " to user " + userId);
			}
			
			
			// obtain the bounds for the 5-point test
			List<Float> editLimits = null;
			if (isToCalculateEditLimit) {
				editLimits = engines.get(engines.size()-1).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
			} else {
				// use [0, 1] as default edit limit
				editLimits = new ArrayList<Float>(2);
				editLimits.add(0f); 
				editLimits.add(1f);
			}
			if (isToTrace()) {
				tracer.setEditLimit(new ArrayList<Float>(editLimits));
			}
			assertEquals(2, editLimits.size());
			
			if (isToCalculateEditLimit) {
				// if we have negative assets, then there can be negative/zero edit limit. In such case, this user cannot trade
				if ((editLimits.get(0) < PROB_ERROR_MARGIN || editLimits.get(1) <= PROB_ERROR_MARGIN || editLimits.get(0) > editLimits.get(1))) {
					Debug.println(getClass(), "User " + userId + " cannot trade on question " + questionId + " because of negative assets");
					iteration--;
					if (isToTrace()) {
						if (tracer.getAddedCash() > 0f) {
							for (MarkovEngineImpl engine: engines) {
								engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
							}
						}
						addedQuestionsInVoidIteration = tracer.getAddedQuestions();
						addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
					}
					numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
					continue;
				}
				
			}
			
			
			
			// Occasionally, user will attempt to exit from a question
			boolean hasBalanced = false;	// this var will become true only if we actually did a balance trade action
			if (random.nextDouble() < probToBalance ) {
				
				// actually balance
				assertTrue(engines.get(0).doBalanceTrade(null, new Date(), 
						"User "+userId + " exits question " + questionId + ", assumptions: " + assumptionIds+"="+assumedStates, 
						userId, questionId, assumptionIds, assumedStates
				));
				
//				if (nodesToTraceCliquePotentials != null) {
//					System.out.println("\nBalanced question " + questionId);
//					try { System.out.print("38="+engines.get(0).getProbList(38L, null, null)); } catch (Exception e) {}
//					try { System.out.print("26="+engines.get(0).getProbList(26L, null, null));} catch (Exception e) {}
//					System.out.println();
//				}
				
				// obtain the balancing trade from history, so that I can be certain that a balance trade was actually executed, and to fill the tracer
				List<QuestionEvent> questionHistory = engines.get(0).getQuestionHistory(questionId, null, null);
				assertTrue(questionHistory.get(questionHistory.size()-1) instanceof BalanceTradeNetworkAction);
				List<TradeSpecification> tradesToBalance = ((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades();
				
				// only mark as if we did balance a question if we really did balance a question
				if (!tradesToBalance.isEmpty()) {
					hasBalanced = true;
					if (isToTrace()) {
						tracer.setBalanceTradeSpecification(tradesToBalance);
					}
				}
			}
			
			if (!hasBalanced)  {	// do not make trades if user actually exitted a trade
				try {
					// do a trade which will "continue" further 
					List<Float> newValues = null;
					if (random.nextDouble() < probTradeOutsideLimit) {
						// there is a chance to trade on or outside the clique
						int switcher = (int) Math.round(random.nextDouble() * 3);
						switch (switcher) {
						case 0:
							// (1) the probability close to but smaller than the lower bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(
									questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
									userId, assumptionIds, assumedStates, FivePointTestType.BELOW_LIMIT, 
									null, true, resolvedQuestions, false);
							break;
						case 1:
							// (2) the probability exactly on the lower bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(
									questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
									userId, assumptionIds, assumedStates, FivePointTestType.ON_LOWER_LIMIT, 
									null, true, resolvedQuestions, false);
							break;
						case 2:
							// (4) the probability exactly on the upper bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(
									questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
									userId, assumptionIds, assumedStates, FivePointTestType.ON_UPPER_LIMIT, 
									null, true, resolvedQuestions, false);
							break;
						default:
							// (5) the probability close to but bigger than the upper bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(
									questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
									userId, assumptionIds, assumedStates, FivePointTestType.ABOVE_LIMIT, 
									null, true, resolvedQuestions, false);
							break;
						}
						
					} else if (Math.round( (editLimits.get(1) - editLimits.get(0)) * Math.pow(10, PROB_FRACTIONAL_DIGITS) ) <= 1) {
						if (isStrictlyNonNegativeCash) {
							// if we must keep cash strictly non-negative, avoid people trying to trade on the extremes
							iteration--;
							if (isToTrace()) {
								if (tracer.getAddedCash() > 0f) {
									for (MarkovEngineImpl engine: engines) {
										engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
									}
								}
								addedQuestionsInVoidIteration = tracer.getAddedQuestions();
								addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
							}
							numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
							continue;
						}
						
						// the edit limits have the same value or they differ by 1 digit in the smalles precision (PROB_FRACTIONAL_DIGITS). 
						// So, it's impossible to do a trade between edit limits (we can only do edits on or over these limits because of precision)
						if (random.nextDouble() <= .5) {
							// the last boolean is false because we don't want this trade to be reverted after this method
							newValues = this.do5PointTest(
									questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
									userId, assumptionIds, assumedStates, FivePointTestType.ON_LOWER_LIMIT, 
									null, true, resolvedQuestions, false);
						} else  {
							// the last boolean is false because we don't want this trade to be reverted after this method
							newValues = this.do5PointTest(
									questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
									userId, assumptionIds, assumedStates, FivePointTestType.ON_UPPER_LIMIT, 
									null, true, resolvedQuestions, false);
						} 
						
					} else {
						// (3) random probability in between the bound;
						// the last boolean is false because we don't want this trade to be reverted after this method
						newValues = this.do5PointTest(
								questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, 
								userId, assumptionIds, assumedStates, FivePointTestType.BETWEEN_LIMITS, 
								null, true, resolvedQuestions, false);
					}
					assertNotNull(newValues);
					assertFalse(newValues.isEmpty());
					if (isToTrace()) {
						tracer.setTargetProb(new ArrayList<Float>(newValues));
					}
				} catch (IllegalArgumentException e) {
					// probably, it could not generate a trade from these inputs. Try another
					Debug.println(getClass(), e.getMessage(), e);
					iteration--;
					if (isToTrace()) {
						if (tracer.getAddedCash() > 0f) {
							for (MarkovEngineImpl engine: engines) {
								engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
							}
						}
						addedQuestionsInVoidIteration = tracer.getAddedQuestions();
						addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
					}
					numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
					continue;
				}
			}
			
			if (isToTrace()) {
				// store all users' score and cash
				for (Long usr : engines.get(engines.size()-1).getUserToAssetAwareAlgorithmMap().keySet()) {
					float score = engines.get(engines.size()-1).scoreUserEv(usr, null, null);
					float cash  = engines.get(engines.size()-1).getCash(usr, null, null);
					tracer.getUserScoreAndCash().add(
							new UserScoreAndCash(
									usr, 
									score , 
									cash )
					);
					if (isStrictlyNonNegativeCash) {
						assertTrue("User " + usr + "' score = " + score, score > 0);
						assertTrue("User " + usr + "' cash = " + cash, cash > 0);
					}
				}
				// store marginals after trade
				tracer.setProbLists(engines.get(engines.size()-1).getProbLists(null, null, null));
			}
			
			
			// resolve a question eventually
			boolean hasResolved = false;
			if (isToResolveQuestion   && (listOfQuestions.size() > minAliveQuestionNumber )&& random.nextDouble() < probResolve) {
				hasResolved = true;
				int settledState = (int)(random.nextDouble()*questionsToNumberOfStatesMap.get(questionId));
				if (isToTrace()) {
					tracer.setToResolveQuestion(true);
					tracer.setResolvedState(settledState);
				}
				
				for (MarkovEngineImpl engine : engines) {
					engine.resolveQuestion(null, new Date(), questionId, settledState);
				}
				resolvedQuestions.add(questionId);
				
//				if (nodesToTraceCliquePotentials != null) {
//					System.out.println("\nResolved question " + questionId + " to state " + settledState);
//					try { System.out.print("38="+engines.get(0).getProbList(38L, null, null)); } catch (Exception e) {}
//					try { System.out.print("26="+engines.get(0).getProbList(26L, null, null));} catch (Exception e) {}
//					System.out.println();
//				}
				
				if (isToTrace()) {
					// store all users' score and cash after resolution
					for (Long usr : engines.get(engines.size()-1).getUserToAssetAwareAlgorithmMap().keySet()) {
						tracer.getUserScoreAndCashAfterResolution().add(
								new UserScoreAndCash(
										usr, 
										engines.get(engines.size()-1).scoreUserEv(usr, null, null), 
										engines.get(engines.size()-1).getCash(usr, null, null))
						);
					}
					
					// store marginals after resolution
					tracer.setProbListsAfterResolution(engines.get(engines.size()-1).getProbLists(null, null, null));
				}
			}
			
			// revert trades occasionally
			if (random.nextDouble() < probToRevert && (!hasResolved || !isToTrace())) {// TODO return back to .1 after we get response from Dr. Robin about the expected behavior of revert trade + add cash
				
				if (isToTrace()) {
					tracer.setToRevertTrade(true);
				}
				
				// choose a single question (questionId) to revert, or revert all questions (null)
				Long questionToRevert = (random.nextDouble()<=.5)?questionId:null;
				if (isToTrace()) {
					questionToRevert = null;
				}
				
				// do revert
				for (MarkovEngineImpl engine : engines) {
					engine.revertTrade(null, new Date(), dateTimeBeforeTrades, questionToRevert);
				}
				
				if (isToTrace()) {
					// store all users' score and cash after revert
					for (Long usr : engines.get(engines.size()-1).getUserToAssetAwareAlgorithmMap().keySet()) {
						tracer.getUserScoreAndCashAfterRevert().add(
								new UserScoreAndCash(
										usr, 
										engines.get(engines.size()-1).scoreUserEv(usr, null, null), 
										engines.get(engines.size()-1).getCash(usr, null, null))
						);
					}
					
					// store marginals after revert
					tracer.setProbListsAfterRevert(engines.get(engines.size()-1).getProbLists(null, null, null));
				}
			}
			
			
			if (isToTrace()) {
				System.out.print(tracer.toString());
			}
		}	// end of for : iteration
		
		System.out.println("\n\nQuantity of iterations close to limits: " + numEditsCloseToLimits + "\n\n");
	}
	/**
	 * Performs the same of {@link #runTestAssumingInitializedNetwork(Map, Map, List)},
	 * but it changes the network structure, resolves questions, adds cash.
	 * @param network : the final network structure. This method will gradually
	 * add nodes and edges to the markov engines until the network structure in 
	 * the markov engine reaches this structure.
	 * @param uncommittedTransactionKeyMap : this is used in order to commit operations in only 1 transaction.
	 * @param userIDs : currently created users
	 * @param enginesNotToChangeNetwork : {@link MarkovEngineInterface#addQuestion(Long, Date, long, int, List)}
	 * and {@link MarkovEngineInterface#addQuestionAssumption(Long, Date, long, List, List)} will not be called
	 * for these engines.
	 */
	private void runRandomTest(Network network, List<Long> userIDs, List<MarkovEngineInterface> enginesNotToChangeNetwork) {
		
		// this list stores which nodes were not created yet
		List<INode> nodesToCreate = new ArrayList<INode>(network.getNodes());
		// this variable will contain questions which were already resolved
		Set<Long> resolvedQuestions = new HashSet<Long>();
		
		assertNotNull(userIDs);
		
		// fill this map if you don't want transactions to be committed immediately
		Map<MarkovEngineImpl, Long> uncommittedTransactionKeyMap = new HashMap<MarkovEngineImpl, Long>();
		
		// make sure initial cash and expected score are 100
		for (MarkovEngineInterface engine : engines) {
			if (uncommittedTransactionKeyMap.containsKey(engine)) {
				// do not test engines in transactionKeyMap, because they were not committed yet
				continue;
			}
			for (Long userId : userIDs) {
				assertEquals(engine.toString(), 100f, engine.getCash(userId, null, null), ASSET_ERROR_MARGIN);
				assertEquals(engine.toString(), 100f, engine.scoreUserEv(userId, null, null), ASSET_ERROR_MARGIN);
			}
		}
		
		
		Map<Long, List<Float>> probabilities = engines.get(0).getProbLists(null, null, null);
		for (int i = 1; i < engines.size(); i++) {
			if (uncommittedTransactionKeyMap.containsKey(engines.get(i))) {
				// do not test engines in transactionKeyMap, because they were not committed yet
				continue;
			}
			// make sure all engines are retrieving the same questions
			Map<Long, List<Float>> probabilitiesOfOtherEngines = engines.get(i).getProbLists(null, null, null);
//			if (probabilities.size() < probabilitiesOfOtherEngines.size()) {
//				probabilities = engines.get(0).getProbLists(null, null, null);
//				probabilitiesOfOtherEngines = engines.get(i).getProbLists(null, null, null);
//			}
			assertTrue(engines.get(i).toString()+ probabilities + probabilitiesOfOtherEngines, probabilities.size() >= probabilitiesOfOtherEngines.size());
			assertTrue(engines.get(i).toString() + ", " + probabilitiesOfOtherEngines + ", " + probabilities, probabilities.keySet().containsAll(probabilitiesOfOtherEngines.keySet()));
			
			// also, make sure that probabilities are initialized equally
			for (Long id : probabilities.keySet()) {
				List<Float> probOfQuestion = probabilities.get(id);
				List<Float> probOfQuestionOfOtherEngines = probabilitiesOfOtherEngines.get(id);
				if (probOfQuestionOfOtherEngines != null) {
					// ignore nodes that were not created yet
					for (int j = 0; j < probOfQuestionOfOtherEngines.size(); j++) {
						assertEquals(
								engines.get(i).toString() + ", ID = " + id, 
								probOfQuestion.get(j), 
								probOfQuestionOfOtherEngines.get(j), 
								PROB_ERROR_MARGIN
						);
					}
				}
			}
		}
		
		
		Date dateTimeBeforeTrades = new Date();	// this variable will be used to revert trades
		int iterationToRevert = 0;
		
		// this boolean var will become true if the number of live questions is greater than minNumQuestionToTriggerResolveQuestion
		boolean isToResolveQuestion = false;	// if false, do not resolve question
		
		// actually run the tests
		for (int iteration = 0; iteration < getHowManyTradesToTest(); iteration++) {
			int numIterationsCloseToBoundsBeforeIteration = numEditsCloseToLimits;
			if (iteration == iterationToDebug) {
				while(!Debug.isDebugMode());
				Debug.setDebug(true);
//				Debug.setDebug(false);
			}
			if (isToTrace()) {
				tracer = new Tracer();
				tracer.setIterationNumberRevertTrade(iterationToRevert);
				tracer.setIterationNumber(iteration);
				if (this.addedQuestionsInVoidIteration != null) {
					tracer.setAddedQuestions(addedQuestionsInVoidIteration);
					tracer.setAddedQuestionsStateSize(addedQuestionsStateSizeInVoidIteration);
					this.addedQuestionsInVoidIteration = null;
					this.addedQuestionsStateSizeInVoidIteration = null;
				}
			}
			
			// with 10% probability, store current date/time, so that we can use it to revert trades to this point
			if (random.nextDouble() <= .1) {
				dateTimeBeforeTrades = new Date();
				if (isToTrace()) {
					iterationToRevert = iteration;
					tracer.setIterationNumberRevertTrade(iterationToRevert);
				}
			}
			
			// obtain the current marginal probabilities, so that we can compare later
			probabilities = engines.get(0).getProbLists(null, null, null);
			
			// (1) Randomly choose one user; create new one if necessary
			long userId = this.getRandomUser(userIDs, MAX_USER_NUM);
			if (isToTrace()) {
				tracer.setUserId(userId);
			}

			
			// (2) Randomly choose one node, 
			List<Long> listOfQuestions = new ArrayList<Long>(probabilities.keySet());
			listOfQuestions.removeAll(resolvedQuestions);
			if (listOfQuestions.isEmpty()) {
				// there is no more question to trade (they are all resolved)
				System.out.println("\n\n# All questions were resolved. Total iterations="+(iteration));
				break;
			}
			Long questionId = listOfQuestions.get((int) (random.nextDouble() * listOfQuestions.size()));
			if (isToTrace()) {
				tracer.setQuestionId(questionId);
			}
			
			// call this method anyway, because we want to create node if not present, and update edges if present
			this.createNodesInMarkovBlanket(questionId, network, engines, enginesNotToChangeNetwork, nodesToCreate, resolvedQuestions);
			
			// if we have at least minNumQuestionToTriggerResolveQuestion live questions, start resolving questions
			if (engines.get(engines.size()-1).getProbabilisticNetwork().getNodeCount() >= minNumQuestionToTriggerResolveQuestion) {
				isToResolveQuestion = true;
			}
			
			// state to consider when obtaining the limits of edit
			int stateOfEditLimit = this.getRandomAssumptionStates(Collections.singletonList(questionId)).get(0);
			if (isToTrace()) {
				tracer.setTargetState(stateOfEditLimit);
			}
			
			// randomly choose assumption set in the same clique of the node. 
			List<Long> assumptionIds = this.getRandomAssumptions(questionId, uncommittedTransactionKeyMap, false);
			assumptionIds.removeAll(resolvedQuestions);
			List<Integer> assumedStates = this.getRandomAssumptionStates(assumptionIds);
			for (Long assumption : assumptionIds) {
				// call this method anyway, because we want to create node if not present, and update edges if present
				this.createNodesInMarkovBlanket(assumption, network, engines, enginesNotToChangeNetwork, nodesToCreate, resolvedQuestions);
			}
			if (isToTrace()) {
				tracer.setAssumptionIds(new ArrayList<Long>(assumptionIds));
				tracer.setAssumedStates(new ArrayList<Integer>(assumedStates));
			}
			
			boolean has0or1 = false;
			// check that the marginal  probability of this node can be changed
			for (Float p : engines.get(engines.size()-1).getProbList(questionId, null, null)) {
				// do not trade on nodes which is 0 or 1 (this may happen because of balance trade).
				if (p == 0f || p == 1f) {
					has0or1 = true;
					break;
				}
			}
			if (has0or1) {
				Debug.println(getClass(), "User " + userId + " cannot trade on question " + questionId 
						+ " given " + assumptionIds + "=" + assumedStates
						+ " because it has 0% or 100% prob");
				iteration--;
				if (isToTrace()) {
					if (tracer.getAddedCash() > 0f) {
						for (MarkovEngineImpl engine: engines) {
							engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
						}
					}
					addedQuestionsInVoidIteration = tracer.getAddedQuestions();
					addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
				}
				numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
				continue;
			}
			
			// check that the conditional probability of this node can be changed
			for (Float p : engines.get(engines.size()-1).getProbList(questionId, assumptionIds, assumedStates)) {
				// do not trade on nodes which is 0 or 1 (this may happen because of balance trade).
				if (p == 0f || p == 1f) {
					has0or1 = true;
					break;
				}
			}
			if (has0or1) {
				Debug.println(getClass(), "User " + userId + " cannot trade on question " + questionId 
						+ " given " + assumptionIds + "=" + assumedStates
						+ " because it has 0% or 100% prob");
				iteration--;
				if (isToTrace()) {
					if (tracer.getAddedCash() > 0f) {
						for (MarkovEngineImpl engine: engines) {
							engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
						}
					}
					addedQuestionsInVoidIteration = tracer.getAddedQuestions();
					addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
				}
				numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
				continue;
			}
			
			// Randomly add cash to the user
			if (random.nextDouble() < probToAddCash ) {
				float ammountToAdd = (float) (ASSET_ERROR_MARGIN + random.nextDouble() * MAX_CASH_TO_ADD);
				if (isToRoundEdit()) {
					// round ammountToAdd to PROB_FRACTIONAL_DIGITSth fractional digit
					ammountToAdd = (float) (Math.round(ammountToAdd*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS));
					// check if it was correctly arounded
					assertEquals(
							"add cash: " + ammountToAdd, 
							0, 
							(Math.round(ammountToAdd*Math.pow(10, PROB_FRACTIONAL_DIGITS)) - ammountToAdd*Math.pow(10, PROB_FRACTIONAL_DIGITS))/Math.pow(10, PROB_FRACTIONAL_DIGITS), 
							PROB_ERROR_MARGIN
						);
				}
				if (isToTrace()) {
					tracer.setAddedCash(ammountToAdd);
				}
				float newCash = Float.NaN;
				float newConditionalCash = Float.NaN;
//				System.out.println("getCash(userId=" + userId+",assumptionIds=null,assumedStates=null)="+oldCash);
//				System.out.println("getCash(userId=" + userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+oldConditionalCash);
//				System.out.println("addCash(userId="+userId+",assets="+ammountToAdd+")");
//				System.out.println("getCash(userId=" + userId+",assumptionIds=null,assumedStates=null)="+newCash);
//				System.out.println("getCash(userId=" + userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+newConditionalCash);
				for (MarkovEngineImpl engine : engines) {
					// obtain previous cash, so that we know that cash was added
					float oldCashToCompare = engine.getCash(userId, null, null);
					float oldConditionalCashToCompare = engine.getCash(userId, assumptionIds, assumedStates);
					
					// obtain the assets of empty separators, for posterior comparison
					float oldEmptySeparatorAssets = Float.NaN;
					try {
						oldEmptySeparatorAssets = engine.getAlgorithmAndAssetNetFromUserID(userId).getEmptySeparatorsDefaultContent();
						if (engine.isToUseQValues()) {
							// this engine may be using q-values. Convert everything to assets for a fair comparison.
							oldEmptySeparatorAssets = engine.getScoreFromQValues(oldEmptySeparatorAssets);
						}
					}catch (InvalidParentException e) {
						e.printStackTrace();
						fail(e.getMessage());
					}
					
					// add the cash
					engine.addCash(null, new Date(), userId, ammountToAdd, "Added " + ammountToAdd + " to user " + userId);
					// print the operations
					// obtain the updated cash
					newCash = engine.getCash(userId, null, null);
					newConditionalCash = engine.getCash(userId, assumptionIds, assumedStates);
					// assertions
					assertEquals(engine.toString() + ", user=" + userId + ", added=" + ammountToAdd, oldCashToCompare + ammountToAdd, newCash , ASSET_ERROR_MARGIN);
					assertEquals(engine.toString() + ", user=" + userId + ", added=" + ammountToAdd +  assumptionIds + " = " + assumedStates, oldConditionalCashToCompare + ammountToAdd, newConditionalCash , ASSET_ERROR_MARGIN);
					
					// compare the assets of empty separators
					try {
						float newEmptySeparatorAssets = engine.getAlgorithmAndAssetNetFromUserID(userId).getEmptySeparatorsDefaultContent();
						if (engine.isToUseQValues()) {
							// this engine may be using q-values. Convert everything to assets for a fair comparison.
							newEmptySeparatorAssets = engine.getScoreFromQValues(newEmptySeparatorAssets);
						}
						assertEquals(engine.toString() + ", user=" + userId + ", added=" + ammountToAdd, oldEmptySeparatorAssets + ammountToAdd, newEmptySeparatorAssets , ASSET_ERROR_MARGIN);
					} catch (InvalidParentException e) {
						e.printStackTrace();
						fail(e.getMessage());
					}
				}
			}
			
			
			// obtain the bounds for the 5-point test
			List<Float> editLimits = null;
			if (isToCalculateEditLimit) {
				if (resolvedQuestions.contains(questionId) || new HashSet<Long>(resolvedQuestions).removeAll(assumptionIds)) {
					try {
						editLimits = engines.get(engines.size()-1).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
						// should not calculate if question was resolved
						fail("user="+userId+", questionId="+questionId+", stateOfEditLimit="+stateOfEditLimit+", assumptionIds="+assumptionIds
								+", assumedStates="+assumedStates);
					} catch (IllegalArgumentException e) {
						// OK
					}
				} else {
					editLimits = engines.get(engines.size()-1).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
				}
			} else {
				// use [0, 1] as default edit limit
				editLimits = new ArrayList<Float>(2);
				editLimits.add(0f); 
				editLimits.add(1f);
			}
			if (isToTrace()) {
				tracer.setEditLimit(new ArrayList<Float>(editLimits));
			}
			assertEquals(2, editLimits.size());
			
			if (isToCalculateEditLimit) {
				// if we have negative assets, then there can be negative/zero edit limit. In such case, this user cannot trade
				if ((editLimits.get(0) < PROB_ERROR_MARGIN || editLimits.get(1) <= PROB_ERROR_MARGIN || editLimits.get(0) > editLimits.get(1))) {
//				if (iterationToRevert > iteration) {
//					iterationToRevert = iteration;
//				}
					Debug.println(getClass(), "User " + userId + " cannot trade on question " + questionId + " because of negative assets");
					iteration--;
					if (isToTrace()) {
						if (tracer.getAddedCash() > 0f) {
							for (MarkovEngineImpl engine: engines) {
								engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
							}
						}
						addedQuestionsInVoidIteration = tracer.getAddedQuestions();
						addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
					}
					numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
					continue;
				}
				
//			System.out.println("getEditLimits(userId="+userId+",questionId="+questionId+",questionState="+stateOfEditLimit+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+editLimits);
				for (int i = 0; i < engines.size()-1; i++) {
					if (uncommittedTransactionKeyMap.containsKey(engines.get(i))) {
						// do not test engines in transactionKeyMap, because they were not committed yet
						continue;
					}
					if (resolvedQuestions.contains(questionId) || new HashSet<Long>(resolvedQuestions).removeAll(assumptionIds)) {
						try {
							engines.get(i).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
							// should not calculate if question was resolved
							fail(engines.get(i)+", user="+userId+", questionId="+questionId+", stateOfEditLimit="+stateOfEditLimit+", assumptionIds="+assumptionIds
									+", assumedStates="+assumedStates);
						}catch (IllegalArgumentException e) {
							// OK
						}
					}else {
						List<Float> editLimitsOfOtherEngine = engines.get(i).getEditLimits(userId, questionId, stateOfEditLimit, assumptionIds, assumedStates);
						assertEquals(engines.get(i).toString(), editLimits.size(), editLimitsOfOtherEngine.size());
						for (int j = 0; j < editLimits.size(); j++) {
							assertEquals(engines.get(i).toString() + ", user=" + userId + ", question=" + questionId 
									+", state=" + stateOfEditLimit + ", assumptions: " +  assumptionIds + "=" + assumedStates
									+", expectedEditLimit = " + editLimits + ", obtainedEditLimit = " + editLimitsOfOtherEngine, 
									editLimits.get(j), editLimitsOfOtherEngine.get(j), 
									RELAXED_PROB_ERROR_MARGIN);
						}
					}
				}
			}
			
			
//			System.out.println("Iteration " + iteration + ", question=" + questionId + ", state=" + stateOfEditLimit + 
//					", limit="+ editLimits + ", user="  +userId + ", assumptions: " + assumptionIds + "=" + assumedStates);
			
			// generate questionsToNumberOfStatesMap based on the list of probabilities
			Map<Long, Integer> questionsToNumberOfStatesMap = new HashMap<Long, Integer>();
			for (Long key : probabilities.keySet()) {
				questionsToNumberOfStatesMap.put(key, probabilities.get(key).size());
			}
			
			// Occasionally, user will attempt to exit from a question
			boolean hasBalanced = false;	// this var will become true only if we actually did a balance trade action
			if (random.nextDouble() < probToBalance ) {
				// TODO BruteForceMarkovEngine needs doBalanceTrade correctly implemented
				Date occurredWhen = new Date();
				List<Float> cashPerStates = null;
				
				List<TradeSpecification> tradesToBalance = null;
				List<TradeSpecification> tradesToBalancePreview = null;	// the previewed trades for balance, so that we compare with trades actually performed
				
				// run in inverse order, because BruteForceMarkovEngine is the 1st engine, and it cannot run doBalanceTrade
				for (int engineIndex = engines.size()-1; engineIndex >= 0; engineIndex--) {
					
					MarkovEngineImpl engine = engines.get(engineIndex);
					if (engine instanceof BruteForceMarkovEngine) {
						for (TradeSpecification tradeSpecification : tradesToBalance) {
							// performs a trade which was calculated by previous engine
							assertNotNull(engine.addTrade(null, occurredWhen, 
									"User "+userId + " exits question " + questionId + ", assumptions: " + assumptionIds+"="+assumedStates, 
									tradeSpecification, true));
						}
					} else {
						float cashBeforeBalance = engine.getCash(userId, null, null);
						
						// preview now, and compare with what was actually ran after trade
						tradesToBalancePreview = engine.previewBalancingTrades(userId, questionId, assumptionIds, assumedStates);
						
						// actually balance
						assertTrue(engine.doBalanceTrade(null, occurredWhen, 
								"User "+userId + " exits question " + questionId + ", assumptions: " + assumptionIds+"="+assumedStates, 
								userId, questionId, assumptionIds, assumedStates
						));
						
						// obtain the balancing trade from history, so that the next iteration can use it if the next engine is a Brute force engine
						List<QuestionEvent> questionHistory = engine.getQuestionHistory(questionId, null, null);
						assertTrue(questionHistory.get(questionHistory.size()-1) instanceof BalanceTradeNetworkAction);
						tradesToBalance = ((BalanceTradeNetworkAction)questionHistory.get(questionHistory.size()-1)).getExecutedTrades();
						
						// compare with previewed trades to balance
						assertEquals(tradesToBalance.size(), tradesToBalancePreview.size());
						for (int i = 0; i < tradesToBalance.size(); i++) {
							
							// compare question and user
							assertEquals(tradesToBalance.get(i).getQuestionId(), tradesToBalancePreview.get(i).getQuestionId());
							assertEquals(tradesToBalance.get(i).getUserId(), tradesToBalancePreview.get(i).getUserId());
							
							// compare assumptions
							assertEquals(tradesToBalance.get(i).getAssumptionIds().size(), tradesToBalancePreview.get(i).getAssumptionIds().size());
							for (int j = 0; j < tradesToBalance.get(i).getAssumptionIds().size(); j++) {
								assertEquals(tradesToBalance.get(i).getAssumptionIds().get(j), tradesToBalancePreview.get(i).getAssumptionIds().get(j));
							}
							
							// compare assumed states
							assertEquals(tradesToBalance.get(i).getAssumedStates().size(), tradesToBalancePreview.get(i).getAssumedStates().size());
							for (int j = 0; j < tradesToBalance.get(i).getAssumedStates().size(); j++) {
								assertEquals(tradesToBalance.get(i).getAssumedStates().get(j), tradesToBalancePreview.get(i).getAssumedStates().get(j));
							}
							
							// compare prob
							assertEquals(tradesToBalance.get(i).getProbabilities().size(), tradesToBalancePreview.get(i).getProbabilities().size());
							for (int j = 0; j < tradesToBalance.get(i).getProbabilities().size(); j++) {
								assertEquals(tradesToBalance.get(i).getProbabilities().get(j), tradesToBalancePreview.get(i).getProbabilities().get(j), PROB_ERROR_MARGIN);
							}
						}
						
						// only mark as if we did balance a question if we really did balance a question
						if (!tradesToBalance.isEmpty()) {
							hasBalanced = true;
							if (isToTrace()) {
								tracer.setBalanceTradeSpecification(tradesToBalance);
							}
						} else {
							// check that conditional min assets per state are close each other
							if (isToCheckCashAfterBalance) {
								List<Float> cashes = engine.getCashPerStates(userId, questionId, assumptionIds, assumedStates);
								for (int i = 1; i < cashes.size(); i++) {
									if (cashBeforeBalance >= 0) {
										// if cash before balance was non negative, balance will keep cash non-negative
										assertTrue(cashBeforeBalance + "->" + cashes.get(i), cashes.get(i) >= 0);
									} 
								}
							}
						}
						// trade shall not be null
						assertNotNull(engine.toString() + ", user=" + userId + ", question="+questionId 
								+ ", assumptions:"+assumptionIds +"=" +assumedStates, tradesToBalance);
						// check that the content of the trade is consistent
						for (TradeSpecification tradeSpecification : tradesToBalance) {
							float sum = 0;
							for (int state = 0; state < tradeSpecification.getProbabilities().size(); state++) {
								float p = tradeSpecification.getProbabilities().get(state);
								assertTrue(engine.toString() + ", user=" + userId + ", question="+questionId 
										+ ", assumptions:"+assumptionIds +"=" +assumedStates + ", p="+p, 
										p <= 1 && p >= 0);
								sum +=p;
							}
							// check that sum of balancing trade is 1
							assertEquals(engine.toString() + ", user=" + userId + ", question="+questionId 
									+ ", assumptions:"+assumptionIds +"=" +assumedStates,1f, sum,PROB_ERROR_MARGIN);
						}
						
						List<Float> assetsIf = engine.getAssetsIfStates(userId, questionId, assumptionIds, assumedStates);
						// check number of states of this question
						assertEquals(engine.toString()+", user = "+userId+", question = " + questionId+", assumptions: " + assumptionIds+"="+assumedStates
								+ "assets-if per state = " + assetsIf, 
								probabilities.get(questionId).size(), assetsIf.size());
						// check that assets given scores per question are close each other
						for (int i = 1; i < assetsIf.size(); i++) {
							assertEquals(engine.toString()+", user = "+userId+", question = " + questionId+", assumptions: " + assumptionIds+"="+assumedStates
									+ "score per state = " + assetsIf,
									assetsIf.get(0), assetsIf.get(i), ASSET_ERROR_MARGIN);
						}
						// check that conditional min assets per state are close each other
						if (isToCheckCashAfterBalance ) {
							cashPerStates = engine.getCashPerStates(userId, questionId, assumptionIds, assumedStates);
							for (int i = 1; i < assetsIf.size(); i++) {
								assertEquals(engine.toString()+", user = "+userId+", question = " + questionId+", assumptions: " + assumptionIds+"="+assumedStates
										+ "cash per state = " + cashPerStates,
										cashPerStates.get(0), cashPerStates.get(i), ASSET_ERROR_MARGIN);
							}
						}
					}
					
				}
				
//				System.out.println("doBalanceTrade(occurredWhen="+occurredWhen+",userId="+userId+",questionId="+questionId
//						+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")");
//				System.out.println("getCashPerStates(userId="+userId+",questionId="+questionId
//						+",assumptionIds+"+assumptionIds+",assumedStates="+assumedStates+")="+cashPerStates);
			}
			
			// if the edit limit is too small, then we cannot change probability
			// edit limit is too small if the maximum amount we can move (i.e. half of the interval)
//			if ((((editLimits.get(1) - editLimits.get(0)) / 2)) / (network.getNode(Long.toString(questionId)).getStatesSize()-1) < probDiffToConsiderSufficientChange) {
//				iteration--;
//				addedQuestionsInVoidIteration = tracer.getAddedQuestions();
//				addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
//				numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
//				continue;
//			}
			
			
			if (!hasBalanced)  {	// do not make trades if user actually exitted a trade
				try {
					// a.) 5-point min-q values test regarding the edit bound; expect to see corresponding q<1, =1, >1 respectively.
					if (isToRun5PointTestInStructureTest  && uncommittedTransactionKeyMap.isEmpty()) {	// only do these tests if we are not comparing the cases which runs all trades in 1 transaction or multiple transactions
						// (1) the probability close to but smaller than the lower bound; the last boolean is true because we want this trade to be reverted after this method
						this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.BELOW_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, true);
						
						// (2) the probability exactly on the lower bound; the last boolean is true because we want this trade to be reverted after this method
						this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_LOWER_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, true);
						
						// (4) the probability exactly on the upper bound; the last boolean is true because we want this trade to be reverted after this method
						this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_UPPER_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, true);
						
						// (5) the probability close to but bigger than the upper bound; the last boolean is true because we want this trade to be reverted after this method
						this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ABOVE_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, true);
					}
					// do a trade which will "continue" further 
					List<Float> newValues = null;
					if (random.nextDouble() < probTradeOutsideLimit) {
						// there is a chance to trade on or outside the clique
						int switcher = (int) Math.round(random.nextDouble() * 3);
						switch (switcher) {
						case 0:
							// (1) the probability close to but smaller than the lower bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.BELOW_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
							break;
						case 1:
							// (2) the probability exactly on the lower bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_LOWER_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
							break;
						case 2:
							// (4) the probability exactly on the upper bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_UPPER_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
							break;
						default:
							// (5) the probability close to but bigger than the upper bound; the last boolean is true because we want this trade to be reverted after this method
							newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ABOVE_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
							break;
						}
						
					} else if (Math.round( (editLimits.get(1) - editLimits.get(0)) * Math.pow(10, PROB_FRACTIONAL_DIGITS) ) <= 1) {
						if (isStrictlyNonNegativeCash) {
							// if we must keep cash strictly non-negative, avoid people trying to trade on the extremes
							iteration--;
							if (isToTrace()) {
								if (tracer.getAddedCash() > 0f) {
									for (MarkovEngineImpl engine: engines) {
										engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
									}
								}
								addedQuestionsInVoidIteration = tracer.getAddedQuestions();
								addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
							}
							numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
							continue;
						}
						// the edit limits have the same value or they differ by 1 digit in the smalles precision (PROB_FRACTIONAL_DIGITS). 
						// So, it's impossible to do a trade between edit limits (we can only do edits on or over these limits because of precision)
						if (random.nextDouble() <= .5) {
							// the last boolean is false because we don't want this trade to be reverted after this method
							newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_LOWER_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
						} else  {
							// the last boolean is false because we don't want this trade to be reverted after this method
							newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.ON_UPPER_LIMIT, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
						} 
					} else {
						// (3) random probability in between the bound;
						// the last boolean is false because we don't want this trade to be reverted after this method
						newValues = this.do5PointTest(questionsToNumberOfStatesMap, questionId, stateOfEditLimit, editLimits, userId, assumptionIds, assumedStates, FivePointTestType.BETWEEN_LIMITS, uncommittedTransactionKeyMap, true, resolvedQuestions, false);
					}
					assertNotNull(newValues);
					assertFalse(newValues.isEmpty());
					if (isToTrace()) {
						tracer.setTargetProb(new ArrayList<Float>(newValues));
					}
				} catch (IllegalArgumentException e) {
					// probably, it could not generate a trade from these inputs. Try another
					Debug.println(getClass(), e.getMessage(), e);
					iteration--;
					if (isToTrace()) {
						if (tracer.getAddedCash() > 0f) {
							for (MarkovEngineImpl engine: engines) {
								engine.addCash(null, new Date(), userId, -tracer.getAddedCash(), "Undoing the last add cash operation...");
							}
						}
						addedQuestionsInVoidIteration = tracer.getAddedQuestions();
						addedQuestionsStateSizeInVoidIteration = tracer.getAddedQuestionsStateSize();
					}
					numEditsCloseToLimits = numIterationsCloseToBoundsBeforeIteration;
					continue;
				}
			}
			
			if (isToTrace()) {
				// store all users' score and cash
				for (Long usr : engines.get(engines.size()-1).getUserToAssetAwareAlgorithmMap().keySet()) {
					tracer.getUserScoreAndCash().add(
							new UserScoreAndCash(
									usr, 
									engines.get(engines.size()-1).scoreUserEv(usr, null, null), 
									engines.get(engines.size()-1).getCash(usr, null, null))
					);
				}
				// make sure they match
				for (int i = 0; i < engines.size()-1; i++) {
					for (UserScoreAndCash scoreCash : tracer.getUserScoreAndCash()) {
						assertEquals(scoreCash.userId.toString(), scoreCash.cash, engines.get(i).getCash(scoreCash.userId, null, null), ASSET_ERROR_MARGIN);
						float scoreUserEv = engines.get(i).scoreUserEv(scoreCash.userId, null, null);
						if (!Float.isInfinite(scoreUserEv) || isToCompareInfiniteExpectedScore) {
							assertEquals(scoreCash.userId.toString(), scoreCash.score, scoreUserEv, ASSET_ERROR_MARGIN);
						}
					}
				}
				// store marginals after trade
				tracer.setProbLists(engines.get(engines.size()-1).getProbLists(null, null, null));
			}
			
			
			// resolve a question eventually
			boolean hasResolved = false;
			if (isToResolveQuestion   && (listOfQuestions.size() > minAliveQuestionNumber )&& random.nextDouble() < probResolve) {
				hasResolved = true;
				int settledState = (int)(random.nextDouble()*probabilities.get(questionId).size());
				if (isToTrace()) {
					tracer.setToResolveQuestion(true);
					tracer.setResolvedState(settledState);
				}
				
//				System.out.println("resolveQuestion(questionId="+questionId+",settledState="+settledState+")");
				for (MarkovEngineImpl engine : engines) {
					engine.resolveQuestion(null, new Date(), questionId, settledState);
					// check that the resolved state is 100% and other states are 0%
					List<Float> probListsToCompare = engine.getProbList(questionId, null, null);
					for (int state = 0; state < probListsToCompare.size(); state++) {
						assertEquals(engine.toString()+", resolved question = " + questionId + ", state = " + settledState,
								((settledState==state)?1f:0f), probListsToCompare.get(state), ASSET_ERROR_MARGIN);
					}
					// check that for engines which deletes resolved questions, the probabilities of resolved states cannot be retrieved anymore
					if (engine.isToDeleteResolvedNode() && !engine.isToObtainProbabilityOfResolvedQuestions()) {
						for (Long resolved : resolvedQuestions) {
							try {
								List<Float> probList = engine.getProbList(resolved, assumptionIds, assumedStates);
								fail(engine.toString() + ", question = "+resolved + ", prob = "+probList);
							} catch (InexistingQuestionException e) {
								// OK
							}
						}
					}
				}
				resolvedQuestions.add(questionId);
				
				if (isToTrace()) {
					// store all users' score and cash after resolution
					for (Long usr : engines.get(engines.size()-1).getUserToAssetAwareAlgorithmMap().keySet()) {
						tracer.getUserScoreAndCashAfterResolution().add(
								new UserScoreAndCash(
										usr, 
										engines.get(engines.size()-1).scoreUserEv(usr, null, null), 
										engines.get(engines.size()-1).getCash(usr, null, null))
						);
					}
					// make sure they match
					for (int i = 0; i < engines.size()-1; i++) {
						for (UserScoreAndCash scoreCash : tracer.getUserScoreAndCashAfterResolution()) {
							assertEquals(scoreCash.userId.toString(), scoreCash.cash, engines.get(i).getCash(scoreCash.userId, null, null), ASSET_ERROR_MARGIN);
							float scoreUserEv = engines.get(i).scoreUserEv(scoreCash.userId, null, null);
							if (!Float.isInfinite(scoreUserEv) || isToCompareInfiniteExpectedScore) {
								assertEquals(scoreCash.userId.toString(), scoreCash.score, scoreUserEv, ASSET_ERROR_MARGIN);
							}
						}
					}
					
					// store marginals after resolution
					tracer.setProbListsAfterResolution(engines.get(engines.size()-1).getProbLists(null, null, null));
				}
				
				// check marginal probability
				probabilities = engines.get(0).getProbLists(null, null, null); 
				if (engines.get(0).isToDeleteResolvedNode()) {
					// force probabilities to contain resolved nodes
					List<Float> prob = engines.get(0).getProbList(questionId, null, null);
					assertNotNull(prob);
					assertFalse(prob.isEmpty());
					probabilities.put(questionId, prob);
				} 
				
				// check that the resolved state is 100% and other states are 0%
				for (int state = 0; state < probabilities.get(questionId).size(); state++) {
					assertEquals("Resolved question = " + questionId + ", state = " + settledState,
							((settledState==state)?1f:0f), probabilities.get(questionId).get(state), ASSET_ERROR_MARGIN);
				}
				
				
				// check that all engines are retrieving the same marginals
//				System.out.println("getProbLists(questionIds=null,assumptionIds=null,assumedStates=null)="+probabilities);
				for (MarkovEngineImpl engine : engines) {
					Map<Long, List<Float>> probListsToCompare = engine.getProbLists(null, null, null);
					assertTrue(engine.toString()+", probabilities="+probabilities+", probListsToCompare="+probListsToCompare,
							probabilities.size() >= probListsToCompare.size());
					for (Long question : probListsToCompare.keySet()) {
						for (int state = 0; state < probListsToCompare.get(question).size(); state++) {
							assertEquals(engine.toString()+", question = " + question + ", state = " + state
									+", probabilities="+probabilities+", probListsToCompare="+probListsToCompare,
									probabilities.get(question).get(state), probListsToCompare.get(question).get(state), PROB_ERROR_MARGIN);
						}
					}
					// if engine is configured to delete resolved questions, then it should not be retrievable from getProbLists
					for (Long question : resolvedQuestions) {
						if (engine.isToDeleteResolvedNode()) {
							assertFalse(engine.toString() +", probabilities="+probabilities+", probListsToCompare="+probListsToCompare + ", question = "+question,
									probListsToCompare.containsKey(question));
						}
					}
				}
				
				// check values related to assets as well
				float scoreUserEv = engines.get(0).scoreUserEv(userId, null, null);
				float conditionalScoreUserEv = engines.get(0).scoreUserEv(userId, assumptionIds, assumedStates);
				float newCash = engines.get(0).getCash(userId, null, null);
				float newConditionalCash = engines.get(0).getCash(userId, assumptionIds, assumedStates);
//				System.out.println("scoreUserEv(userId="+userId+",assumptionIds=null,assumedStates=null)="+scoreUserEv);
//				System.out.println("scoreUserEv(userId="+userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+conditionalScoreUserEv);
//				System.out.println("scoreUserQuestionEvStates(userId="+userId+",questionId="+questionId
//						+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+scoreUserQuestionEvStates);
//				System.out.println("getCashPerStates(userId="+userId+",questionId="+questionId
//						+",assumptionIds+"+assumptionIds+",assumedStates="+assumedStates+")="+cashPerStates);
//				System.out.println("getCash(userId=" + userId+",assumptionIds=null,assumedStates=null)="+newCash);
//				System.out.println("getCash(userId=" + userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+newConditionalCash);
				for (int i = 1; i < engines.size(); i++) {
					// extract the values related to assets, from current engine
					float scoreUserEvToCompare = engines.get(i).scoreUserEv(userId, null, null);
					float conditionalScoreUserEvToCompare = engines.get(i).scoreUserEv(userId, assumptionIds, assumedStates);
					float newCashToCompare = engines.get(i).getCash(userId, null, null);
					float newConditionalCashToCompare = engines.get(i).getCash(userId, assumptionIds, assumedStates);
					
					List<Float> scoreUserQuestionEvStatesToCompare = null;
//					List<Float> cashPerStatesToCompare = null;
					// the following shall throw exception if engine is configured to delete resolved nodes
					if (engines.get(i).isToDeleteResolvedNode() || !engines.get(i).isToObtainProbabilityOfResolvedQuestions()) {
						try {
							engines.get(i).scoreUserQuestionEvStates(userId, questionId, assumptionIds, assumedStates);
							fail(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates);
						} catch (IllegalArgumentException e) {
							// OK
						}
						try {
							engines.get(i).getCashPerStates(userId, questionId, assumptionIds, assumedStates);
							fail(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates);
						} catch (IllegalArgumentException e) {
							// OK
						}
					} else if (!engines.get(0).isToDeleteResolvedNode()) {
						List<Float> scoreUserQuestionEvStates = engines.get(0).scoreUserQuestionEvStates(userId, questionId, assumptionIds, assumedStates);
						List<Float> cashPerStates = engines.get(0).getCashPerStates(userId, questionId, assumptionIds, assumedStates);
						// nodes are still present in the system
						scoreUserQuestionEvStatesToCompare = engines.get(i).scoreUserQuestionEvStates(userId, questionId, assumptionIds, assumedStates);
//						cashPerStatesToCompare = engines.get(i).getCashPerStates(userId, questionId, assumptionIds, assumedStates);
						
						// check that the number of states is matching
						assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
								scoreUserQuestionEvStates.size(), scoreUserQuestionEvStatesToCompare.size());
//						assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
//								cashPerStates.size(), cashPerStatesToCompare.size());
						assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
								cashPerStates.size(), scoreUserQuestionEvStates.size());
						
						// these lists will be used to simulate getCashPerStates.
						List<Long> assumptionIdsIncludingResolved = new ArrayList<Long>(assumptionIds);
						List<Integer> assumedStatesIncludingResolved = new ArrayList<Integer>(assumedStates);
						assumptionIdsIncludingResolved.add(questionId);
						assumedStatesIncludingResolved.add(0);
						
						// compare scores and min assets per state
						for (int state = 0; state < scoreUserQuestionEvStates.size(); state++) {
							assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
									scoreUserQuestionEvStates.get(state), scoreUserQuestionEvStatesToCompare.get(state), ASSET_ERROR_MARGIN);
//							assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
//									cashPerStates.get(state), cashPerStatesToCompare.get(state), ASSET_ERROR_MARGIN);
							
							assumedStatesIncludingResolved.set(assumedStatesIncludingResolved.size()-1, state);
							if (state != settledState) {
								try {
									float cash = engines.get(i).getCash(userId, assumptionIdsIncludingResolved, assumedStatesIncludingResolved);
									fail(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates+ ", cash="+cash);
								} catch (ZeroAssetsException e) {
									// OK. Engine is supposed to throw this exception if infinite asset is found
								}
							} else {
								assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
										cashPerStates.get(state), engines.get(i).getCash(userId, assumptionIdsIncludingResolved, assumedStatesIncludingResolved), ASSET_ERROR_MARGIN);
							}
							
						}
					}
					
					// compare score and conditional score
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							scoreUserEv, scoreUserEvToCompare, ASSET_ERROR_MARGIN);
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							conditionalScoreUserEv, conditionalScoreUserEvToCompare, ASSET_ERROR_MARGIN);
					// compare cash and conditional cash
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							newCash, newCashToCompare, ASSET_ERROR_MARGIN);
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							newConditionalCash, newConditionalCashToCompare, ASSET_ERROR_MARGIN);
					
				}
			}
			
			// revert trades occasionally
			if (random.nextDouble() < probToRevert && (!hasResolved || !isToTrace())) {// TODO return back to .1 after we get response from Dr. Robin about the expected behavior of revert trade + add cash
				
				if (isToTrace()) {
					tracer.setToRevertTrade(true);
				}
				
				// choose a single question (questionId) to revert, or revert all questions (null)
				Long questionToRevert = (random.nextDouble()<=.5)?questionId:null;
				if (isToTrace()) {
					questionToRevert = null;
				}
				
				// store marginals before revert
				probabilities = engines.get(0).getProbLists(null, null, null);
				
				// do revert
				for (MarkovEngineImpl engine : engines) {
					engine.revertTrade(null, new Date(), dateTimeBeforeTrades, questionToRevert);
				}

				if (isToTrace()) {
					// store all users' score and cash after revert
					for (Long usr : engines.get(engines.size()-1).getUserToAssetAwareAlgorithmMap().keySet()) {
						tracer.getUserScoreAndCashAfterRevert().add(
								new UserScoreAndCash(
										usr, 
										engines.get(engines.size()-1).scoreUserEv(usr, null, null), 
										engines.get(engines.size()-1).getCash(usr, null, null))
						);
					}
					
					// store marginals after revert
					tracer.setProbListsAfterRevert(engines.get(engines.size()-1).getProbLists(null, null, null));
				}
				
				// check values related to assets
				List<Float> scoreUserQuestionEvStates = engines.get(0).scoreUserQuestionEvStates(userId, questionId, assumptionIds, assumedStates);
				List<Float> cashPerStates = engines.get(0).getCashPerStates(userId, questionId, assumptionIds, assumedStates);
				float scoreUserEv = engines.get(0).scoreUserEv(userId, null, null);
				float conditionalScoreUserEv = engines.get(0).scoreUserEv(userId, assumptionIds, assumedStates);
				float newCash = engines.get(0).getCash(userId, null, null);
				float newConditionalCash = engines.get(0).getCash(userId, assumptionIds, assumedStates);
//				System.out.println("revertTrade(tradesStartingWhen="+dateTimeBeforeTrades+",questionId="+questionToRevert+")");
//				System.out.println("scoreUserEv(userId="+userId+",assumptionIds=null,assumedStates=null)="+scoreUserEv);
//				System.out.println("scoreUserEv(userId="+userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+conditionalScoreUserEv);
//				System.out.println("scoreUserQuestionEvStates(userId="+userId+",questionId="+questionId
//						+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+scoreUserQuestionEvStates);
//				System.out.println("getCashPerStates(userId="+userId+",questionId="+questionId
//						+",assumptionIds+"+assumptionIds+",assumedStates="+assumedStates+")="+cashPerStates);
//				System.out.println("getCash(userId=" + userId+",assumptionIds=null,assumedStates=null)="+newCash);
//				System.out.println("getCash(userId=" + userId+",assumptionIds="+assumptionIds+",assumedStates="+assumedStates+")="+newConditionalCash);
				for (int i = 1; i < engines.size(); i++) {
					// extract the values related to assets, from current engine
					float scoreUserEvToCompare = engines.get(i).scoreUserEv(userId, null, null);
					float conditionalScoreUserEvToCompare = engines.get(i).scoreUserEv(userId, assumptionIds, assumedStates);
					float newCashToCompare = engines.get(i).getCash(userId, null, null);
					float newConditionalCashToCompare = engines.get(i).getCash(userId, assumptionIds, assumedStates);
					if (!engines.get(i).isToDeleteResolvedNode()) {
						
					List<Float> scoreUserQuestionEvStatesToCompare = engines.get(i).scoreUserQuestionEvStates(userId, questionId, assumptionIds, assumedStates);
					List<Float> cashPerStatesToCompare = engines.get(i).getCashPerStates(userId, questionId, assumptionIds, assumedStates);
						
						// check that the number of states is matching
						assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
								scoreUserQuestionEvStates.size(), scoreUserQuestionEvStatesToCompare.size());
						assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
								cashPerStates.size(), cashPerStatesToCompare.size());
						assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
								cashPerStates.size(), cashPerStatesToCompare.size());
						
						// compare scores and min assets per state
						for (int state = 0; state < scoreUserQuestionEvStates.size(); state++) {
							assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
									scoreUserQuestionEvStates.get(state), scoreUserQuestionEvStatesToCompare.get(state), ASSET_ERROR_MARGIN);
							assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
									cashPerStates.get(state), cashPerStatesToCompare.get(state), ASSET_ERROR_MARGIN);
						}
					}
					// compare score and conditional score
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							scoreUserEv, scoreUserEvToCompare, ASSET_ERROR_MARGIN);
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							conditionalScoreUserEv, conditionalScoreUserEvToCompare, ASSET_ERROR_MARGIN);
					// compare cash and conditional cash
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							newCash, newCashToCompare, ASSET_ERROR_MARGIN);
					assertEquals(engines.get(i).toString() + ", user = "+ userId + ", question = " + questionId+ ", assumptions : " + assumptionIds+"="+assumedStates, 
							newConditionalCash, newConditionalCashToCompare, ASSET_ERROR_MARGIN);
					
					// check that the marginals after revert should be equals to before revert
					Map<Long, List<Float>> probListsToCompare = engines.get(i).getProbLists(null, null, null);
					assertTrue(engines.get(i).toString()+", probabilities="+probabilities+", probListsToCompare="+probListsToCompare,
							probabilities.size() >= probListsToCompare.size());
					for (Long question : probListsToCompare.keySet()) {
						for (int state = 0; state < probListsToCompare.get(question).size(); state++) {
							assertEquals(engines.get(i).toString()+", question = " + question + ", state = " + state
									+", probabilities="+probabilities+", probListsToCompare="+probListsToCompare,
									probabilities.get(question).get(state), probListsToCompare.get(question).get(state), PROB_ERROR_MARGIN);
						}
					}
					// if engine is configured to delete resolved questions, then it should not be retrievable from getProbLists
					for (Long question : resolvedQuestions) {
						// make sure marginals of resolved questions do not reappear
						if (engines.get(i).isToDeleteResolvedNode()) {
							assertFalse(engines.get(i).toString() +", probabilities="+probabilities+", probListsToCompare="+probListsToCompare + ", question = "+question,
									probListsToCompare.containsKey(question));
						}
					}
				}
			}
			
			
			if (isToTrace()) {
				System.out.print(tracer.toString());
			}
		}	// end of for : iteration
		
		System.out.println("\n\nQuantity of iterations close to limits: " + numEditsCloseToLimits + "\n\n");
	}
	
	private long getRandomUser(List<Long> userIDs, int maxUserNum) {
		long userId = (long) (random.nextDouble() * maxUserNum);
		if (!userIDs.contains(userId)) {
			userIDs.add(userId);
		}
		return userId;
	}
	
//	/**
//	 * Create all nodes within clique containing questionIds
//	 * @param questionIds
//	 * @param net
//	 * @param engines
//	 * @param enginesNotToChangeNetwork
//	 * @param nodesNotPresent
//	 * @param resolvedQuestions
//	 * @see #createNodesInMarkovBlanket(Long, Network, List, List, List, Collection)
//	 */
//	protected void createNodesInClique(List<Long> questionIds, Network net, List<MarkovEngineImpl> engines, 
//			List<MarkovEngineInterface> enginesNotToChangeNetwork, List<INode> nodesNotPresent, Collection<Long>resolvedQuestions) {
//		
//		// collect cliques containing questionIds
//		List<List<Long>> groups = new ArrayList<List<Long>>();
//		for (List<Long> group : engines.get(0).getQuestionAssumptionGroups()) {
//			if (group.containsAll(questionIds)) {
//				groups.add(group);
//			}
//		}
//		// store what nodes were added
//		List<INode> addedNodes = new ArrayList<INode>();
//		
//		// add questions/edges to engine
//		for (MarkovEngineImpl engine : engines) {
//			Long transactionKey = engine.startNetworkActions();
//			if (enginesNotToChangeNetwork.contains(engine)) {
//				// do not add question/edge to enginesNotToChangeNetwork
//				continue;
//			}
//			// for each group, add questions and edges
//			for (List<Long> group : groups) {
//				// add questions
//				for (Long questionId : group) {
//					Node nodeToCreate = net.getNode(questionId.toString());
//					// do not add question if it is in addedNodes or not in nodesNotPresent.
//					if (!addedNodes.contains(nodeToCreate) && nodesNotPresent.contains(nodeToCreate)) {
//						engine.addQuestion(transactionKey, new Date(), questionId, nodeToCreate.getStatesSize(), null);
//						addedNodes.add(nodeToCreate);
//					}
//				}
//				// at this point, all nodes in group were supposedly added
//				// add edges of all nodes in group, if nodes are already present
//				for (Long questionId : group) {
//					
//					// ids of parents to add
//					List<Long> parentQuestionIds = new ArrayList<Long>();	
//					
//					// this node contains all correct parents
//					Node completeNode = net.getNode(questionId.toString());
//					for (Node completeParentNode : completeNode.getParents()) {
//						if (!addedNodes.contains(completeParentNode) && engine.getProbabilisticNetwork().getNodeIndex(completeParentNode.getName()) < 0) {
//							// do not add edge from/to non-existing questions
//							continue;
//							// this should also avoid adding edges from/to resolved questions, if engine deletes resolved questions
//						}
//						// add question to idsOfParents
//						parentQuestionIds.add(Long.parseLong(completeParentNode.getName()));
//					}
//					if (!parentQuestionIds.isEmpty()) {
//						engine.addQuestionAssumption(transactionKey, new Date(), questionId, parentQuestionIds, null);
//					}
//				}
//			}
//			// actually create nodes/edges
//			engine.commitNetworkActions(transactionKey);
//			// make sure creation of the node/edge did not reappear the resolved nodes
//			if (engine.isToDeleteResolvedNode()) {
//				Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
//				assertFalse(engine.toString()+", resolved="+resolvedQuestions+", probLists="+probLists,new ArrayList<Long>(resolvedQuestions).removeAll(probLists.keySet()));
//			}
//		}
//		
//		// trace included nodes
//		if (isToTrace()) {
//			for (INode node : addedNodes) {
//				tracer.getAddedQuestions().add(Long.parseLong(node.getName()));
//				tracer.getAddedQuestionsStateSize().add(node.getStatesSize());
//			}
//		}
//		
//		// unregister the nodes which were added in this method
//		nodesNotPresent.removeAll(addedNodes);
//	}
	
	/**
	 * This method creates a question in the markov engine.
	 * It also creates the links between nodes which are already present in the engine
	 * This method is different from {@link #createNodesInMarkovBlanket(Long, Network, List, List, List, Collection)}, because
	 * this method is guaranteed to create only 1 node.
	 * Calls {@link MarkovEngineInterface#addQuestion(Long, Date, long, int, List)} and 
	 * {@link MarkovEngineInterface#addQuestionAssumption(Long, Date, long, List, List)}
	 * in order to create new nodes and arcs in the system.
	 * @param questionId
	 * @param net
	 * @param engines
	 * @param enginesNotToChangeNetwork
	 * @param nodesNotPresent
	 */
	protected void createNode(Long questionId, Network net, List<MarkovEngineImpl> engines, 
			List<MarkovEngineInterface> enginesNotToChangeNetwork, List<INode> nodesNotPresent, Collection<Long>resolvedQuestions) {
		
		INode nodeToCreate = net.getNode(questionId.toString());
		assertNotNull(questionId.toString(), nodeToCreate);
		
		// create this node and all arcs coming in or going out from this node
		for (MarkovEngineImpl engine : engines) {
			if (enginesNotToChangeNetwork.contains(engine)) {
				// do not add new node into this engine
				continue;
			}
			Map<Long, float[]> userToScoreAndCashMap = null;
			Map<Long, List<Float>> oldProbLists = null;
			if (isToCompareValuesBeforeAndAfterCreateNode) {
				oldProbLists = engine.getProbLists(null, null, null);
				userToScoreAndCashMap = new HashMap<Long, float[]>();
				for (Long user : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
					float[] scoreCash = {engine.scoreUserEv(user, null, null), engine.getCash(user, null, null)};
					userToScoreAndCashMap.put(user, scoreCash);
				}
			}
			Long transactionKey = engine.startNetworkActions();
			
			// create this node 
			if (nodesNotPresent.contains(nodeToCreate)) {
				engine.addQuestion(transactionKey, new Date(), questionId, nodeToCreate.getStatesSize(), null);
			}
			
			// extract the network managed by this engine, so that we can find what nodes are visible to the current engine
			ProbabilisticNetwork netME = engine.getProbabilisticNetwork();
			
			// check if parents of the node being created exist. If so, generate edge
			List<Long> parentQuestionIds = new ArrayList<Long>();
			for (INode parent : nodeToCreate.getParentNodes()) {
				if (netME.getNodeIndex(parent.getName()) >= 0) {
					// this parent exists. Add parent's ID into parentsIDs, so that an edge will be created from parent to the new node
					parentQuestionIds.add(Long.parseLong(parent.getName()));
				}
			}
			
			// add the edges at once
			if (!parentQuestionIds.isEmpty()) {
				engine.addQuestionAssumption(transactionKey, new Date(), questionId, parentQuestionIds, null);
			}
			
			// prepare the list containing only questionId, to be used in order to add questionId as parent of other nodes
			parentQuestionIds = new ArrayList<Long>(1);
			parentQuestionIds.add(questionId);	
			// create the edges from the new node to children
			for (INode child : nodeToCreate.getChildNodes()) {
				if (netME.getNodeIndex(child.getName()) >= 0) {
					// This child exists. Add the edges one by one
					engine.addQuestionAssumption(transactionKey, new Date(), Long.parseLong(child.getName()), parentQuestionIds, null);
				}
			}
//			if (nodesToTraceCliquePotentials != null) {
//				System.out.println("\n Before creating node " + questionId);
//				if (engines.get(0).getProbabilisticNetwork().getJunctionTree() != null) {
//					for (Clique clique : engines.get(0).getProbabilisticNetwork().getJunctionTree().getCliques()) {
//						boolean hasNodes = false;
//						for (Long id : nodesToTraceCliquePotentials) {
//							Node node = engines.get(0).getProbabilisticNetwork().getNode(id.toString());
//							if (node != null && clique.getNodes().contains(node)) {
//								hasNodes = true;
//								break;
//							}
//						}
//						if (hasNodes) {
//							System.out.print("\nClique = [");
//							for (int i = 0; i < clique.getProbabilityFunction().getVariablesSize(); i++) {
//								System.out.print(clique.getProbabilityFunction().getVariableAt(i));
//							}
//							System.out.println("]");
//							for (int i = 0; i < clique.getProbabilityFunction().tableSize(); i++) {
//								System.out.println(clique.getProbabilityFunction().getValue(i));
//							}
//						}
//					}
//				}
////				try { System.out.print("38="+engines.get(0).getProbList(38L, null, null)); } catch (Exception e) {}
////				try { System.out.print("26="+engines.get(0).getProbList(26L, null, null));} catch (Exception e) {}
//				System.out.println();
//			}
			
			// commit transaction in order to actually create the nodes & all edges. This will re-run the history
			engine.commitNetworkActions(transactionKey);
//			if (nodesToTraceCliquePotentials != null) {
//				System.out.println("\n After creating node " + questionId);
//				for (Clique clique : engines.get(0).getProbabilisticNetwork().getJunctionTree().getCliques()) {
//					boolean hasNodes = false;
//					for (Long id : nodesToTraceCliquePotentials) {
//						Node node = engines.get(0).getProbabilisticNetwork().getNode(id.toString());
//						if (node != null && clique.getNodes().contains(node)) {
//							hasNodes = true;
//							break;
//						}
//					}
//					if (hasNodes) {
//						System.out.print("\nClique = [");
//						for (int i = 0; i < clique.getProbabilityFunction().getVariablesSize(); i++) {
//							System.out.print(clique.getProbabilityFunction().getVariableAt(i));
//						}
//						System.out.println("]");
//						for (int i = 0; i < clique.getProbabilityFunction().tableSize(); i++) {
//							System.out.println(clique.getProbabilityFunction().getValue(i));
//						}
//					}
//				}
//				try { System.out.print("38="+engines.get(0).getProbList(38L, null, null)); } catch (Exception e) {}
//				try { System.out.print("26="+engines.get(0).getProbList(26L, null, null));} catch (Exception e) {}
//				System.out.println();
//			}
			
			// compare values before and after creation of node/edge
			if (isToCompareValuesBeforeAndAfterCreateNode) {
				// compare marginals
				Map<Long, List<Float>> newProbLists = engine.getProbLists(null, null, null);
				// shall have more nodes than before
				assertTrue(newProbLists.size() > oldProbLists.size()); 
				for (Long id : oldProbLists.keySet()) {
					List<Float> oldProb = oldProbLists.get(id);
					List<Float> newProb = newProbLists.get(id);
					assertEquals(oldProb.size(), newProb.size());
					for (int i = 0; i < oldProb.size(); i++) {
						assertEquals("Node=" + id + ", index=" + i + ", old="+oldProbLists+"; new=" + newProbLists,
								oldProb.get(i), newProb.get(i), RELAXED_PROB_ERROR_MARGIN);
					}
				}
				// compare user's score and cash
				for (Long user : userToScoreAndCashMap.keySet()) {
					float[] oldScoreCash = userToScoreAndCashMap.get(user);
					float[] newScoreCash = {engine.scoreUserEv(user, null, null), engine.getCash(user, null, null)};
					assertEquals("user="+user+";"+oldScoreCash+newScoreCash, 
							oldScoreCash[0], newScoreCash[0], ASSET_ERROR_MARGIN);
					assertEquals("user="+user+";"+oldScoreCash+newScoreCash, 
							oldScoreCash[1], newScoreCash[1], ASSET_ERROR_MARGIN);
				}
			}
		}
		
		// mark this node as created (update nodesNotPresent) and also update tracer.
		if (nodesNotPresent.contains(nodeToCreate)) {
			if (isToTrace()) {
				tracer.getAddedQuestions().add(questionId);
				tracer.getAddedQuestionsStateSize().add(nodeToCreate.getStatesSize());
			}
			nodesNotPresent.remove(nodeToCreate);
		}
	}

	/**
	 * This method creates a question and all questions of its markov blanket.
	 * Calls {@link MarkovEngineInterface#addQuestion(Long, Date, long, int, List)} and 
	 * {@link MarkovEngineInterface#addQuestionAssumption(Long, Date, long, List, List)}
	 * in order to create new nodes and arcs in the system.
	 * @param questionId
	 * @param net
	 * @param engines
	 * @param enginesNotToChangeNetwork
	 * @param nodesNotPresent
	 */
	protected void createNodesInMarkovBlanket(Long questionId, Network net, List<MarkovEngineImpl> engines, 
			List<MarkovEngineInterface> enginesNotToChangeNetwork, List<INode> nodesNotPresent, Collection<Long>resolvedQuestions) {
		
		INode nodeToCreate = net.getNode(questionId.toString());
		assertNotNull(questionId.toString(), nodeToCreate);
		
		// variables for comparison
		Map<Long, float[]> userToScoreAndCashMap = null;
		Map<Long, List<Float>> oldProbLists = null;
		
		// create all nodes in markov blanket
		for (MarkovEngineImpl engine : engines) {
			if (enginesNotToChangeNetwork.contains(engine)) {
				// do not add new node into this engine
				continue;
			}
			if (isToCompareValuesBeforeAndAfterCreateNode) {
				oldProbLists = engine.getProbLists(null, null, null);
				userToScoreAndCashMap = new HashMap<Long, float[]>();
				for (Long user : engine.getUserToAssetAwareAlgorithmMap().keySet()) {
					float[] scoreCash = {engine.scoreUserEv(user, null, null), engine.getCash(user, null, null)};
					userToScoreAndCashMap.put(user, scoreCash);
				}
			}
			if (nodesNotPresent.contains(nodeToCreate)) {
				engine.addQuestion(null, new Date(), questionId, nodeToCreate.getStatesSize(), null);
				// make sure creation of the node did not reappear the resolved nodes
				if (engine.isToDeleteResolvedNode()) {
					Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
					assertFalse(engine.toString()+", resolved="+resolvedQuestions+", probLists="+probLists,new ArrayList<Long>(resolvedQuestions).removeAll(probLists.keySet()));
				}
			}
		}
		
		if (nodesNotPresent.contains(nodeToCreate)) {
			// mark this node as created.
			if (isToTrace()) {
				tracer.getAddedQuestions().add(questionId);
				tracer.getAddedQuestionsStateSize().add(nodeToCreate.getStatesSize());
			}
			nodesNotPresent.remove(nodeToCreate);
		}
		
		List<Long> parentQuestionIds = new ArrayList<Long>();
		// extract child node in the last ME, so that we can check for existence of edges
		Node childInLastME = engines.get(engines.size()-1).getProbabilisticNetwork().getNode(nodeToCreate.getName());
		// add edges if parents are already present in the system
		for (INode parent : nodeToCreate.getParentNodes()) {
			if (!nodesNotPresent.contains(parent)) {
				Node parentInLastME = engines.get(engines.size()-1).getProbabilisticNetwork().getNode(parent.getName());
				// do not re-add edges which are already present
				if (engines.get(engines.size()-1).getProbabilisticNetwork().getEdge(parentInLastME, childInLastME) == null) {
					parentQuestionIds.add(Long.parseLong(parent.getName())); // the parent is already present in the system. Add edge
				}
			}
		}
		if (!parentQuestionIds.isEmpty() && !new ArrayList<Long>(resolvedQuestions).removeAll(parentQuestionIds)) {
			// if there are parents and they were not resolved, then add edge
//			System.out.println("addQuestionAssumption(childQuestionId="+questionId+",parentQuestionIds="+parentQuestionIds+")");
			for (MarkovEngineImpl engine : engines) {
				if (enginesNotToChangeNetwork.contains(engine)) {
					// do not add new node into this engine
					continue;
				}
				engine.addQuestionAssumption(null, new Date(), questionId, parentQuestionIds, null);
				// make sure creation of the edge did not reappear the resolved nodes
				if (engine.isToDeleteResolvedNode()) {
					Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
					assertFalse(engine.toString()+", resolved="+resolvedQuestions+", probLists="+probLists,new ArrayList<Long>(resolvedQuestions).removeAll(probLists.keySet()));
				}
			}
		}
		
		// add edges if children are already present in the system
		for (INode child : nodeToCreate.getChildNodes()) {
			if (!nodesNotPresent.contains(child)&& !resolvedQuestions.contains(Long.parseLong(child.getName()))) {
				// the node is already present in the system and not resolved. Add edge
				for (MarkovEngineImpl engine : engines) {
					if (enginesNotToChangeNetwork.contains(engine)) {
						// do not add new node into this engine
						continue;
					}
					// extract child and parent in current engine, so that exact comparison does not fail
					Node childInCurrentME = engine.getProbabilisticNetwork().getNode(child.getName());
					if (childInCurrentME == null) {
						continue;
					}
					Node parentInCurrentME = engine.getProbabilisticNetwork().getNode(nodeToCreate.getName());
					if (parentInCurrentME == null) {
						continue;
					}
					// only create edge if it does not exist
					if (engine.getProbabilisticNetwork().getEdge(parentInCurrentME, childInCurrentME) == null) {
						engine.addQuestionAssumption(null, new Date(), Long.parseLong(child.getName()), Collections.singletonList(Long.parseLong(nodeToCreate.getName())), null);
					}
					// make sure creation of the edge did not reappear the resolved nodes
					if (engine.isToDeleteResolvedNode()) {
						Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
						assertFalse(engine.toString()+", resolved="+resolvedQuestions+", probLists="+probLists,new ArrayList<Long>(resolvedQuestions).removeAll(probLists.keySet()));
					}
				}
			}
			// add edge if siblings (parent of my child) are present in the system
			parentQuestionIds = new ArrayList<Long>();
			// add edges if parents are already present in the system
			for (INode parent : child.getParentNodes()) {
				if (!nodesNotPresent.contains(parent) && !parent.equals(nodeToCreate)) {
					// the parent is already present in the system. Add edge
					parentQuestionIds.add(Long.parseLong(parent.getName()));
				}
			}
			if (!parentQuestionIds.isEmpty()&& !new ArrayList<Long>(resolvedQuestions).removeAll(parentQuestionIds)) {
				parentQuestionIds.add(questionId);
				for (MarkovEngineImpl engine : engines) {
					if (enginesNotToChangeNetwork.contains(engine)) {
						// do not add new node into this engine
						continue;
					}
					if (nodesNotPresent.contains(child)) {
						engine.addQuestion(null, new Date(), Long.parseLong(child.getName()), child.getStatesSize(), null);
						// make sure creation of the node did not reappear the resolved nodes
						if (engine.isToDeleteResolvedNode()) {
							Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
							assertFalse(engine.toString()+", resolved="+resolvedQuestions+", probLists="+probLists,new ArrayList<Long>(resolvedQuestions).removeAll(probLists.keySet()));
						}
					}
					// extract child and parent in current engine, so that exact comparison does not fail
					Node childInCurrentME = engine.getProbabilisticNetwork().getNode(child.getName());
					if (childInCurrentME == null) {
						continue;
					}
					// remove the parents which are already in ME
					List<Long> parentQuestionIdsToAdd = new ArrayList<Long>(parentQuestionIds.size());
					for (Long parentId : parentQuestionIds) {
						Node parentInCurrentME = engine.getProbabilisticNetwork().getNode(parentId.toString());
						if (engine.getProbabilisticNetwork().getEdge(parentInCurrentME, childInCurrentME) == null) {
							parentQuestionIdsToAdd.add(parentId);
						}
					}
					if (parentQuestionIdsToAdd.isEmpty()) {
						continue;
					}
					// only create edge if it does not exist
					if (!parentQuestionIdsToAdd.isEmpty()) {
						engine.addQuestionAssumption(null, new Date(), Long.parseLong(child.getName()), parentQuestionIdsToAdd, null);
					}
					// make sure creation of the edge did not reappear the resolved nodes
					if (engine.isToDeleteResolvedNode()) {
						Map<Long, List<Float>> probLists = engine.getProbLists(null, null, null);
						assertFalse(engine.toString()+", resolved="+resolvedQuestions+", probLists="+probLists,new ArrayList<Long>(resolvedQuestions).removeAll(probLists.keySet()));
					}
					// compare values before and after creation of node/edge
					if (isToCompareValuesBeforeAndAfterCreateNode) {
						// compare marginals
						Map<Long, List<Float>> newProbLists = engine.getProbLists(null, null, null);
						// shall have more nodes than before
						assertTrue(newProbLists.size() > oldProbLists.size()); 
						for (Long id : oldProbLists.keySet()) {
							List<Float> oldProb = oldProbLists.get(id);
							List<Float> newProb = newProbLists.get(id);
							assertEquals(oldProb.size(), newProb.size());
							for (int i = 0; i < oldProb.size(); i++) {
								assertEquals("Node=" + id + ", index=" + i + ", old="+oldProbLists+"; new=" + newProbLists,
										oldProb.get(i), newProb.get(i), PROB_ERROR_MARGIN);
							}
						}
						// compare user's score and cash
						for (Long user : userToScoreAndCashMap.keySet()) {
							float[] oldScoreCash = userToScoreAndCashMap.get(user);
							float[] newScoreCash = {engine.scoreUserEv(user, null, null), engine.getCash(user, null, null)};
							assertEquals("user="+user+";"+oldScoreCash+newScoreCash, 
									oldScoreCash[0], newScoreCash[0], ASSET_ERROR_MARGIN);
							assertEquals("user="+user+";"+oldScoreCash+newScoreCash, 
									oldScoreCash[1], newScoreCash[1], ASSET_ERROR_MARGIN);
						}
					}
				}
				if (nodesNotPresent.contains(child)) {
					nodesNotPresent.remove(child);
					if (isToTrace()) {
						tracer.getAddedQuestions().add(Long.parseLong(child.getName()));
						tracer.getAddedQuestionsStateSize().add(child.getStatesSize());
					}
				}
			}
		}
		
	}


	/**
	 * Test method for the DEF network. Testing the following conditions
	 * in 4 engines (respectively the Markov Engine - the official - Markov Engine with q-values,
	 * Brute force markov engine - product of cliques / product of separators, and Brute force
	 * markov engine - product of CPTs):
	 * <br/>
	 * a.) 5-point min-q values test regarding the edit bound; expect to see corresponding 
	 * q<1, =1, >1 respectively. <br/>
	 * b.) marginal probability on individual variable.<br/>
	 * c.) min-q values after a user confirms a trade.<br/>
	 * d.) min-q state. (not tested in this version)<br/>
	 * e.) The expected score.<br/>
	 * f. ) conditional min-q and expected score on randomly given states. 
	 * How many random given states depends on network size. 
	 * We choose floor(0.3*numberOfVariablesInTheNet).<br/>
	 * g.) An userfs asset table is not changed when other user makes edit.<br/>
	 * <br/>
	 * Methodology (using total of 3 users):<br/>
	 * (1) Randomly choose one user; <br/>
	 * (2) Randomly choose one node, and randomly choose assumption set in the same clique of the node. 
	 * If the clique size is bigger than 3, the size of assumption set has to be at least 2.<br/>
	 * <br/>
	 * <br/>
	 * Definition: 5-point min-q test is to verify the min-q values returned after trades are 
	 * made on specific edit around boundary over the edit limit. 
	 * In particular, we choose 5 point of probability edit: <br/>
	 * (1) the probability close to but smaller than the lower bound;<br/> 
	 * (2) the probability exactly on the lower bound;<br/> 
	 * (3) random probability in between the bound;<br/> 
	 * (4) the probability exactly on the upper bound;<br/> 
	 * (5) the probability close to but bigger than the upper bound;<br/> 
	 */
	public final void testDEF5Points() {
		
		// most basic assertion
		assertNotNull(engines);
		assertFalse(engines.isEmpty());
		
		for (MarkovEngineImpl engine : engines) {
			if (engine.isToUseQValues()) {
				engine.setDefaultInitialAssetTableValue((float) engine.getQValuesFromScore(1000f));
			} else {
				engine.setDefaultInitialAssetTableValue(1000f);
			}
		}
		
		// initialize network
		Map<Long,Integer> questionsToQuantityOfStatesMap = new HashMap<Long, Integer>();
		// generate the DEF network
		for (MarkovEngineInterface engine : engines) {
			long transactionKey = engine.startNetworkActions();
			// create nodes D, E, F
			engine.addQuestion(transactionKey, new Date(), 0x0D, 2, null);	// question D has ID = hexadecimal D. CPD == null -> linear distro
			questionsToQuantityOfStatesMap.put(0x0DL, 2);
			engine.addQuestion(transactionKey, new Date(), 0x0E, 2, null);	// question E has ID = hexadecimal E. CPD == null -> linear distro
			questionsToQuantityOfStatesMap.put(0x0EL,2);
			engine.addQuestion(transactionKey, new Date(), 0x0F, 2, null);	// question F has ID = hexadecimal F. CPD == null -> linear distro
			questionsToQuantityOfStatesMap.put(0x0FL,2);
			// create edge D->E 
			engine.addQuestionAssumption(transactionKey, new Date(), 0x0E, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
			// create edge D->F
			engine.addQuestionAssumption(transactionKey, new Date(), 0x0F, Collections.singletonList((long) 0x0D), null);	// cpd == null -> linear distro
			// commit changes
			engine.commitNetworkActions(transactionKey);
		}
		
		// Randomly create 3 user IDs
		List<Long> userIDs = new ArrayList<Long>(3);
		do {
			userIDs.clear();
			Set<Long> userFilter = new HashSet<Long>(3);
			userFilter.add((long) (random.nextDouble()*0x0F));
			userFilter.add((long) (random.nextDouble()*0x0F));
			userFilter.add((long) (random.nextDouble()*0x0F));
			userIDs.addAll(userFilter);
		} while (userIDs.size() != 3);
		
		assertNotNull(questionsToQuantityOfStatesMap);
		this.runTestAssumingInitializedNetwork(questionsToQuantityOfStatesMap, new HashMap<MarkovEngineImpl, Long>(), userIDs);
	}	

	
	/**
	 * Test method for the networks loaded from files identified by the names in {@link #getFileNames()}.
	 * Testing the following conditions
	 * in 4 engines (respectively the Markov Engine - the official - Markov Engine with q-values,
	 * Brute force markov engine - product of cliques / product of separators, and Brute force
	 * markov engine - product of CPTs):
	 * <br/>
	 * a.) 5-point min-q values test regarding the edit bound; expect to see corresponding 
	 * q<1, =1, >1 respectively. <br/>
	 * b.) marginal probability on individual variable.<br/>
	 * c.) min-q values after a user confirms a trade.<br/>
	 * d.) min-q state. (not tested in this version)<br/>
	 * e.) The expected score.<br/>
	 * f. ) conditional min-q and expected score on randomly given states. 
	 * How many random given states depends on network size. 
	 * We choose floor(0.3*numberOfVariablesInTheNet).<br/>
	 * g.) An userfs asset table is not changed when other user makes edit.<br/>
	 * <br/>
	 * Methodology (using total of 3 users):<br/>
	 * (1) Randomly choose one user; <br/>
	 * (2) Randomly choose one node, and randomly choose assumption set in the same clique of the node. 
	 * If the clique size is bigger than 3, the size of assumption set has to be at least 2.<br/>
	 * <br/>
	 * <br/>
	 * Definition: 5-point min-q test is to verify the min-q values returned after trades are 
	 * made on specific edit around boundary over the edit limit. 
	 * In particular, we choose 5 point of probability edit: <br/>
	 * (1) the probability close to but smaller than the lower bound;<br/> 
	 * (2) the probability exactly on the lower bound;<br/> 
	 * (3) random probability in between the bound;<br/> 
	 * (4) the probability exactly on the upper bound;<br/> 
	 * (5) the probability close to but bigger than the upper bound;<br/> 
	 */
	public final void testFiles() {
		
		// most basic assertion
		assertNotNull(engines);
		assertFalse(engines.isEmpty());
		
		assertNotNull(getFileNames());
		assertFalse(getFileNames().length <= 0);
		
		NetIO io = new NetIO();
		
		Graph network = null;
		for (String fileName : getFileNames()) {
			System.out.println("Reading file " + fileName);
			try {
				network = io.load(new File(getClass().getClassLoader().getResource(fileName).getFile()));
			} catch (Exception e) {
				e.printStackTrace();
				fail(e.getMessage());
			} 
			assertNotNull(network);
			
			// initialize network based on network loaded from file
			Map<Long,Integer> questionsToQuantityOfStatesMap = new HashMap<Long, Integer>();
			// generate the  network
			for (MarkovEngineInterface engine : engines) {
				engine.initialize();
				long transactionKey = engine.startNetworkActions();
				// create nodes
				for (Node node : network.getNodes()) {
					engine.addQuestion(transactionKey, new Date(), Long.parseLong(node.getName()), node.getStatesSize(), null); // assume uniform distribution for all nodes 
					questionsToQuantityOfStatesMap.put(Long.parseLong(node.getName()), node.getStatesSize());
				}
				// create edges 
				for (Node node : network.getNodes()) {
					List<Long> parentIds = new ArrayList<Long>();
					for (Node parent : node.getParents()) {
						parentIds.add(Long.parseLong(parent.getName()));
					}
					if (parentIds.isEmpty() && random.nextDouble() <= .5) {
						parentIds = null;
					}
					engine.addQuestionAssumption(transactionKey, new Date(), Long.parseLong(node.getName()), parentIds, null);	// cpd == null -> linear distro
				}
				// commit changes
				engine.commitNetworkActions(transactionKey);
			}
			
			// Randomly create 3 user IDs
			List<Long> userIDs = new ArrayList<Long>(3);
			do {
				userIDs.clear();
				Set<Long> userFilter = new HashSet<Long>(3);
				userFilter.add((long) (random.nextDouble()*0x0F));
				userFilter.add((long) (random.nextDouble()*0x0F));
				userFilter.add((long) (random.nextDouble()*0x0F));
				userIDs.addAll(userFilter);
			} while (userIDs.size() != 3);
			
			assertNotNull(questionsToQuantityOfStatesMap);
			this.runTestAssumingInitializedNetwork(questionsToQuantityOfStatesMap, new HashMap<MarkovEngineImpl, Long>(), userIDs);
		}
	}	
	

	/**
	 * This test case will run the same test of {@link #testFiles()},
	 * but the engines in {@link #engines} will run in a single transaction
	 * except for the 1st engine.
	 */
	public final void testFilesIn1Transaction() {
		
		// markov engine which commits every trade 1-by-1
		engines.add(0, (MarkovEngineImpl) MarkovEngineImpl.getInstance(2f, 100f, 1000f));
		
		// engine which commits 2 times: add questions, commit (1st time), add trades, commit (2nd time)
		engines.add((MarkovEngineImpl) MarkovEngineImpl.getInstance(2f, 100f, 1000f));
		
		// most basic assertion
		assertNotNull(engines);
		assertFalse(engines.isEmpty());
		
		assertNotNull(getFileNames());
		assertFalse(getFileNames().length <= 0);
		
		NetIO io = new NetIO();
		
		Graph network = null;
		for (String fileName : getFileNames()) {
			System.out.println("Reading file " + fileName);
			try {
				network = io.load(new File(getClass().getClassLoader().getResource(fileName).getFile()));
			} catch (Exception e) {
				e.printStackTrace();
				fail(e.getMessage());
			} 
			assertNotNull(network);
			
			
			// initialize network based on network loaded from file
			Map<Long,Integer> questionsToQuantityOfStatesMap = new HashMap<Long, Integer>();
			
			// for the 1st engine, generate the DEF network and commit transaction
			engines.get(0).initialize();
			
			long transactionKey = engines.get(0).startNetworkActions();
			
			// create nodes
			for (Node node : network.getNodes()) {
				engines.get(0).addQuestion(transactionKey, new Date(), Long.parseLong(node.getName()), node.getStatesSize(), null); // assume uniform distribution for all nodes 
				questionsToQuantityOfStatesMap.put(Long.parseLong(node.getName()), node.getStatesSize());
			}
			// create edges 
			for (Node node : network.getNodes()) {
				List<Long> parentIds = new ArrayList<Long>();
				for (Node parent : node.getParents()) {
					parentIds.add(Long.parseLong(parent.getName()));
				}
				if (parentIds.isEmpty() && random.nextDouble() <= .5) {
					parentIds = null;
				}
				// cpd == null -> linear distro
				engines.get(0).addQuestionAssumption(transactionKey, new Date(), Long.parseLong(node.getName()), parentIds, null);	
			}
			// commit transaction of 1st engine
			engines.get(0).commitNetworkActions(transactionKey);
			
			// this map stores what transaction key shall be used by the trades of each engine. If none, each trade will open its own transaction
			Map<MarkovEngineImpl, Long> uncommittedTransactionKeyMap = new HashMap<MarkovEngineImpl, Long>();
			
			// for other engines, generate DEF network and do not commit the transaction
			for (int i = 1; i < engines.size(); i++) {
				MarkovEngineImpl engine = engines.get(i);
				
				engine.initialize();
				
				transactionKey = engine.startNetworkActions();
				uncommittedTransactionKeyMap.put(engine, transactionKey);
				
				// create nodes
				for (Node node : network.getNodes()) {
					engine.addQuestion(transactionKey, new Date(), Long.parseLong(node.getName()), node.getStatesSize(), null); // assume uniform distribution for all nodes 
					questionsToQuantityOfStatesMap.put(Long.parseLong(node.getName()), node.getStatesSize());
				}
				// create edges 
				for (Node node : network.getNodes()) {
					List<Long> parentIds = new ArrayList<Long>();
					for (Node parent : node.getParents()) {
						parentIds.add(Long.parseLong(parent.getName()));
					}
					if (parentIds.isEmpty() && random.nextDouble() <= .5) {
						parentIds = null;
					}
					engine.addQuestionAssumption(transactionKey, new Date(), Long.parseLong(node.getName()), parentIds, null);	// cpd == null -> linear distro
				}
				// do not commit changes
			}
			
			// we can commit the last engine, but register new transaction to uncommittedTransactionKeyMap so that all trades are committed at once
			engines.get(engines.size()-1).commitNetworkActions(uncommittedTransactionKeyMap.get(engines.get(engines.size()-1)));
			uncommittedTransactionKeyMap.put(engines.get(engines.size()-1), engines.get(engines.size()-1).startNetworkActions());

			// Randomly create 3 user IDs
			List<Long> userIDs = new ArrayList<Long>(3);
			do {
				userIDs.clear();
				Set<Long> userFilter = new HashSet<Long>(3);
				userFilter.add((long) (random.nextDouble()*0x0F));
				userFilter.add((long) (random.nextDouble()*0x0F));
				userFilter.add((long) (random.nextDouble()*0x0F));
				userIDs.addAll(userFilter);
			} while (userIDs.size() != 3);
			
			assertNotNull(questionsToQuantityOfStatesMap);
			this.runTestAssumingInitializedNetwork(questionsToQuantityOfStatesMap, uncommittedTransactionKeyMap, userIDs);
			
			// commit all uncommitted transactions
			for (MarkovEngineImpl uncommittedEngine : uncommittedTransactionKeyMap.keySet()) {
				uncommittedEngine.commitNetworkActions(uncommittedTransactionKeyMap.get(uncommittedEngine));
			}
			// all transactions were committed.
			uncommittedTransactionKeyMap.clear();
			
			// b.) marginal probability on individual variable.
			for (int i = 1; i < engines.size(); i++) {
				Map<Long, List<Float>> probabilities = engines.get(0).getProbLists(null, null, null);
				MarkovEngineImpl engine = engines.get(i);
				Map<Long, List<Float>> probToCompare = engine.getProbLists(null, null, null);
				assertNotNull(engine.toString(), probToCompare);
				assertEquals(engine.toString(), probabilities.size(), probToCompare.size());
				
				// compare marginals
				for (Long id : probabilities.keySet()) {
					List<Float> marginal = probabilities.get(id);
					List<Float> marginalToCompare = probToCompare.get(id);
					assertEquals(engine.toString(), marginal.size(), marginalToCompare.size());
					for (int state = 0; state < marginal.size(); state++) {
						assertEquals(engine.toString() + ", question = " + id + ", state = " + state,  
								marginal.get(state), 
								marginalToCompare.get(state), 
								((engine instanceof CPTBruteForceMarkovEngine)?RELAXED_PROB_ERROR_MARGIN:PROB_ERROR_MARGIN)
						);
					}
				}
				for (Long questionId : questionsToQuantityOfStatesMap.keySet()) {
					for (Long userId : userIDs) {
						List<Long> assumptionIds = this.getRandomAssumptions(questionId, uncommittedTransactionKeyMap, true);
						List<Integer> assumedStates = this.getRandomAssumptionStates(assumptionIds);
						
						List<Float> scoreUserQuestionEvStatesAfterTrade = engine.scoreUserQuestionEvStates(userId, questionId, assumptionIds , assumedStates);
						assertEquals(engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
								(int)questionsToQuantityOfStatesMap.get(questionId), 
								(int)scoreUserQuestionEvStatesAfterTrade.size()
						);
						
						ScoreSummary scoreSummaryOrig= engines.get(0).getScoreSummaryObject(userId, questionId, assumptionIds, assumedStates);
						
						float minimum = engines.get(0).getCash(userId, null, null);
						
						// c.) min-q values after a user confirms a trade.
//						if (Math.abs(minimum - engine.getCash(userId, null, null)) >
//						((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
//							engines.get(0).getCash(userId, null, null);
//							engine.getCash(userId, null, null);
//						}
						assertEquals(engine.toString(), minimum, engine.getCash(userId, null, null), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN));
						// e.) The expected score.
						assertEquals(
								engine.toString(), 
								engines.get(0).scoreUserEv(userId, null, null), 
								engine.scoreUserEv(userId, null, null), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						// f. ) conditional min-q and expected score on randomly given states. How many random given states depends on network size. We choose floor(0.3*numberOfVariablesInTheNet).
//						if (Math.abs(engines.get(0).getCash(userId, assumptionIds, assumedStates) - engine.getCash(userId, assumptionIds, assumedStates))
//								> ((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)) {
//							engines.get(0).getCash(userId, assumptionIds, assumedStates);
//							engine.getCash(userId, assumptionIds, assumedStates);
//						}
						assertEquals(
								engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
								engines.get(0).getCash(userId, assumptionIds, assumedStates), 
								engine.getCash(userId, assumptionIds, assumedStates), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						assertEquals(
								engine.toString() + userId + " , " + assumptionIds + assumedStates, 
								engines.get(0).scoreUserEv(userId, assumptionIds, assumedStates), 
								engine.scoreUserEv(userId, assumptionIds, assumedStates), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						
						// b.) marginal probability on individual variable (with assumptions).
						probabilities = engines.get(0).getProbLists(null, assumptionIds, assumedStates);
						probToCompare = engine.getProbLists(null, assumptionIds, assumedStates);
						assertNotNull(engine.toString(), probToCompare);
						assertEquals(engine.toString(), probabilities.size(), probToCompare.size());
						
						// compare marginals with assumptions
						for (Long id : probabilities.keySet()) {
							List<Float> marginal = probabilities.get(id);
							List<Float> marginalToCompare = probToCompare.get(id);
							assertEquals(engine.toString(), marginal.size(), marginalToCompare.size());
							for (int state = 0; state < marginal.size(); state++) {
								assertEquals(engine.toString() + ", question = " + id + ", state = " + state,  
										marginal.get(state), 
										marginalToCompare.get(state), 
										((engine instanceof CPTBruteForceMarkovEngine)?RELAXED_PROB_ERROR_MARGIN:PROB_ERROR_MARGIN)
								);
							}
						}
						
						
						ScoreSummary scoreSummaryObject = engine.getScoreSummaryObject(userId, null, assumptionIds, assumedStates);
						assertNotNull(scoreSummaryObject);
						assertEquals(
								engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
								engines.get(0).getCash(userId, assumptionIds, assumedStates), 
								scoreSummaryObject.getCash(), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						assertEquals(
								engine.toString() + userId + " , assumption=" + assumptionIds+ "=" + assumedStates, 
								scoreSummaryOrig.getCash(), 
								scoreSummaryObject.getCash(), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						assertEquals(
								engine.toString() + userId + " , " + assumptionIds + assumedStates, 
								engines.get(0).scoreUserEv(userId, assumptionIds, assumedStates), 
								scoreSummaryObject.getScoreEV(), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						assertEquals(
								engine.toString() + userId + " , " + assumptionIds + assumedStates, 
								scoreSummaryOrig.getScoreEV(), 
								scoreSummaryObject.getScoreEV(), 
								((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
						);
						float sumOfScoreComponents = 0f;
						if (engine.isToReturnEVComponentsAsScoreSummary()) {
							// the score summary contains clique potential * values in asset tables
							for (SummaryContribution contribution : scoreSummaryObject.getScoreComponents()) {
								sumOfScoreComponents += contribution.getContributionToScoreEV();
							}
							for (SummaryContribution contribution : scoreSummaryObject.getIntersectionScoreComponents()) {
								sumOfScoreComponents += contribution.getContributionToScoreEV();
							}
							assertFalse(engine.toString() + userId + " , " + assumptionIds + assumedStates, Float.isNaN(sumOfScoreComponents));
							assertEquals("["+ engines.indexOf(engine) + "]"+
									engine.toString() + userId + " , " + assumptionIds + assumedStates, 
									scoreSummaryObject.getScoreEV(), 
									sumOfScoreComponents, 
									((engine instanceof CPTBruteForceMarkovEngine)?ASSET_ERROR_MARGIN_CPT_BRUTE_FORC:ASSET_ERROR_MARGIN)
							);
						} else {
							// the score summary contains expected score per state
							List<Long> tradedQuestions = new ArrayList<Long>(engine.getTradedQuestions(userId)); // extract questions traded by the user
							for (int questionIndex = 0; questionIndex < tradedQuestions.size(); questionIndex++) {
								
								sumOfScoreComponents = 0f;	// prepare to calculate the sum of (<Expected score given state> * <marginal of state>)
								
								for (int stateIndex = 0; stateIndex < probabilities.get(tradedQuestions.get(questionIndex)).size(); stateIndex++) {
									
									// calculate the index in scoreComponent which is related to questionIndex and stateIndex.
									// this is <number of questions handled so far> * <number of states of such questions> + stateIndex
									int scoreComponentIndex = stateIndex;	
									for (int j = 0; j < tradedQuestions.size(); j++) {
										if (j == questionIndex) {
											break;
										}
										// the number of states of a question can be retrieved from the size of an entry in engine.getProbLists
										scoreComponentIndex += probabilities.get(tradedQuestions.get(j)).size();
									}
									
									// assert that getScoreComponents is related to current question
									assertEquals("["+ engines.indexOf(engine) + "]"
											+ engine.toString()+ " , " + assumptionIds + assumedStates
											+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
											1, scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getQuestions().size());
									assertEquals("["+ engines.indexOf(engine) + "]"
											+ engine.toString()+ " , " + assumptionIds + assumedStates
											+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
											tradedQuestions.get(questionIndex),
											scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getQuestions().get(0)
									);
									
									// assert that getScoreComponents is related to current state
									assertEquals("["+ engines.indexOf(engine) + "]"
											+ engine.toString()+ " , " + assumptionIds + assumedStates
											+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
											1, scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getStates().size() );
									assertEquals("["+ engines.indexOf(engine) + "]"
											+ engine.toString() + " , " + assumptionIds + assumedStates
											+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex) + ", state = " + stateIndex, 
											stateIndex,
											scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getStates().get(0).intValue()
									);
									
									// multiply marginal (of this state of this question) and expected score of this state of this question
									sumOfScoreComponents += probabilities.get(tradedQuestions.get(questionIndex)).get(stateIndex) // marginal
										* scoreSummaryObject.getScoreComponents().get(scoreComponentIndex).getContributionToScoreEV();	 // expected
								}
								
								// assert that, for each question, the sum of expected score per state multiplied by its marginal (w/ assumptions) will result in the total expected score
								// i.e. scoreUserEV = Expected(D=d1)*P(D=d1) + Expected(D=d2)*P(D=d2) = Expected(E=e1)*P(E=e1) + Expected(E=e2)*P(E=e2) = Expected(F=f1)*P(F=f1) + Expected(F=f2)*P(F=f2)
								assertEquals("["+ engines.indexOf(engine) + "]"
										+ engine.toString()+ " , " + assumptionIds + assumedStates
										+ ", user = " + userId + ", question = " + tradedQuestions.get(questionIndex), 
										scoreSummaryObject.getScoreEV(), sumOfScoreComponents, ASSET_ERROR_MARGIN);
							}
						}
					}
				}
			} // end of value verification
			
		} // end of iteration of file names
		
	}	
	
	

	/**
	 * This value indicates how many test iterations (5-point tests) will be performed by default
	 * @return the howManyTradesToTest
	 */
	public int getHowManyTradesToTest() {
		return howManyTradesToTest;
	}

	/**
	 * This value indicates how many test iterations (5-point tests) will be performed by default
	 * @param howManyTradesToTest the howManyTradesToTest to set
	 */
	public void setHowManyTradesToTest(int maxQuantityOfIterations) {
		this.howManyTradesToTest = maxQuantityOfIterations;
	}

	/**
	 * File names to be used in {@link #testFiles()} 
	 * @return the fileNames
	 */
	public String[] getFileNames() {
		return fileNames;
	}

	/**
	 * File names to be used in {@link #testFiles()} 
	 * @param fileNames the fileNames to set
	 */
	public void setFileNames(String[] fileNames) {
		this.fileNames = fileNames;
	}

	/**
	 * @param isToTrace the isToTrace to set
	 */
	public void setToTrace(boolean isToTrace) {
		this.isToTrace = isToTrace;
	}

	/**
	 * @return the isToTrace
	 */
	public boolean isToTrace() {
		return isToTrace;
	}

//	/**
//	 * @param isToCompare the isToCompare to set
//	 */
//	public void setToCompare(boolean isToCompare) {
//		this.isToCompare = isToCompare;
//	}
//
//	/**
//	 * @return the isToCompare
//	 */
//	public boolean isToCompare() {
//		return isToCompare;
//	}

	/**
	 * @return the isToRoundEdit
	 */
	public boolean isToRoundEdit() {
		return isToRoundEdit;
	}

	/**
	 * @param isToRoundEdit the isToRoundEdit to set
	 */
	public void setToRoundEdit(boolean isToRoundEdit) {
		this.isToRoundEdit = isToRoundEdit;
	}

	/**
	 * This is a probNearEditLimitBias for the {@link #generateEdit(Long, int, int, List, List, FivePointTestType)}.
	 * This value , which is between 0 and 1 will indicate the probability of
	 * {@link #generateEdit(Long, int, int, List, List, FivePointTestType)} with {@link FivePointTestType#BETWEEN_LIMITS}
	 * to be closer to the extremes.
	 * @param probNearEditLimitBias the probNearEditLimitBias to set
	 */
	public void setBias(float bias) {
		this.probNearEditLimitBias = bias;
	}

	/**
	 * This is a probNearEditLimitBias for the {@link #generateEdit(Long, int, int, List, List, FivePointTestType)}.
	 * This value , which is between 0 and 1 will indicate the probability of
	 * {@link #generateEdit(Long, int, int, List, List, FivePointTestType)} with {@link FivePointTestType#BETWEEN_LIMITS}
	 * to be closer to the extremes.
	 * @return the probNearEditLimitBias
	 */
	public float getBias() {
		return probNearEditLimitBias;
	}
	
}
